
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserInterest
 * 
 */
export type UserInterest = $Result.DefaultSelection<Prisma.$UserInterestPayload>
/**
 * Model AvailabilitySlot
 * 
 */
export type AvailabilitySlot = $Result.DefaultSelection<Prisma.$AvailabilitySlotPayload>
/**
 * Model MatchProposal
 * 
 */
export type MatchProposal = $Result.DefaultSelection<Prisma.$MatchProposalPayload>
/**
 * Model Appointment
 * 
 */
export type Appointment = $Result.DefaultSelection<Prisma.$AppointmentPayload>
/**
 * Model AttendanceCheck
 * 
 */
export type AttendanceCheck = $Result.DefaultSelection<Prisma.$AttendanceCheckPayload>
/**
 * Model Report
 * 
 */
export type Report = $Result.DefaultSelection<Prisma.$ReportPayload>
/**
 * Model Sanction
 * 
 */
export type Sanction = $Result.DefaultSelection<Prisma.$SanctionPayload>
/**
 * Model Review
 * 
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const MatchStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  REJECTED: 'REJECTED'
};

export type MatchStatus = (typeof MatchStatus)[keyof typeof MatchStatus]


export const AppointmentStatus: {
  CONFIRMED: 'CONFIRMED',
  COMPLETED: 'COMPLETED',
  CANCELED: 'CANCELED',
  NO_SHOW: 'NO_SHOW'
};

export type AppointmentStatus = (typeof AppointmentStatus)[keyof typeof AppointmentStatus]


export const ReportStatus: {
  OPEN: 'OPEN',
  RESOLVED: 'RESOLVED',
  REJECTED: 'REJECTED'
};

export type ReportStatus = (typeof ReportStatus)[keyof typeof ReportStatus]


export const SanctionLevel: {
  WARNING: 'WARNING',
  SUSPEND_7D: 'SUSPEND_7D',
  SUSPEND_30D: 'SUSPEND_30D',
  BAN: 'BAN'
};

export type SanctionLevel = (typeof SanctionLevel)[keyof typeof SanctionLevel]

}

export type MatchStatus = $Enums.MatchStatus

export const MatchStatus: typeof $Enums.MatchStatus

export type AppointmentStatus = $Enums.AppointmentStatus

export const AppointmentStatus: typeof $Enums.AppointmentStatus

export type ReportStatus = $Enums.ReportStatus

export const ReportStatus: typeof $Enums.ReportStatus

export type SanctionLevel = $Enums.SanctionLevel

export const SanctionLevel: typeof $Enums.SanctionLevel

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userInterest`: Exposes CRUD operations for the **UserInterest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserInterests
    * const userInterests = await prisma.userInterest.findMany()
    * ```
    */
  get userInterest(): Prisma.UserInterestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.availabilitySlot`: Exposes CRUD operations for the **AvailabilitySlot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AvailabilitySlots
    * const availabilitySlots = await prisma.availabilitySlot.findMany()
    * ```
    */
  get availabilitySlot(): Prisma.AvailabilitySlotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.matchProposal`: Exposes CRUD operations for the **MatchProposal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MatchProposals
    * const matchProposals = await prisma.matchProposal.findMany()
    * ```
    */
  get matchProposal(): Prisma.MatchProposalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.appointment`: Exposes CRUD operations for the **Appointment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Appointments
    * const appointments = await prisma.appointment.findMany()
    * ```
    */
  get appointment(): Prisma.AppointmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendanceCheck`: Exposes CRUD operations for the **AttendanceCheck** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AttendanceChecks
    * const attendanceChecks = await prisma.attendanceCheck.findMany()
    * ```
    */
  get attendanceCheck(): Prisma.AttendanceCheckDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.report`: Exposes CRUD operations for the **Report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.report.findMany()
    * ```
    */
  get report(): Prisma.ReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sanction`: Exposes CRUD operations for the **Sanction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sanctions
    * const sanctions = await prisma.sanction.findMany()
    * ```
    */
  get sanction(): Prisma.SanctionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.2
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    UserInterest: 'UserInterest',
    AvailabilitySlot: 'AvailabilitySlot',
    MatchProposal: 'MatchProposal',
    Appointment: 'Appointment',
    AttendanceCheck: 'AttendanceCheck',
    Report: 'Report',
    Sanction: 'Sanction',
    Review: 'Review'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "userInterest" | "availabilitySlot" | "matchProposal" | "appointment" | "attendanceCheck" | "report" | "sanction" | "review"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserInterest: {
        payload: Prisma.$UserInterestPayload<ExtArgs>
        fields: Prisma.UserInterestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserInterestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInterestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserInterestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInterestPayload>
          }
          findFirst: {
            args: Prisma.UserInterestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInterestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserInterestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInterestPayload>
          }
          findMany: {
            args: Prisma.UserInterestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInterestPayload>[]
          }
          create: {
            args: Prisma.UserInterestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInterestPayload>
          }
          createMany: {
            args: Prisma.UserInterestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserInterestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInterestPayload>[]
          }
          delete: {
            args: Prisma.UserInterestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInterestPayload>
          }
          update: {
            args: Prisma.UserInterestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInterestPayload>
          }
          deleteMany: {
            args: Prisma.UserInterestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserInterestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserInterestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInterestPayload>[]
          }
          upsert: {
            args: Prisma.UserInterestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInterestPayload>
          }
          aggregate: {
            args: Prisma.UserInterestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserInterest>
          }
          groupBy: {
            args: Prisma.UserInterestGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserInterestGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserInterestCountArgs<ExtArgs>
            result: $Utils.Optional<UserInterestCountAggregateOutputType> | number
          }
        }
      }
      AvailabilitySlot: {
        payload: Prisma.$AvailabilitySlotPayload<ExtArgs>
        fields: Prisma.AvailabilitySlotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AvailabilitySlotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilitySlotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AvailabilitySlotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilitySlotPayload>
          }
          findFirst: {
            args: Prisma.AvailabilitySlotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilitySlotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AvailabilitySlotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilitySlotPayload>
          }
          findMany: {
            args: Prisma.AvailabilitySlotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilitySlotPayload>[]
          }
          create: {
            args: Prisma.AvailabilitySlotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilitySlotPayload>
          }
          createMany: {
            args: Prisma.AvailabilitySlotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AvailabilitySlotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilitySlotPayload>[]
          }
          delete: {
            args: Prisma.AvailabilitySlotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilitySlotPayload>
          }
          update: {
            args: Prisma.AvailabilitySlotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilitySlotPayload>
          }
          deleteMany: {
            args: Prisma.AvailabilitySlotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AvailabilitySlotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AvailabilitySlotUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilitySlotPayload>[]
          }
          upsert: {
            args: Prisma.AvailabilitySlotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilitySlotPayload>
          }
          aggregate: {
            args: Prisma.AvailabilitySlotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAvailabilitySlot>
          }
          groupBy: {
            args: Prisma.AvailabilitySlotGroupByArgs<ExtArgs>
            result: $Utils.Optional<AvailabilitySlotGroupByOutputType>[]
          }
          count: {
            args: Prisma.AvailabilitySlotCountArgs<ExtArgs>
            result: $Utils.Optional<AvailabilitySlotCountAggregateOutputType> | number
          }
        }
      }
      MatchProposal: {
        payload: Prisma.$MatchProposalPayload<ExtArgs>
        fields: Prisma.MatchProposalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MatchProposalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchProposalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MatchProposalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchProposalPayload>
          }
          findFirst: {
            args: Prisma.MatchProposalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchProposalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MatchProposalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchProposalPayload>
          }
          findMany: {
            args: Prisma.MatchProposalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchProposalPayload>[]
          }
          create: {
            args: Prisma.MatchProposalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchProposalPayload>
          }
          createMany: {
            args: Prisma.MatchProposalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MatchProposalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchProposalPayload>[]
          }
          delete: {
            args: Prisma.MatchProposalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchProposalPayload>
          }
          update: {
            args: Prisma.MatchProposalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchProposalPayload>
          }
          deleteMany: {
            args: Prisma.MatchProposalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MatchProposalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MatchProposalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchProposalPayload>[]
          }
          upsert: {
            args: Prisma.MatchProposalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchProposalPayload>
          }
          aggregate: {
            args: Prisma.MatchProposalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMatchProposal>
          }
          groupBy: {
            args: Prisma.MatchProposalGroupByArgs<ExtArgs>
            result: $Utils.Optional<MatchProposalGroupByOutputType>[]
          }
          count: {
            args: Prisma.MatchProposalCountArgs<ExtArgs>
            result: $Utils.Optional<MatchProposalCountAggregateOutputType> | number
          }
        }
      }
      Appointment: {
        payload: Prisma.$AppointmentPayload<ExtArgs>
        fields: Prisma.AppointmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppointmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppointmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findFirst: {
            args: Prisma.AppointmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppointmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findMany: {
            args: Prisma.AppointmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          create: {
            args: Prisma.AppointmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          createMany: {
            args: Prisma.AppointmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AppointmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          delete: {
            args: Prisma.AppointmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          update: {
            args: Prisma.AppointmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          deleteMany: {
            args: Prisma.AppointmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppointmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AppointmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          upsert: {
            args: Prisma.AppointmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          aggregate: {
            args: Prisma.AppointmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppointment>
          }
          groupBy: {
            args: Prisma.AppointmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppointmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppointmentCountArgs<ExtArgs>
            result: $Utils.Optional<AppointmentCountAggregateOutputType> | number
          }
        }
      }
      AttendanceCheck: {
        payload: Prisma.$AttendanceCheckPayload<ExtArgs>
        fields: Prisma.AttendanceCheckFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceCheckFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceCheckPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceCheckFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceCheckPayload>
          }
          findFirst: {
            args: Prisma.AttendanceCheckFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceCheckPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceCheckFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceCheckPayload>
          }
          findMany: {
            args: Prisma.AttendanceCheckFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceCheckPayload>[]
          }
          create: {
            args: Prisma.AttendanceCheckCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceCheckPayload>
          }
          createMany: {
            args: Prisma.AttendanceCheckCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendanceCheckCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceCheckPayload>[]
          }
          delete: {
            args: Prisma.AttendanceCheckDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceCheckPayload>
          }
          update: {
            args: Prisma.AttendanceCheckUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceCheckPayload>
          }
          deleteMany: {
            args: Prisma.AttendanceCheckDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceCheckUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttendanceCheckUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceCheckPayload>[]
          }
          upsert: {
            args: Prisma.AttendanceCheckUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceCheckPayload>
          }
          aggregate: {
            args: Prisma.AttendanceCheckAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendanceCheck>
          }
          groupBy: {
            args: Prisma.AttendanceCheckGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceCheckGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceCheckCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceCheckCountAggregateOutputType> | number
          }
        }
      }
      Report: {
        payload: Prisma.$ReportPayload<ExtArgs>
        fields: Prisma.ReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findFirst: {
            args: Prisma.ReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findMany: {
            args: Prisma.ReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          create: {
            args: Prisma.ReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          createMany: {
            args: Prisma.ReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          delete: {
            args: Prisma.ReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          update: {
            args: Prisma.ReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          deleteMany: {
            args: Prisma.ReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          upsert: {
            args: Prisma.ReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          aggregate: {
            args: Prisma.ReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReport>
          }
          groupBy: {
            args: Prisma.ReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportCountArgs<ExtArgs>
            result: $Utils.Optional<ReportCountAggregateOutputType> | number
          }
        }
      }
      Sanction: {
        payload: Prisma.$SanctionPayload<ExtArgs>
        fields: Prisma.SanctionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SanctionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SanctionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SanctionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SanctionPayload>
          }
          findFirst: {
            args: Prisma.SanctionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SanctionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SanctionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SanctionPayload>
          }
          findMany: {
            args: Prisma.SanctionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SanctionPayload>[]
          }
          create: {
            args: Prisma.SanctionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SanctionPayload>
          }
          createMany: {
            args: Prisma.SanctionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SanctionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SanctionPayload>[]
          }
          delete: {
            args: Prisma.SanctionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SanctionPayload>
          }
          update: {
            args: Prisma.SanctionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SanctionPayload>
          }
          deleteMany: {
            args: Prisma.SanctionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SanctionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SanctionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SanctionPayload>[]
          }
          upsert: {
            args: Prisma.SanctionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SanctionPayload>
          }
          aggregate: {
            args: Prisma.SanctionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSanction>
          }
          groupBy: {
            args: Prisma.SanctionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SanctionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SanctionCountArgs<ExtArgs>
            result: $Utils.Optional<SanctionCountAggregateOutputType> | number
          }
        }
      }
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>
        fields: Prisma.ReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    userInterest?: UserInterestOmit
    availabilitySlot?: AvailabilitySlotOmit
    matchProposal?: MatchProposalOmit
    appointment?: AppointmentOmit
    attendanceCheck?: AttendanceCheckOmit
    report?: ReportOmit
    sanction?: SanctionOmit
    review?: ReviewOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    interests: number
    availability: number
    proposer: number
    partner: number
    appointmentsA: number
    appointmentsB: number
    checks: number
    reports: number
    sanctions: number
    reviewsGiven: number
    reviewsRecv: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interests?: boolean | UserCountOutputTypeCountInterestsArgs
    availability?: boolean | UserCountOutputTypeCountAvailabilityArgs
    proposer?: boolean | UserCountOutputTypeCountProposerArgs
    partner?: boolean | UserCountOutputTypeCountPartnerArgs
    appointmentsA?: boolean | UserCountOutputTypeCountAppointmentsAArgs
    appointmentsB?: boolean | UserCountOutputTypeCountAppointmentsBArgs
    checks?: boolean | UserCountOutputTypeCountChecksArgs
    reports?: boolean | UserCountOutputTypeCountReportsArgs
    sanctions?: boolean | UserCountOutputTypeCountSanctionsArgs
    reviewsGiven?: boolean | UserCountOutputTypeCountReviewsGivenArgs
    reviewsRecv?: boolean | UserCountOutputTypeCountReviewsRecvArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInterestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserInterestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAvailabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvailabilitySlotWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProposerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchProposalWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPartnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchProposalWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAppointmentsAArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAppointmentsBArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceCheckWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSanctionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SanctionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewsGivenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewsRecvArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }


  /**
   * Count Type AppointmentCountOutputType
   */

  export type AppointmentCountOutputType = {
    checks: number
    reports: number
    reviews: number
  }

  export type AppointmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    checks?: boolean | AppointmentCountOutputTypeCountChecksArgs
    reports?: boolean | AppointmentCountOutputTypeCountReportsArgs
    reviews?: boolean | AppointmentCountOutputTypeCountReviewsArgs
  }

  // Custom InputTypes
  /**
   * AppointmentCountOutputType without action
   */
  export type AppointmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentCountOutputType
     */
    select?: AppointmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AppointmentCountOutputType without action
   */
  export type AppointmentCountOutputTypeCountChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceCheckWhereInput
  }

  /**
   * AppointmentCountOutputType without action
   */
  export type AppointmentCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * AppointmentCountOutputType without action
   */
  export type AppointmentCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    trustScore: number | null
  }

  export type UserSumAggregateOutputType = {
    trustScore: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    provider: string | null
    nickname: string | null
    bio: string | null
    region: string | null
    trustScore: number | null
    phoneVerified: boolean | null
    blocked: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    provider: string | null
    nickname: string | null
    bio: string | null
    region: string | null
    trustScore: number | null
    phoneVerified: boolean | null
    blocked: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    provider: number
    nickname: number
    bio: number
    region: number
    trustScore: number
    phoneVerified: number
    blocked: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    trustScore?: true
  }

  export type UserSumAggregateInputType = {
    trustScore?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    provider?: true
    nickname?: true
    bio?: true
    region?: true
    trustScore?: true
    phoneVerified?: true
    blocked?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    provider?: true
    nickname?: true
    bio?: true
    region?: true
    trustScore?: true
    phoneVerified?: true
    blocked?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    provider?: true
    nickname?: true
    bio?: true
    region?: true
    trustScore?: true
    phoneVerified?: true
    blocked?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    provider: string
    nickname: string
    bio: string | null
    region: string | null
    trustScore: number
    phoneVerified: boolean
    blocked: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    provider?: boolean
    nickname?: boolean
    bio?: boolean
    region?: boolean
    trustScore?: boolean
    phoneVerified?: boolean
    blocked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    interests?: boolean | User$interestsArgs<ExtArgs>
    availability?: boolean | User$availabilityArgs<ExtArgs>
    proposer?: boolean | User$proposerArgs<ExtArgs>
    partner?: boolean | User$partnerArgs<ExtArgs>
    appointmentsA?: boolean | User$appointmentsAArgs<ExtArgs>
    appointmentsB?: boolean | User$appointmentsBArgs<ExtArgs>
    checks?: boolean | User$checksArgs<ExtArgs>
    reports?: boolean | User$reportsArgs<ExtArgs>
    sanctions?: boolean | User$sanctionsArgs<ExtArgs>
    reviewsGiven?: boolean | User$reviewsGivenArgs<ExtArgs>
    reviewsRecv?: boolean | User$reviewsRecvArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    provider?: boolean
    nickname?: boolean
    bio?: boolean
    region?: boolean
    trustScore?: boolean
    phoneVerified?: boolean
    blocked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    provider?: boolean
    nickname?: boolean
    bio?: boolean
    region?: boolean
    trustScore?: boolean
    phoneVerified?: boolean
    blocked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    provider?: boolean
    nickname?: boolean
    bio?: boolean
    region?: boolean
    trustScore?: boolean
    phoneVerified?: boolean
    blocked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "provider" | "nickname" | "bio" | "region" | "trustScore" | "phoneVerified" | "blocked" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interests?: boolean | User$interestsArgs<ExtArgs>
    availability?: boolean | User$availabilityArgs<ExtArgs>
    proposer?: boolean | User$proposerArgs<ExtArgs>
    partner?: boolean | User$partnerArgs<ExtArgs>
    appointmentsA?: boolean | User$appointmentsAArgs<ExtArgs>
    appointmentsB?: boolean | User$appointmentsBArgs<ExtArgs>
    checks?: boolean | User$checksArgs<ExtArgs>
    reports?: boolean | User$reportsArgs<ExtArgs>
    sanctions?: boolean | User$sanctionsArgs<ExtArgs>
    reviewsGiven?: boolean | User$reviewsGivenArgs<ExtArgs>
    reviewsRecv?: boolean | User$reviewsRecvArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      interests: Prisma.$UserInterestPayload<ExtArgs>[]
      availability: Prisma.$AvailabilitySlotPayload<ExtArgs>[]
      proposer: Prisma.$MatchProposalPayload<ExtArgs>[]
      partner: Prisma.$MatchProposalPayload<ExtArgs>[]
      appointmentsA: Prisma.$AppointmentPayload<ExtArgs>[]
      appointmentsB: Prisma.$AppointmentPayload<ExtArgs>[]
      checks: Prisma.$AttendanceCheckPayload<ExtArgs>[]
      reports: Prisma.$ReportPayload<ExtArgs>[]
      sanctions: Prisma.$SanctionPayload<ExtArgs>[]
      reviewsGiven: Prisma.$ReviewPayload<ExtArgs>[]
      reviewsRecv: Prisma.$ReviewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      provider: string
      nickname: string
      bio: string | null
      region: string | null
      trustScore: number
      phoneVerified: boolean
      blocked: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    interests<T extends User$interestsArgs<ExtArgs> = {}>(args?: Subset<T, User$interestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInterestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    availability<T extends User$availabilityArgs<ExtArgs> = {}>(args?: Subset<T, User$availabilityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvailabilitySlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    proposer<T extends User$proposerArgs<ExtArgs> = {}>(args?: Subset<T, User$proposerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchProposalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    partner<T extends User$partnerArgs<ExtArgs> = {}>(args?: Subset<T, User$partnerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchProposalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    appointmentsA<T extends User$appointmentsAArgs<ExtArgs> = {}>(args?: Subset<T, User$appointmentsAArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    appointmentsB<T extends User$appointmentsBArgs<ExtArgs> = {}>(args?: Subset<T, User$appointmentsBArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    checks<T extends User$checksArgs<ExtArgs> = {}>(args?: Subset<T, User$checksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceCheckPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reports<T extends User$reportsArgs<ExtArgs> = {}>(args?: Subset<T, User$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sanctions<T extends User$sanctionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sanctionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SanctionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviewsGiven<T extends User$reviewsGivenArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewsGivenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviewsRecv<T extends User$reviewsRecvArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewsRecvArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly provider: FieldRef<"User", 'String'>
    readonly nickname: FieldRef<"User", 'String'>
    readonly bio: FieldRef<"User", 'String'>
    readonly region: FieldRef<"User", 'String'>
    readonly trustScore: FieldRef<"User", 'Int'>
    readonly phoneVerified: FieldRef<"User", 'Boolean'>
    readonly blocked: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.interests
   */
  export type User$interestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInterest
     */
    select?: UserInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInterest
     */
    omit?: UserInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInterestInclude<ExtArgs> | null
    where?: UserInterestWhereInput
    orderBy?: UserInterestOrderByWithRelationInput | UserInterestOrderByWithRelationInput[]
    cursor?: UserInterestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserInterestScalarFieldEnum | UserInterestScalarFieldEnum[]
  }

  /**
   * User.availability
   */
  export type User$availabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvailabilitySlot
     */
    select?: AvailabilitySlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvailabilitySlot
     */
    omit?: AvailabilitySlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilitySlotInclude<ExtArgs> | null
    where?: AvailabilitySlotWhereInput
    orderBy?: AvailabilitySlotOrderByWithRelationInput | AvailabilitySlotOrderByWithRelationInput[]
    cursor?: AvailabilitySlotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AvailabilitySlotScalarFieldEnum | AvailabilitySlotScalarFieldEnum[]
  }

  /**
   * User.proposer
   */
  export type User$proposerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchProposal
     */
    select?: MatchProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchProposal
     */
    omit?: MatchProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchProposalInclude<ExtArgs> | null
    where?: MatchProposalWhereInput
    orderBy?: MatchProposalOrderByWithRelationInput | MatchProposalOrderByWithRelationInput[]
    cursor?: MatchProposalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchProposalScalarFieldEnum | MatchProposalScalarFieldEnum[]
  }

  /**
   * User.partner
   */
  export type User$partnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchProposal
     */
    select?: MatchProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchProposal
     */
    omit?: MatchProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchProposalInclude<ExtArgs> | null
    where?: MatchProposalWhereInput
    orderBy?: MatchProposalOrderByWithRelationInput | MatchProposalOrderByWithRelationInput[]
    cursor?: MatchProposalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchProposalScalarFieldEnum | MatchProposalScalarFieldEnum[]
  }

  /**
   * User.appointmentsA
   */
  export type User$appointmentsAArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * User.appointmentsB
   */
  export type User$appointmentsBArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * User.checks
   */
  export type User$checksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceCheck
     */
    select?: AttendanceCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceCheck
     */
    omit?: AttendanceCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceCheckInclude<ExtArgs> | null
    where?: AttendanceCheckWhereInput
    orderBy?: AttendanceCheckOrderByWithRelationInput | AttendanceCheckOrderByWithRelationInput[]
    cursor?: AttendanceCheckWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceCheckScalarFieldEnum | AttendanceCheckScalarFieldEnum[]
  }

  /**
   * User.reports
   */
  export type User$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * User.sanctions
   */
  export type User$sanctionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sanction
     */
    select?: SanctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sanction
     */
    omit?: SanctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SanctionInclude<ExtArgs> | null
    where?: SanctionWhereInput
    orderBy?: SanctionOrderByWithRelationInput | SanctionOrderByWithRelationInput[]
    cursor?: SanctionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SanctionScalarFieldEnum | SanctionScalarFieldEnum[]
  }

  /**
   * User.reviewsGiven
   */
  export type User$reviewsGivenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * User.reviewsRecv
   */
  export type User$reviewsRecvArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserInterest
   */

  export type AggregateUserInterest = {
    _count: UserInterestCountAggregateOutputType | null
    _min: UserInterestMinAggregateOutputType | null
    _max: UserInterestMaxAggregateOutputType | null
  }

  export type UserInterestMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
  }

  export type UserInterestMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
  }

  export type UserInterestCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    _all: number
  }


  export type UserInterestMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
  }

  export type UserInterestMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
  }

  export type UserInterestCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    _all?: true
  }

  export type UserInterestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserInterest to aggregate.
     */
    where?: UserInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInterests to fetch.
     */
    orderBy?: UserInterestOrderByWithRelationInput | UserInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserInterests
    **/
    _count?: true | UserInterestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserInterestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserInterestMaxAggregateInputType
  }

  export type GetUserInterestAggregateType<T extends UserInterestAggregateArgs> = {
        [P in keyof T & keyof AggregateUserInterest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserInterest[P]>
      : GetScalarType<T[P], AggregateUserInterest[P]>
  }




  export type UserInterestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserInterestWhereInput
    orderBy?: UserInterestOrderByWithAggregationInput | UserInterestOrderByWithAggregationInput[]
    by: UserInterestScalarFieldEnum[] | UserInterestScalarFieldEnum
    having?: UserInterestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserInterestCountAggregateInputType | true
    _min?: UserInterestMinAggregateInputType
    _max?: UserInterestMaxAggregateInputType
  }

  export type UserInterestGroupByOutputType = {
    id: string
    userId: string
    name: string
    _count: UserInterestCountAggregateOutputType | null
    _min: UserInterestMinAggregateOutputType | null
    _max: UserInterestMaxAggregateOutputType | null
  }

  type GetUserInterestGroupByPayload<T extends UserInterestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserInterestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserInterestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserInterestGroupByOutputType[P]>
            : GetScalarType<T[P], UserInterestGroupByOutputType[P]>
        }
      >
    >


  export type UserInterestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userInterest"]>

  export type UserInterestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userInterest"]>

  export type UserInterestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userInterest"]>

  export type UserInterestSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
  }

  export type UserInterestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name", ExtArgs["result"]["userInterest"]>
  export type UserInterestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserInterestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserInterestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserInterestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserInterest"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
    }, ExtArgs["result"]["userInterest"]>
    composites: {}
  }

  type UserInterestGetPayload<S extends boolean | null | undefined | UserInterestDefaultArgs> = $Result.GetResult<Prisma.$UserInterestPayload, S>

  type UserInterestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserInterestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserInterestCountAggregateInputType | true
    }

  export interface UserInterestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserInterest'], meta: { name: 'UserInterest' } }
    /**
     * Find zero or one UserInterest that matches the filter.
     * @param {UserInterestFindUniqueArgs} args - Arguments to find a UserInterest
     * @example
     * // Get one UserInterest
     * const userInterest = await prisma.userInterest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserInterestFindUniqueArgs>(args: SelectSubset<T, UserInterestFindUniqueArgs<ExtArgs>>): Prisma__UserInterestClient<$Result.GetResult<Prisma.$UserInterestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserInterest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserInterestFindUniqueOrThrowArgs} args - Arguments to find a UserInterest
     * @example
     * // Get one UserInterest
     * const userInterest = await prisma.userInterest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserInterestFindUniqueOrThrowArgs>(args: SelectSubset<T, UserInterestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserInterestClient<$Result.GetResult<Prisma.$UserInterestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserInterest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInterestFindFirstArgs} args - Arguments to find a UserInterest
     * @example
     * // Get one UserInterest
     * const userInterest = await prisma.userInterest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserInterestFindFirstArgs>(args?: SelectSubset<T, UserInterestFindFirstArgs<ExtArgs>>): Prisma__UserInterestClient<$Result.GetResult<Prisma.$UserInterestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserInterest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInterestFindFirstOrThrowArgs} args - Arguments to find a UserInterest
     * @example
     * // Get one UserInterest
     * const userInterest = await prisma.userInterest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserInterestFindFirstOrThrowArgs>(args?: SelectSubset<T, UserInterestFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserInterestClient<$Result.GetResult<Prisma.$UserInterestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserInterests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInterestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserInterests
     * const userInterests = await prisma.userInterest.findMany()
     * 
     * // Get first 10 UserInterests
     * const userInterests = await prisma.userInterest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userInterestWithIdOnly = await prisma.userInterest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserInterestFindManyArgs>(args?: SelectSubset<T, UserInterestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInterestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserInterest.
     * @param {UserInterestCreateArgs} args - Arguments to create a UserInterest.
     * @example
     * // Create one UserInterest
     * const UserInterest = await prisma.userInterest.create({
     *   data: {
     *     // ... data to create a UserInterest
     *   }
     * })
     * 
     */
    create<T extends UserInterestCreateArgs>(args: SelectSubset<T, UserInterestCreateArgs<ExtArgs>>): Prisma__UserInterestClient<$Result.GetResult<Prisma.$UserInterestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserInterests.
     * @param {UserInterestCreateManyArgs} args - Arguments to create many UserInterests.
     * @example
     * // Create many UserInterests
     * const userInterest = await prisma.userInterest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserInterestCreateManyArgs>(args?: SelectSubset<T, UserInterestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserInterests and returns the data saved in the database.
     * @param {UserInterestCreateManyAndReturnArgs} args - Arguments to create many UserInterests.
     * @example
     * // Create many UserInterests
     * const userInterest = await prisma.userInterest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserInterests and only return the `id`
     * const userInterestWithIdOnly = await prisma.userInterest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserInterestCreateManyAndReturnArgs>(args?: SelectSubset<T, UserInterestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInterestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserInterest.
     * @param {UserInterestDeleteArgs} args - Arguments to delete one UserInterest.
     * @example
     * // Delete one UserInterest
     * const UserInterest = await prisma.userInterest.delete({
     *   where: {
     *     // ... filter to delete one UserInterest
     *   }
     * })
     * 
     */
    delete<T extends UserInterestDeleteArgs>(args: SelectSubset<T, UserInterestDeleteArgs<ExtArgs>>): Prisma__UserInterestClient<$Result.GetResult<Prisma.$UserInterestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserInterest.
     * @param {UserInterestUpdateArgs} args - Arguments to update one UserInterest.
     * @example
     * // Update one UserInterest
     * const userInterest = await prisma.userInterest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserInterestUpdateArgs>(args: SelectSubset<T, UserInterestUpdateArgs<ExtArgs>>): Prisma__UserInterestClient<$Result.GetResult<Prisma.$UserInterestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserInterests.
     * @param {UserInterestDeleteManyArgs} args - Arguments to filter UserInterests to delete.
     * @example
     * // Delete a few UserInterests
     * const { count } = await prisma.userInterest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserInterestDeleteManyArgs>(args?: SelectSubset<T, UserInterestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserInterests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInterestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserInterests
     * const userInterest = await prisma.userInterest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserInterestUpdateManyArgs>(args: SelectSubset<T, UserInterestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserInterests and returns the data updated in the database.
     * @param {UserInterestUpdateManyAndReturnArgs} args - Arguments to update many UserInterests.
     * @example
     * // Update many UserInterests
     * const userInterest = await prisma.userInterest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserInterests and only return the `id`
     * const userInterestWithIdOnly = await prisma.userInterest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserInterestUpdateManyAndReturnArgs>(args: SelectSubset<T, UserInterestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInterestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserInterest.
     * @param {UserInterestUpsertArgs} args - Arguments to update or create a UserInterest.
     * @example
     * // Update or create a UserInterest
     * const userInterest = await prisma.userInterest.upsert({
     *   create: {
     *     // ... data to create a UserInterest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserInterest we want to update
     *   }
     * })
     */
    upsert<T extends UserInterestUpsertArgs>(args: SelectSubset<T, UserInterestUpsertArgs<ExtArgs>>): Prisma__UserInterestClient<$Result.GetResult<Prisma.$UserInterestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserInterests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInterestCountArgs} args - Arguments to filter UserInterests to count.
     * @example
     * // Count the number of UserInterests
     * const count = await prisma.userInterest.count({
     *   where: {
     *     // ... the filter for the UserInterests we want to count
     *   }
     * })
    **/
    count<T extends UserInterestCountArgs>(
      args?: Subset<T, UserInterestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserInterestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserInterest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInterestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserInterestAggregateArgs>(args: Subset<T, UserInterestAggregateArgs>): Prisma.PrismaPromise<GetUserInterestAggregateType<T>>

    /**
     * Group by UserInterest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInterestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserInterestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserInterestGroupByArgs['orderBy'] }
        : { orderBy?: UserInterestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserInterestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserInterestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserInterest model
   */
  readonly fields: UserInterestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserInterest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserInterestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserInterest model
   */
  interface UserInterestFieldRefs {
    readonly id: FieldRef<"UserInterest", 'String'>
    readonly userId: FieldRef<"UserInterest", 'String'>
    readonly name: FieldRef<"UserInterest", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserInterest findUnique
   */
  export type UserInterestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInterest
     */
    select?: UserInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInterest
     */
    omit?: UserInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInterestInclude<ExtArgs> | null
    /**
     * Filter, which UserInterest to fetch.
     */
    where: UserInterestWhereUniqueInput
  }

  /**
   * UserInterest findUniqueOrThrow
   */
  export type UserInterestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInterest
     */
    select?: UserInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInterest
     */
    omit?: UserInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInterestInclude<ExtArgs> | null
    /**
     * Filter, which UserInterest to fetch.
     */
    where: UserInterestWhereUniqueInput
  }

  /**
   * UserInterest findFirst
   */
  export type UserInterestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInterest
     */
    select?: UserInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInterest
     */
    omit?: UserInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInterestInclude<ExtArgs> | null
    /**
     * Filter, which UserInterest to fetch.
     */
    where?: UserInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInterests to fetch.
     */
    orderBy?: UserInterestOrderByWithRelationInput | UserInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserInterests.
     */
    cursor?: UserInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserInterests.
     */
    distinct?: UserInterestScalarFieldEnum | UserInterestScalarFieldEnum[]
  }

  /**
   * UserInterest findFirstOrThrow
   */
  export type UserInterestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInterest
     */
    select?: UserInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInterest
     */
    omit?: UserInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInterestInclude<ExtArgs> | null
    /**
     * Filter, which UserInterest to fetch.
     */
    where?: UserInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInterests to fetch.
     */
    orderBy?: UserInterestOrderByWithRelationInput | UserInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserInterests.
     */
    cursor?: UserInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserInterests.
     */
    distinct?: UserInterestScalarFieldEnum | UserInterestScalarFieldEnum[]
  }

  /**
   * UserInterest findMany
   */
  export type UserInterestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInterest
     */
    select?: UserInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInterest
     */
    omit?: UserInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInterestInclude<ExtArgs> | null
    /**
     * Filter, which UserInterests to fetch.
     */
    where?: UserInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInterests to fetch.
     */
    orderBy?: UserInterestOrderByWithRelationInput | UserInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserInterests.
     */
    cursor?: UserInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInterests.
     */
    skip?: number
    distinct?: UserInterestScalarFieldEnum | UserInterestScalarFieldEnum[]
  }

  /**
   * UserInterest create
   */
  export type UserInterestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInterest
     */
    select?: UserInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInterest
     */
    omit?: UserInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInterestInclude<ExtArgs> | null
    /**
     * The data needed to create a UserInterest.
     */
    data: XOR<UserInterestCreateInput, UserInterestUncheckedCreateInput>
  }

  /**
   * UserInterest createMany
   */
  export type UserInterestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserInterests.
     */
    data: UserInterestCreateManyInput | UserInterestCreateManyInput[]
  }

  /**
   * UserInterest createManyAndReturn
   */
  export type UserInterestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInterest
     */
    select?: UserInterestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserInterest
     */
    omit?: UserInterestOmit<ExtArgs> | null
    /**
     * The data used to create many UserInterests.
     */
    data: UserInterestCreateManyInput | UserInterestCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInterestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserInterest update
   */
  export type UserInterestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInterest
     */
    select?: UserInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInterest
     */
    omit?: UserInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInterestInclude<ExtArgs> | null
    /**
     * The data needed to update a UserInterest.
     */
    data: XOR<UserInterestUpdateInput, UserInterestUncheckedUpdateInput>
    /**
     * Choose, which UserInterest to update.
     */
    where: UserInterestWhereUniqueInput
  }

  /**
   * UserInterest updateMany
   */
  export type UserInterestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserInterests.
     */
    data: XOR<UserInterestUpdateManyMutationInput, UserInterestUncheckedUpdateManyInput>
    /**
     * Filter which UserInterests to update
     */
    where?: UserInterestWhereInput
    /**
     * Limit how many UserInterests to update.
     */
    limit?: number
  }

  /**
   * UserInterest updateManyAndReturn
   */
  export type UserInterestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInterest
     */
    select?: UserInterestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserInterest
     */
    omit?: UserInterestOmit<ExtArgs> | null
    /**
     * The data used to update UserInterests.
     */
    data: XOR<UserInterestUpdateManyMutationInput, UserInterestUncheckedUpdateManyInput>
    /**
     * Filter which UserInterests to update
     */
    where?: UserInterestWhereInput
    /**
     * Limit how many UserInterests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInterestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserInterest upsert
   */
  export type UserInterestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInterest
     */
    select?: UserInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInterest
     */
    omit?: UserInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInterestInclude<ExtArgs> | null
    /**
     * The filter to search for the UserInterest to update in case it exists.
     */
    where: UserInterestWhereUniqueInput
    /**
     * In case the UserInterest found by the `where` argument doesn't exist, create a new UserInterest with this data.
     */
    create: XOR<UserInterestCreateInput, UserInterestUncheckedCreateInput>
    /**
     * In case the UserInterest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserInterestUpdateInput, UserInterestUncheckedUpdateInput>
  }

  /**
   * UserInterest delete
   */
  export type UserInterestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInterest
     */
    select?: UserInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInterest
     */
    omit?: UserInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInterestInclude<ExtArgs> | null
    /**
     * Filter which UserInterest to delete.
     */
    where: UserInterestWhereUniqueInput
  }

  /**
   * UserInterest deleteMany
   */
  export type UserInterestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserInterests to delete
     */
    where?: UserInterestWhereInput
    /**
     * Limit how many UserInterests to delete.
     */
    limit?: number
  }

  /**
   * UserInterest without action
   */
  export type UserInterestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInterest
     */
    select?: UserInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInterest
     */
    omit?: UserInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInterestInclude<ExtArgs> | null
  }


  /**
   * Model AvailabilitySlot
   */

  export type AggregateAvailabilitySlot = {
    _count: AvailabilitySlotCountAggregateOutputType | null
    _avg: AvailabilitySlotAvgAggregateOutputType | null
    _sum: AvailabilitySlotSumAggregateOutputType | null
    _min: AvailabilitySlotMinAggregateOutputType | null
    _max: AvailabilitySlotMaxAggregateOutputType | null
  }

  export type AvailabilitySlotAvgAggregateOutputType = {
    weekday: number | null
  }

  export type AvailabilitySlotSumAggregateOutputType = {
    weekday: number | null
  }

  export type AvailabilitySlotMinAggregateOutputType = {
    id: string | null
    userId: string | null
    weekday: number | null
    startTime: string | null
    endTime: string | null
    area: string | null
    createdAt: Date | null
  }

  export type AvailabilitySlotMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    weekday: number | null
    startTime: string | null
    endTime: string | null
    area: string | null
    createdAt: Date | null
  }

  export type AvailabilitySlotCountAggregateOutputType = {
    id: number
    userId: number
    weekday: number
    startTime: number
    endTime: number
    area: number
    createdAt: number
    _all: number
  }


  export type AvailabilitySlotAvgAggregateInputType = {
    weekday?: true
  }

  export type AvailabilitySlotSumAggregateInputType = {
    weekday?: true
  }

  export type AvailabilitySlotMinAggregateInputType = {
    id?: true
    userId?: true
    weekday?: true
    startTime?: true
    endTime?: true
    area?: true
    createdAt?: true
  }

  export type AvailabilitySlotMaxAggregateInputType = {
    id?: true
    userId?: true
    weekday?: true
    startTime?: true
    endTime?: true
    area?: true
    createdAt?: true
  }

  export type AvailabilitySlotCountAggregateInputType = {
    id?: true
    userId?: true
    weekday?: true
    startTime?: true
    endTime?: true
    area?: true
    createdAt?: true
    _all?: true
  }

  export type AvailabilitySlotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AvailabilitySlot to aggregate.
     */
    where?: AvailabilitySlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AvailabilitySlots to fetch.
     */
    orderBy?: AvailabilitySlotOrderByWithRelationInput | AvailabilitySlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AvailabilitySlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AvailabilitySlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AvailabilitySlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AvailabilitySlots
    **/
    _count?: true | AvailabilitySlotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AvailabilitySlotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AvailabilitySlotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AvailabilitySlotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AvailabilitySlotMaxAggregateInputType
  }

  export type GetAvailabilitySlotAggregateType<T extends AvailabilitySlotAggregateArgs> = {
        [P in keyof T & keyof AggregateAvailabilitySlot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAvailabilitySlot[P]>
      : GetScalarType<T[P], AggregateAvailabilitySlot[P]>
  }




  export type AvailabilitySlotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvailabilitySlotWhereInput
    orderBy?: AvailabilitySlotOrderByWithAggregationInput | AvailabilitySlotOrderByWithAggregationInput[]
    by: AvailabilitySlotScalarFieldEnum[] | AvailabilitySlotScalarFieldEnum
    having?: AvailabilitySlotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AvailabilitySlotCountAggregateInputType | true
    _avg?: AvailabilitySlotAvgAggregateInputType
    _sum?: AvailabilitySlotSumAggregateInputType
    _min?: AvailabilitySlotMinAggregateInputType
    _max?: AvailabilitySlotMaxAggregateInputType
  }

  export type AvailabilitySlotGroupByOutputType = {
    id: string
    userId: string
    weekday: number
    startTime: string
    endTime: string
    area: string
    createdAt: Date
    _count: AvailabilitySlotCountAggregateOutputType | null
    _avg: AvailabilitySlotAvgAggregateOutputType | null
    _sum: AvailabilitySlotSumAggregateOutputType | null
    _min: AvailabilitySlotMinAggregateOutputType | null
    _max: AvailabilitySlotMaxAggregateOutputType | null
  }

  type GetAvailabilitySlotGroupByPayload<T extends AvailabilitySlotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AvailabilitySlotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AvailabilitySlotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AvailabilitySlotGroupByOutputType[P]>
            : GetScalarType<T[P], AvailabilitySlotGroupByOutputType[P]>
        }
      >
    >


  export type AvailabilitySlotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    weekday?: boolean
    startTime?: boolean
    endTime?: boolean
    area?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["availabilitySlot"]>

  export type AvailabilitySlotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    weekday?: boolean
    startTime?: boolean
    endTime?: boolean
    area?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["availabilitySlot"]>

  export type AvailabilitySlotSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    weekday?: boolean
    startTime?: boolean
    endTime?: boolean
    area?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["availabilitySlot"]>

  export type AvailabilitySlotSelectScalar = {
    id?: boolean
    userId?: boolean
    weekday?: boolean
    startTime?: boolean
    endTime?: boolean
    area?: boolean
    createdAt?: boolean
  }

  export type AvailabilitySlotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "weekday" | "startTime" | "endTime" | "area" | "createdAt", ExtArgs["result"]["availabilitySlot"]>
  export type AvailabilitySlotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AvailabilitySlotIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AvailabilitySlotIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AvailabilitySlotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AvailabilitySlot"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      weekday: number
      startTime: string
      endTime: string
      area: string
      createdAt: Date
    }, ExtArgs["result"]["availabilitySlot"]>
    composites: {}
  }

  type AvailabilitySlotGetPayload<S extends boolean | null | undefined | AvailabilitySlotDefaultArgs> = $Result.GetResult<Prisma.$AvailabilitySlotPayload, S>

  type AvailabilitySlotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AvailabilitySlotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AvailabilitySlotCountAggregateInputType | true
    }

  export interface AvailabilitySlotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AvailabilitySlot'], meta: { name: 'AvailabilitySlot' } }
    /**
     * Find zero or one AvailabilitySlot that matches the filter.
     * @param {AvailabilitySlotFindUniqueArgs} args - Arguments to find a AvailabilitySlot
     * @example
     * // Get one AvailabilitySlot
     * const availabilitySlot = await prisma.availabilitySlot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AvailabilitySlotFindUniqueArgs>(args: SelectSubset<T, AvailabilitySlotFindUniqueArgs<ExtArgs>>): Prisma__AvailabilitySlotClient<$Result.GetResult<Prisma.$AvailabilitySlotPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AvailabilitySlot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AvailabilitySlotFindUniqueOrThrowArgs} args - Arguments to find a AvailabilitySlot
     * @example
     * // Get one AvailabilitySlot
     * const availabilitySlot = await prisma.availabilitySlot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AvailabilitySlotFindUniqueOrThrowArgs>(args: SelectSubset<T, AvailabilitySlotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AvailabilitySlotClient<$Result.GetResult<Prisma.$AvailabilitySlotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AvailabilitySlot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilitySlotFindFirstArgs} args - Arguments to find a AvailabilitySlot
     * @example
     * // Get one AvailabilitySlot
     * const availabilitySlot = await prisma.availabilitySlot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AvailabilitySlotFindFirstArgs>(args?: SelectSubset<T, AvailabilitySlotFindFirstArgs<ExtArgs>>): Prisma__AvailabilitySlotClient<$Result.GetResult<Prisma.$AvailabilitySlotPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AvailabilitySlot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilitySlotFindFirstOrThrowArgs} args - Arguments to find a AvailabilitySlot
     * @example
     * // Get one AvailabilitySlot
     * const availabilitySlot = await prisma.availabilitySlot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AvailabilitySlotFindFirstOrThrowArgs>(args?: SelectSubset<T, AvailabilitySlotFindFirstOrThrowArgs<ExtArgs>>): Prisma__AvailabilitySlotClient<$Result.GetResult<Prisma.$AvailabilitySlotPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AvailabilitySlots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilitySlotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AvailabilitySlots
     * const availabilitySlots = await prisma.availabilitySlot.findMany()
     * 
     * // Get first 10 AvailabilitySlots
     * const availabilitySlots = await prisma.availabilitySlot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const availabilitySlotWithIdOnly = await prisma.availabilitySlot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AvailabilitySlotFindManyArgs>(args?: SelectSubset<T, AvailabilitySlotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvailabilitySlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AvailabilitySlot.
     * @param {AvailabilitySlotCreateArgs} args - Arguments to create a AvailabilitySlot.
     * @example
     * // Create one AvailabilitySlot
     * const AvailabilitySlot = await prisma.availabilitySlot.create({
     *   data: {
     *     // ... data to create a AvailabilitySlot
     *   }
     * })
     * 
     */
    create<T extends AvailabilitySlotCreateArgs>(args: SelectSubset<T, AvailabilitySlotCreateArgs<ExtArgs>>): Prisma__AvailabilitySlotClient<$Result.GetResult<Prisma.$AvailabilitySlotPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AvailabilitySlots.
     * @param {AvailabilitySlotCreateManyArgs} args - Arguments to create many AvailabilitySlots.
     * @example
     * // Create many AvailabilitySlots
     * const availabilitySlot = await prisma.availabilitySlot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AvailabilitySlotCreateManyArgs>(args?: SelectSubset<T, AvailabilitySlotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AvailabilitySlots and returns the data saved in the database.
     * @param {AvailabilitySlotCreateManyAndReturnArgs} args - Arguments to create many AvailabilitySlots.
     * @example
     * // Create many AvailabilitySlots
     * const availabilitySlot = await prisma.availabilitySlot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AvailabilitySlots and only return the `id`
     * const availabilitySlotWithIdOnly = await prisma.availabilitySlot.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AvailabilitySlotCreateManyAndReturnArgs>(args?: SelectSubset<T, AvailabilitySlotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvailabilitySlotPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AvailabilitySlot.
     * @param {AvailabilitySlotDeleteArgs} args - Arguments to delete one AvailabilitySlot.
     * @example
     * // Delete one AvailabilitySlot
     * const AvailabilitySlot = await prisma.availabilitySlot.delete({
     *   where: {
     *     // ... filter to delete one AvailabilitySlot
     *   }
     * })
     * 
     */
    delete<T extends AvailabilitySlotDeleteArgs>(args: SelectSubset<T, AvailabilitySlotDeleteArgs<ExtArgs>>): Prisma__AvailabilitySlotClient<$Result.GetResult<Prisma.$AvailabilitySlotPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AvailabilitySlot.
     * @param {AvailabilitySlotUpdateArgs} args - Arguments to update one AvailabilitySlot.
     * @example
     * // Update one AvailabilitySlot
     * const availabilitySlot = await prisma.availabilitySlot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AvailabilitySlotUpdateArgs>(args: SelectSubset<T, AvailabilitySlotUpdateArgs<ExtArgs>>): Prisma__AvailabilitySlotClient<$Result.GetResult<Prisma.$AvailabilitySlotPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AvailabilitySlots.
     * @param {AvailabilitySlotDeleteManyArgs} args - Arguments to filter AvailabilitySlots to delete.
     * @example
     * // Delete a few AvailabilitySlots
     * const { count } = await prisma.availabilitySlot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AvailabilitySlotDeleteManyArgs>(args?: SelectSubset<T, AvailabilitySlotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AvailabilitySlots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilitySlotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AvailabilitySlots
     * const availabilitySlot = await prisma.availabilitySlot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AvailabilitySlotUpdateManyArgs>(args: SelectSubset<T, AvailabilitySlotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AvailabilitySlots and returns the data updated in the database.
     * @param {AvailabilitySlotUpdateManyAndReturnArgs} args - Arguments to update many AvailabilitySlots.
     * @example
     * // Update many AvailabilitySlots
     * const availabilitySlot = await prisma.availabilitySlot.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AvailabilitySlots and only return the `id`
     * const availabilitySlotWithIdOnly = await prisma.availabilitySlot.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AvailabilitySlotUpdateManyAndReturnArgs>(args: SelectSubset<T, AvailabilitySlotUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvailabilitySlotPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AvailabilitySlot.
     * @param {AvailabilitySlotUpsertArgs} args - Arguments to update or create a AvailabilitySlot.
     * @example
     * // Update or create a AvailabilitySlot
     * const availabilitySlot = await prisma.availabilitySlot.upsert({
     *   create: {
     *     // ... data to create a AvailabilitySlot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AvailabilitySlot we want to update
     *   }
     * })
     */
    upsert<T extends AvailabilitySlotUpsertArgs>(args: SelectSubset<T, AvailabilitySlotUpsertArgs<ExtArgs>>): Prisma__AvailabilitySlotClient<$Result.GetResult<Prisma.$AvailabilitySlotPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AvailabilitySlots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilitySlotCountArgs} args - Arguments to filter AvailabilitySlots to count.
     * @example
     * // Count the number of AvailabilitySlots
     * const count = await prisma.availabilitySlot.count({
     *   where: {
     *     // ... the filter for the AvailabilitySlots we want to count
     *   }
     * })
    **/
    count<T extends AvailabilitySlotCountArgs>(
      args?: Subset<T, AvailabilitySlotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AvailabilitySlotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AvailabilitySlot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilitySlotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AvailabilitySlotAggregateArgs>(args: Subset<T, AvailabilitySlotAggregateArgs>): Prisma.PrismaPromise<GetAvailabilitySlotAggregateType<T>>

    /**
     * Group by AvailabilitySlot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilitySlotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AvailabilitySlotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AvailabilitySlotGroupByArgs['orderBy'] }
        : { orderBy?: AvailabilitySlotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AvailabilitySlotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAvailabilitySlotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AvailabilitySlot model
   */
  readonly fields: AvailabilitySlotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AvailabilitySlot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AvailabilitySlotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AvailabilitySlot model
   */
  interface AvailabilitySlotFieldRefs {
    readonly id: FieldRef<"AvailabilitySlot", 'String'>
    readonly userId: FieldRef<"AvailabilitySlot", 'String'>
    readonly weekday: FieldRef<"AvailabilitySlot", 'Int'>
    readonly startTime: FieldRef<"AvailabilitySlot", 'String'>
    readonly endTime: FieldRef<"AvailabilitySlot", 'String'>
    readonly area: FieldRef<"AvailabilitySlot", 'String'>
    readonly createdAt: FieldRef<"AvailabilitySlot", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AvailabilitySlot findUnique
   */
  export type AvailabilitySlotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvailabilitySlot
     */
    select?: AvailabilitySlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvailabilitySlot
     */
    omit?: AvailabilitySlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilitySlotInclude<ExtArgs> | null
    /**
     * Filter, which AvailabilitySlot to fetch.
     */
    where: AvailabilitySlotWhereUniqueInput
  }

  /**
   * AvailabilitySlot findUniqueOrThrow
   */
  export type AvailabilitySlotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvailabilitySlot
     */
    select?: AvailabilitySlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvailabilitySlot
     */
    omit?: AvailabilitySlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilitySlotInclude<ExtArgs> | null
    /**
     * Filter, which AvailabilitySlot to fetch.
     */
    where: AvailabilitySlotWhereUniqueInput
  }

  /**
   * AvailabilitySlot findFirst
   */
  export type AvailabilitySlotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvailabilitySlot
     */
    select?: AvailabilitySlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvailabilitySlot
     */
    omit?: AvailabilitySlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilitySlotInclude<ExtArgs> | null
    /**
     * Filter, which AvailabilitySlot to fetch.
     */
    where?: AvailabilitySlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AvailabilitySlots to fetch.
     */
    orderBy?: AvailabilitySlotOrderByWithRelationInput | AvailabilitySlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AvailabilitySlots.
     */
    cursor?: AvailabilitySlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AvailabilitySlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AvailabilitySlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AvailabilitySlots.
     */
    distinct?: AvailabilitySlotScalarFieldEnum | AvailabilitySlotScalarFieldEnum[]
  }

  /**
   * AvailabilitySlot findFirstOrThrow
   */
  export type AvailabilitySlotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvailabilitySlot
     */
    select?: AvailabilitySlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvailabilitySlot
     */
    omit?: AvailabilitySlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilitySlotInclude<ExtArgs> | null
    /**
     * Filter, which AvailabilitySlot to fetch.
     */
    where?: AvailabilitySlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AvailabilitySlots to fetch.
     */
    orderBy?: AvailabilitySlotOrderByWithRelationInput | AvailabilitySlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AvailabilitySlots.
     */
    cursor?: AvailabilitySlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AvailabilitySlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AvailabilitySlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AvailabilitySlots.
     */
    distinct?: AvailabilitySlotScalarFieldEnum | AvailabilitySlotScalarFieldEnum[]
  }

  /**
   * AvailabilitySlot findMany
   */
  export type AvailabilitySlotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvailabilitySlot
     */
    select?: AvailabilitySlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvailabilitySlot
     */
    omit?: AvailabilitySlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilitySlotInclude<ExtArgs> | null
    /**
     * Filter, which AvailabilitySlots to fetch.
     */
    where?: AvailabilitySlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AvailabilitySlots to fetch.
     */
    orderBy?: AvailabilitySlotOrderByWithRelationInput | AvailabilitySlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AvailabilitySlots.
     */
    cursor?: AvailabilitySlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AvailabilitySlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AvailabilitySlots.
     */
    skip?: number
    distinct?: AvailabilitySlotScalarFieldEnum | AvailabilitySlotScalarFieldEnum[]
  }

  /**
   * AvailabilitySlot create
   */
  export type AvailabilitySlotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvailabilitySlot
     */
    select?: AvailabilitySlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvailabilitySlot
     */
    omit?: AvailabilitySlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilitySlotInclude<ExtArgs> | null
    /**
     * The data needed to create a AvailabilitySlot.
     */
    data: XOR<AvailabilitySlotCreateInput, AvailabilitySlotUncheckedCreateInput>
  }

  /**
   * AvailabilitySlot createMany
   */
  export type AvailabilitySlotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AvailabilitySlots.
     */
    data: AvailabilitySlotCreateManyInput | AvailabilitySlotCreateManyInput[]
  }

  /**
   * AvailabilitySlot createManyAndReturn
   */
  export type AvailabilitySlotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvailabilitySlot
     */
    select?: AvailabilitySlotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AvailabilitySlot
     */
    omit?: AvailabilitySlotOmit<ExtArgs> | null
    /**
     * The data used to create many AvailabilitySlots.
     */
    data: AvailabilitySlotCreateManyInput | AvailabilitySlotCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilitySlotIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AvailabilitySlot update
   */
  export type AvailabilitySlotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvailabilitySlot
     */
    select?: AvailabilitySlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvailabilitySlot
     */
    omit?: AvailabilitySlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilitySlotInclude<ExtArgs> | null
    /**
     * The data needed to update a AvailabilitySlot.
     */
    data: XOR<AvailabilitySlotUpdateInput, AvailabilitySlotUncheckedUpdateInput>
    /**
     * Choose, which AvailabilitySlot to update.
     */
    where: AvailabilitySlotWhereUniqueInput
  }

  /**
   * AvailabilitySlot updateMany
   */
  export type AvailabilitySlotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AvailabilitySlots.
     */
    data: XOR<AvailabilitySlotUpdateManyMutationInput, AvailabilitySlotUncheckedUpdateManyInput>
    /**
     * Filter which AvailabilitySlots to update
     */
    where?: AvailabilitySlotWhereInput
    /**
     * Limit how many AvailabilitySlots to update.
     */
    limit?: number
  }

  /**
   * AvailabilitySlot updateManyAndReturn
   */
  export type AvailabilitySlotUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvailabilitySlot
     */
    select?: AvailabilitySlotSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AvailabilitySlot
     */
    omit?: AvailabilitySlotOmit<ExtArgs> | null
    /**
     * The data used to update AvailabilitySlots.
     */
    data: XOR<AvailabilitySlotUpdateManyMutationInput, AvailabilitySlotUncheckedUpdateManyInput>
    /**
     * Filter which AvailabilitySlots to update
     */
    where?: AvailabilitySlotWhereInput
    /**
     * Limit how many AvailabilitySlots to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilitySlotIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AvailabilitySlot upsert
   */
  export type AvailabilitySlotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvailabilitySlot
     */
    select?: AvailabilitySlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvailabilitySlot
     */
    omit?: AvailabilitySlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilitySlotInclude<ExtArgs> | null
    /**
     * The filter to search for the AvailabilitySlot to update in case it exists.
     */
    where: AvailabilitySlotWhereUniqueInput
    /**
     * In case the AvailabilitySlot found by the `where` argument doesn't exist, create a new AvailabilitySlot with this data.
     */
    create: XOR<AvailabilitySlotCreateInput, AvailabilitySlotUncheckedCreateInput>
    /**
     * In case the AvailabilitySlot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AvailabilitySlotUpdateInput, AvailabilitySlotUncheckedUpdateInput>
  }

  /**
   * AvailabilitySlot delete
   */
  export type AvailabilitySlotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvailabilitySlot
     */
    select?: AvailabilitySlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvailabilitySlot
     */
    omit?: AvailabilitySlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilitySlotInclude<ExtArgs> | null
    /**
     * Filter which AvailabilitySlot to delete.
     */
    where: AvailabilitySlotWhereUniqueInput
  }

  /**
   * AvailabilitySlot deleteMany
   */
  export type AvailabilitySlotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AvailabilitySlots to delete
     */
    where?: AvailabilitySlotWhereInput
    /**
     * Limit how many AvailabilitySlots to delete.
     */
    limit?: number
  }

  /**
   * AvailabilitySlot without action
   */
  export type AvailabilitySlotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvailabilitySlot
     */
    select?: AvailabilitySlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvailabilitySlot
     */
    omit?: AvailabilitySlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilitySlotInclude<ExtArgs> | null
  }


  /**
   * Model MatchProposal
   */

  export type AggregateMatchProposal = {
    _count: MatchProposalCountAggregateOutputType | null
    _min: MatchProposalMinAggregateOutputType | null
    _max: MatchProposalMaxAggregateOutputType | null
  }

  export type MatchProposalMinAggregateOutputType = {
    id: string | null
    proposerId: string | null
    partnerId: string | null
    message: string | null
    status: $Enums.MatchStatus | null
    createdAt: Date | null
  }

  export type MatchProposalMaxAggregateOutputType = {
    id: string | null
    proposerId: string | null
    partnerId: string | null
    message: string | null
    status: $Enums.MatchStatus | null
    createdAt: Date | null
  }

  export type MatchProposalCountAggregateOutputType = {
    id: number
    proposerId: number
    partnerId: number
    message: number
    status: number
    createdAt: number
    _all: number
  }


  export type MatchProposalMinAggregateInputType = {
    id?: true
    proposerId?: true
    partnerId?: true
    message?: true
    status?: true
    createdAt?: true
  }

  export type MatchProposalMaxAggregateInputType = {
    id?: true
    proposerId?: true
    partnerId?: true
    message?: true
    status?: true
    createdAt?: true
  }

  export type MatchProposalCountAggregateInputType = {
    id?: true
    proposerId?: true
    partnerId?: true
    message?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type MatchProposalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatchProposal to aggregate.
     */
    where?: MatchProposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchProposals to fetch.
     */
    orderBy?: MatchProposalOrderByWithRelationInput | MatchProposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MatchProposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchProposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchProposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MatchProposals
    **/
    _count?: true | MatchProposalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MatchProposalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MatchProposalMaxAggregateInputType
  }

  export type GetMatchProposalAggregateType<T extends MatchProposalAggregateArgs> = {
        [P in keyof T & keyof AggregateMatchProposal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMatchProposal[P]>
      : GetScalarType<T[P], AggregateMatchProposal[P]>
  }




  export type MatchProposalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchProposalWhereInput
    orderBy?: MatchProposalOrderByWithAggregationInput | MatchProposalOrderByWithAggregationInput[]
    by: MatchProposalScalarFieldEnum[] | MatchProposalScalarFieldEnum
    having?: MatchProposalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MatchProposalCountAggregateInputType | true
    _min?: MatchProposalMinAggregateInputType
    _max?: MatchProposalMaxAggregateInputType
  }

  export type MatchProposalGroupByOutputType = {
    id: string
    proposerId: string
    partnerId: string
    message: string | null
    status: $Enums.MatchStatus
    createdAt: Date
    _count: MatchProposalCountAggregateOutputType | null
    _min: MatchProposalMinAggregateOutputType | null
    _max: MatchProposalMaxAggregateOutputType | null
  }

  type GetMatchProposalGroupByPayload<T extends MatchProposalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MatchProposalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MatchProposalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MatchProposalGroupByOutputType[P]>
            : GetScalarType<T[P], MatchProposalGroupByOutputType[P]>
        }
      >
    >


  export type MatchProposalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    proposerId?: boolean
    partnerId?: boolean
    message?: boolean
    status?: boolean
    createdAt?: boolean
    proposer?: boolean | UserDefaultArgs<ExtArgs>
    partner?: boolean | UserDefaultArgs<ExtArgs>
    appointment?: boolean | MatchProposal$appointmentArgs<ExtArgs>
  }, ExtArgs["result"]["matchProposal"]>

  export type MatchProposalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    proposerId?: boolean
    partnerId?: boolean
    message?: boolean
    status?: boolean
    createdAt?: boolean
    proposer?: boolean | UserDefaultArgs<ExtArgs>
    partner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matchProposal"]>

  export type MatchProposalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    proposerId?: boolean
    partnerId?: boolean
    message?: boolean
    status?: boolean
    createdAt?: boolean
    proposer?: boolean | UserDefaultArgs<ExtArgs>
    partner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matchProposal"]>

  export type MatchProposalSelectScalar = {
    id?: boolean
    proposerId?: boolean
    partnerId?: boolean
    message?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type MatchProposalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "proposerId" | "partnerId" | "message" | "status" | "createdAt", ExtArgs["result"]["matchProposal"]>
  export type MatchProposalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proposer?: boolean | UserDefaultArgs<ExtArgs>
    partner?: boolean | UserDefaultArgs<ExtArgs>
    appointment?: boolean | MatchProposal$appointmentArgs<ExtArgs>
  }
  export type MatchProposalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proposer?: boolean | UserDefaultArgs<ExtArgs>
    partner?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MatchProposalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proposer?: boolean | UserDefaultArgs<ExtArgs>
    partner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MatchProposalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MatchProposal"
    objects: {
      proposer: Prisma.$UserPayload<ExtArgs>
      partner: Prisma.$UserPayload<ExtArgs>
      appointment: Prisma.$AppointmentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      proposerId: string
      partnerId: string
      message: string | null
      status: $Enums.MatchStatus
      createdAt: Date
    }, ExtArgs["result"]["matchProposal"]>
    composites: {}
  }

  type MatchProposalGetPayload<S extends boolean | null | undefined | MatchProposalDefaultArgs> = $Result.GetResult<Prisma.$MatchProposalPayload, S>

  type MatchProposalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MatchProposalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MatchProposalCountAggregateInputType | true
    }

  export interface MatchProposalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MatchProposal'], meta: { name: 'MatchProposal' } }
    /**
     * Find zero or one MatchProposal that matches the filter.
     * @param {MatchProposalFindUniqueArgs} args - Arguments to find a MatchProposal
     * @example
     * // Get one MatchProposal
     * const matchProposal = await prisma.matchProposal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MatchProposalFindUniqueArgs>(args: SelectSubset<T, MatchProposalFindUniqueArgs<ExtArgs>>): Prisma__MatchProposalClient<$Result.GetResult<Prisma.$MatchProposalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MatchProposal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MatchProposalFindUniqueOrThrowArgs} args - Arguments to find a MatchProposal
     * @example
     * // Get one MatchProposal
     * const matchProposal = await prisma.matchProposal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MatchProposalFindUniqueOrThrowArgs>(args: SelectSubset<T, MatchProposalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MatchProposalClient<$Result.GetResult<Prisma.$MatchProposalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MatchProposal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchProposalFindFirstArgs} args - Arguments to find a MatchProposal
     * @example
     * // Get one MatchProposal
     * const matchProposal = await prisma.matchProposal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MatchProposalFindFirstArgs>(args?: SelectSubset<T, MatchProposalFindFirstArgs<ExtArgs>>): Prisma__MatchProposalClient<$Result.GetResult<Prisma.$MatchProposalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MatchProposal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchProposalFindFirstOrThrowArgs} args - Arguments to find a MatchProposal
     * @example
     * // Get one MatchProposal
     * const matchProposal = await prisma.matchProposal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MatchProposalFindFirstOrThrowArgs>(args?: SelectSubset<T, MatchProposalFindFirstOrThrowArgs<ExtArgs>>): Prisma__MatchProposalClient<$Result.GetResult<Prisma.$MatchProposalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MatchProposals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchProposalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MatchProposals
     * const matchProposals = await prisma.matchProposal.findMany()
     * 
     * // Get first 10 MatchProposals
     * const matchProposals = await prisma.matchProposal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const matchProposalWithIdOnly = await prisma.matchProposal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MatchProposalFindManyArgs>(args?: SelectSubset<T, MatchProposalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchProposalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MatchProposal.
     * @param {MatchProposalCreateArgs} args - Arguments to create a MatchProposal.
     * @example
     * // Create one MatchProposal
     * const MatchProposal = await prisma.matchProposal.create({
     *   data: {
     *     // ... data to create a MatchProposal
     *   }
     * })
     * 
     */
    create<T extends MatchProposalCreateArgs>(args: SelectSubset<T, MatchProposalCreateArgs<ExtArgs>>): Prisma__MatchProposalClient<$Result.GetResult<Prisma.$MatchProposalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MatchProposals.
     * @param {MatchProposalCreateManyArgs} args - Arguments to create many MatchProposals.
     * @example
     * // Create many MatchProposals
     * const matchProposal = await prisma.matchProposal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MatchProposalCreateManyArgs>(args?: SelectSubset<T, MatchProposalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MatchProposals and returns the data saved in the database.
     * @param {MatchProposalCreateManyAndReturnArgs} args - Arguments to create many MatchProposals.
     * @example
     * // Create many MatchProposals
     * const matchProposal = await prisma.matchProposal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MatchProposals and only return the `id`
     * const matchProposalWithIdOnly = await prisma.matchProposal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MatchProposalCreateManyAndReturnArgs>(args?: SelectSubset<T, MatchProposalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchProposalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MatchProposal.
     * @param {MatchProposalDeleteArgs} args - Arguments to delete one MatchProposal.
     * @example
     * // Delete one MatchProposal
     * const MatchProposal = await prisma.matchProposal.delete({
     *   where: {
     *     // ... filter to delete one MatchProposal
     *   }
     * })
     * 
     */
    delete<T extends MatchProposalDeleteArgs>(args: SelectSubset<T, MatchProposalDeleteArgs<ExtArgs>>): Prisma__MatchProposalClient<$Result.GetResult<Prisma.$MatchProposalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MatchProposal.
     * @param {MatchProposalUpdateArgs} args - Arguments to update one MatchProposal.
     * @example
     * // Update one MatchProposal
     * const matchProposal = await prisma.matchProposal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MatchProposalUpdateArgs>(args: SelectSubset<T, MatchProposalUpdateArgs<ExtArgs>>): Prisma__MatchProposalClient<$Result.GetResult<Prisma.$MatchProposalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MatchProposals.
     * @param {MatchProposalDeleteManyArgs} args - Arguments to filter MatchProposals to delete.
     * @example
     * // Delete a few MatchProposals
     * const { count } = await prisma.matchProposal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MatchProposalDeleteManyArgs>(args?: SelectSubset<T, MatchProposalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MatchProposals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchProposalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MatchProposals
     * const matchProposal = await prisma.matchProposal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MatchProposalUpdateManyArgs>(args: SelectSubset<T, MatchProposalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MatchProposals and returns the data updated in the database.
     * @param {MatchProposalUpdateManyAndReturnArgs} args - Arguments to update many MatchProposals.
     * @example
     * // Update many MatchProposals
     * const matchProposal = await prisma.matchProposal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MatchProposals and only return the `id`
     * const matchProposalWithIdOnly = await prisma.matchProposal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MatchProposalUpdateManyAndReturnArgs>(args: SelectSubset<T, MatchProposalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchProposalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MatchProposal.
     * @param {MatchProposalUpsertArgs} args - Arguments to update or create a MatchProposal.
     * @example
     * // Update or create a MatchProposal
     * const matchProposal = await prisma.matchProposal.upsert({
     *   create: {
     *     // ... data to create a MatchProposal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MatchProposal we want to update
     *   }
     * })
     */
    upsert<T extends MatchProposalUpsertArgs>(args: SelectSubset<T, MatchProposalUpsertArgs<ExtArgs>>): Prisma__MatchProposalClient<$Result.GetResult<Prisma.$MatchProposalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MatchProposals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchProposalCountArgs} args - Arguments to filter MatchProposals to count.
     * @example
     * // Count the number of MatchProposals
     * const count = await prisma.matchProposal.count({
     *   where: {
     *     // ... the filter for the MatchProposals we want to count
     *   }
     * })
    **/
    count<T extends MatchProposalCountArgs>(
      args?: Subset<T, MatchProposalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MatchProposalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MatchProposal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchProposalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MatchProposalAggregateArgs>(args: Subset<T, MatchProposalAggregateArgs>): Prisma.PrismaPromise<GetMatchProposalAggregateType<T>>

    /**
     * Group by MatchProposal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchProposalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MatchProposalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MatchProposalGroupByArgs['orderBy'] }
        : { orderBy?: MatchProposalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MatchProposalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatchProposalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MatchProposal model
   */
  readonly fields: MatchProposalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MatchProposal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MatchProposalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    proposer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    partner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    appointment<T extends MatchProposal$appointmentArgs<ExtArgs> = {}>(args?: Subset<T, MatchProposal$appointmentArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MatchProposal model
   */
  interface MatchProposalFieldRefs {
    readonly id: FieldRef<"MatchProposal", 'String'>
    readonly proposerId: FieldRef<"MatchProposal", 'String'>
    readonly partnerId: FieldRef<"MatchProposal", 'String'>
    readonly message: FieldRef<"MatchProposal", 'String'>
    readonly status: FieldRef<"MatchProposal", 'MatchStatus'>
    readonly createdAt: FieldRef<"MatchProposal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MatchProposal findUnique
   */
  export type MatchProposalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchProposal
     */
    select?: MatchProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchProposal
     */
    omit?: MatchProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchProposalInclude<ExtArgs> | null
    /**
     * Filter, which MatchProposal to fetch.
     */
    where: MatchProposalWhereUniqueInput
  }

  /**
   * MatchProposal findUniqueOrThrow
   */
  export type MatchProposalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchProposal
     */
    select?: MatchProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchProposal
     */
    omit?: MatchProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchProposalInclude<ExtArgs> | null
    /**
     * Filter, which MatchProposal to fetch.
     */
    where: MatchProposalWhereUniqueInput
  }

  /**
   * MatchProposal findFirst
   */
  export type MatchProposalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchProposal
     */
    select?: MatchProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchProposal
     */
    omit?: MatchProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchProposalInclude<ExtArgs> | null
    /**
     * Filter, which MatchProposal to fetch.
     */
    where?: MatchProposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchProposals to fetch.
     */
    orderBy?: MatchProposalOrderByWithRelationInput | MatchProposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatchProposals.
     */
    cursor?: MatchProposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchProposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchProposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatchProposals.
     */
    distinct?: MatchProposalScalarFieldEnum | MatchProposalScalarFieldEnum[]
  }

  /**
   * MatchProposal findFirstOrThrow
   */
  export type MatchProposalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchProposal
     */
    select?: MatchProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchProposal
     */
    omit?: MatchProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchProposalInclude<ExtArgs> | null
    /**
     * Filter, which MatchProposal to fetch.
     */
    where?: MatchProposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchProposals to fetch.
     */
    orderBy?: MatchProposalOrderByWithRelationInput | MatchProposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatchProposals.
     */
    cursor?: MatchProposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchProposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchProposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatchProposals.
     */
    distinct?: MatchProposalScalarFieldEnum | MatchProposalScalarFieldEnum[]
  }

  /**
   * MatchProposal findMany
   */
  export type MatchProposalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchProposal
     */
    select?: MatchProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchProposal
     */
    omit?: MatchProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchProposalInclude<ExtArgs> | null
    /**
     * Filter, which MatchProposals to fetch.
     */
    where?: MatchProposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchProposals to fetch.
     */
    orderBy?: MatchProposalOrderByWithRelationInput | MatchProposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MatchProposals.
     */
    cursor?: MatchProposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchProposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchProposals.
     */
    skip?: number
    distinct?: MatchProposalScalarFieldEnum | MatchProposalScalarFieldEnum[]
  }

  /**
   * MatchProposal create
   */
  export type MatchProposalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchProposal
     */
    select?: MatchProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchProposal
     */
    omit?: MatchProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchProposalInclude<ExtArgs> | null
    /**
     * The data needed to create a MatchProposal.
     */
    data: XOR<MatchProposalCreateInput, MatchProposalUncheckedCreateInput>
  }

  /**
   * MatchProposal createMany
   */
  export type MatchProposalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MatchProposals.
     */
    data: MatchProposalCreateManyInput | MatchProposalCreateManyInput[]
  }

  /**
   * MatchProposal createManyAndReturn
   */
  export type MatchProposalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchProposal
     */
    select?: MatchProposalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MatchProposal
     */
    omit?: MatchProposalOmit<ExtArgs> | null
    /**
     * The data used to create many MatchProposals.
     */
    data: MatchProposalCreateManyInput | MatchProposalCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchProposalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MatchProposal update
   */
  export type MatchProposalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchProposal
     */
    select?: MatchProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchProposal
     */
    omit?: MatchProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchProposalInclude<ExtArgs> | null
    /**
     * The data needed to update a MatchProposal.
     */
    data: XOR<MatchProposalUpdateInput, MatchProposalUncheckedUpdateInput>
    /**
     * Choose, which MatchProposal to update.
     */
    where: MatchProposalWhereUniqueInput
  }

  /**
   * MatchProposal updateMany
   */
  export type MatchProposalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MatchProposals.
     */
    data: XOR<MatchProposalUpdateManyMutationInput, MatchProposalUncheckedUpdateManyInput>
    /**
     * Filter which MatchProposals to update
     */
    where?: MatchProposalWhereInput
    /**
     * Limit how many MatchProposals to update.
     */
    limit?: number
  }

  /**
   * MatchProposal updateManyAndReturn
   */
  export type MatchProposalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchProposal
     */
    select?: MatchProposalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MatchProposal
     */
    omit?: MatchProposalOmit<ExtArgs> | null
    /**
     * The data used to update MatchProposals.
     */
    data: XOR<MatchProposalUpdateManyMutationInput, MatchProposalUncheckedUpdateManyInput>
    /**
     * Filter which MatchProposals to update
     */
    where?: MatchProposalWhereInput
    /**
     * Limit how many MatchProposals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchProposalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MatchProposal upsert
   */
  export type MatchProposalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchProposal
     */
    select?: MatchProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchProposal
     */
    omit?: MatchProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchProposalInclude<ExtArgs> | null
    /**
     * The filter to search for the MatchProposal to update in case it exists.
     */
    where: MatchProposalWhereUniqueInput
    /**
     * In case the MatchProposal found by the `where` argument doesn't exist, create a new MatchProposal with this data.
     */
    create: XOR<MatchProposalCreateInput, MatchProposalUncheckedCreateInput>
    /**
     * In case the MatchProposal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MatchProposalUpdateInput, MatchProposalUncheckedUpdateInput>
  }

  /**
   * MatchProposal delete
   */
  export type MatchProposalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchProposal
     */
    select?: MatchProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchProposal
     */
    omit?: MatchProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchProposalInclude<ExtArgs> | null
    /**
     * Filter which MatchProposal to delete.
     */
    where: MatchProposalWhereUniqueInput
  }

  /**
   * MatchProposal deleteMany
   */
  export type MatchProposalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatchProposals to delete
     */
    where?: MatchProposalWhereInput
    /**
     * Limit how many MatchProposals to delete.
     */
    limit?: number
  }

  /**
   * MatchProposal.appointment
   */
  export type MatchProposal$appointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
  }

  /**
   * MatchProposal without action
   */
  export type MatchProposalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchProposal
     */
    select?: MatchProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchProposal
     */
    omit?: MatchProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchProposalInclude<ExtArgs> | null
  }


  /**
   * Model Appointment
   */

  export type AggregateAppointment = {
    _count: AppointmentCountAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  export type AppointmentMinAggregateOutputType = {
    id: string | null
    proposalId: string | null
    userAId: string | null
    userBId: string | null
    place: string | null
    startsAt: Date | null
    status: $Enums.AppointmentStatus | null
    checkinCode: string | null
    createdAt: Date | null
  }

  export type AppointmentMaxAggregateOutputType = {
    id: string | null
    proposalId: string | null
    userAId: string | null
    userBId: string | null
    place: string | null
    startsAt: Date | null
    status: $Enums.AppointmentStatus | null
    checkinCode: string | null
    createdAt: Date | null
  }

  export type AppointmentCountAggregateOutputType = {
    id: number
    proposalId: number
    userAId: number
    userBId: number
    place: number
    startsAt: number
    status: number
    checkinCode: number
    createdAt: number
    _all: number
  }


  export type AppointmentMinAggregateInputType = {
    id?: true
    proposalId?: true
    userAId?: true
    userBId?: true
    place?: true
    startsAt?: true
    status?: true
    checkinCode?: true
    createdAt?: true
  }

  export type AppointmentMaxAggregateInputType = {
    id?: true
    proposalId?: true
    userAId?: true
    userBId?: true
    place?: true
    startsAt?: true
    status?: true
    checkinCode?: true
    createdAt?: true
  }

  export type AppointmentCountAggregateInputType = {
    id?: true
    proposalId?: true
    userAId?: true
    userBId?: true
    place?: true
    startsAt?: true
    status?: true
    checkinCode?: true
    createdAt?: true
    _all?: true
  }

  export type AppointmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointment to aggregate.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Appointments
    **/
    _count?: true | AppointmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppointmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppointmentMaxAggregateInputType
  }

  export type GetAppointmentAggregateType<T extends AppointmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAppointment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppointment[P]>
      : GetScalarType<T[P], AggregateAppointment[P]>
  }




  export type AppointmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithAggregationInput | AppointmentOrderByWithAggregationInput[]
    by: AppointmentScalarFieldEnum[] | AppointmentScalarFieldEnum
    having?: AppointmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppointmentCountAggregateInputType | true
    _min?: AppointmentMinAggregateInputType
    _max?: AppointmentMaxAggregateInputType
  }

  export type AppointmentGroupByOutputType = {
    id: string
    proposalId: string
    userAId: string
    userBId: string
    place: string
    startsAt: Date
    status: $Enums.AppointmentStatus
    checkinCode: string
    createdAt: Date
    _count: AppointmentCountAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  type GetAppointmentGroupByPayload<T extends AppointmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppointmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppointmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
            : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
        }
      >
    >


  export type AppointmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    proposalId?: boolean
    userAId?: boolean
    userBId?: boolean
    place?: boolean
    startsAt?: boolean
    status?: boolean
    checkinCode?: boolean
    createdAt?: boolean
    proposal?: boolean | MatchProposalDefaultArgs<ExtArgs>
    userA?: boolean | UserDefaultArgs<ExtArgs>
    userB?: boolean | UserDefaultArgs<ExtArgs>
    checks?: boolean | Appointment$checksArgs<ExtArgs>
    reports?: boolean | Appointment$reportsArgs<ExtArgs>
    reviews?: boolean | Appointment$reviewsArgs<ExtArgs>
    _count?: boolean | AppointmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    proposalId?: boolean
    userAId?: boolean
    userBId?: boolean
    place?: boolean
    startsAt?: boolean
    status?: boolean
    checkinCode?: boolean
    createdAt?: boolean
    proposal?: boolean | MatchProposalDefaultArgs<ExtArgs>
    userA?: boolean | UserDefaultArgs<ExtArgs>
    userB?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    proposalId?: boolean
    userAId?: boolean
    userBId?: boolean
    place?: boolean
    startsAt?: boolean
    status?: boolean
    checkinCode?: boolean
    createdAt?: boolean
    proposal?: boolean | MatchProposalDefaultArgs<ExtArgs>
    userA?: boolean | UserDefaultArgs<ExtArgs>
    userB?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectScalar = {
    id?: boolean
    proposalId?: boolean
    userAId?: boolean
    userBId?: boolean
    place?: boolean
    startsAt?: boolean
    status?: boolean
    checkinCode?: boolean
    createdAt?: boolean
  }

  export type AppointmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "proposalId" | "userAId" | "userBId" | "place" | "startsAt" | "status" | "checkinCode" | "createdAt", ExtArgs["result"]["appointment"]>
  export type AppointmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proposal?: boolean | MatchProposalDefaultArgs<ExtArgs>
    userA?: boolean | UserDefaultArgs<ExtArgs>
    userB?: boolean | UserDefaultArgs<ExtArgs>
    checks?: boolean | Appointment$checksArgs<ExtArgs>
    reports?: boolean | Appointment$reportsArgs<ExtArgs>
    reviews?: boolean | Appointment$reviewsArgs<ExtArgs>
    _count?: boolean | AppointmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AppointmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proposal?: boolean | MatchProposalDefaultArgs<ExtArgs>
    userA?: boolean | UserDefaultArgs<ExtArgs>
    userB?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AppointmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proposal?: boolean | MatchProposalDefaultArgs<ExtArgs>
    userA?: boolean | UserDefaultArgs<ExtArgs>
    userB?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AppointmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Appointment"
    objects: {
      proposal: Prisma.$MatchProposalPayload<ExtArgs>
      userA: Prisma.$UserPayload<ExtArgs>
      userB: Prisma.$UserPayload<ExtArgs>
      checks: Prisma.$AttendanceCheckPayload<ExtArgs>[]
      reports: Prisma.$ReportPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      proposalId: string
      userAId: string
      userBId: string
      place: string
      startsAt: Date
      status: $Enums.AppointmentStatus
      checkinCode: string
      createdAt: Date
    }, ExtArgs["result"]["appointment"]>
    composites: {}
  }

  type AppointmentGetPayload<S extends boolean | null | undefined | AppointmentDefaultArgs> = $Result.GetResult<Prisma.$AppointmentPayload, S>

  type AppointmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AppointmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AppointmentCountAggregateInputType | true
    }

  export interface AppointmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Appointment'], meta: { name: 'Appointment' } }
    /**
     * Find zero or one Appointment that matches the filter.
     * @param {AppointmentFindUniqueArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppointmentFindUniqueArgs>(args: SelectSubset<T, AppointmentFindUniqueArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Appointment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AppointmentFindUniqueOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppointmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AppointmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Appointment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppointmentFindFirstArgs>(args?: SelectSubset<T, AppointmentFindFirstArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Appointment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppointmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AppointmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Appointments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Appointments
     * const appointments = await prisma.appointment.findMany()
     * 
     * // Get first 10 Appointments
     * const appointments = await prisma.appointment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appointmentWithIdOnly = await prisma.appointment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AppointmentFindManyArgs>(args?: SelectSubset<T, AppointmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Appointment.
     * @param {AppointmentCreateArgs} args - Arguments to create a Appointment.
     * @example
     * // Create one Appointment
     * const Appointment = await prisma.appointment.create({
     *   data: {
     *     // ... data to create a Appointment
     *   }
     * })
     * 
     */
    create<T extends AppointmentCreateArgs>(args: SelectSubset<T, AppointmentCreateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Appointments.
     * @param {AppointmentCreateManyArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppointmentCreateManyArgs>(args?: SelectSubset<T, AppointmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Appointments and returns the data saved in the database.
     * @param {AppointmentCreateManyAndReturnArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Appointments and only return the `id`
     * const appointmentWithIdOnly = await prisma.appointment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AppointmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AppointmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Appointment.
     * @param {AppointmentDeleteArgs} args - Arguments to delete one Appointment.
     * @example
     * // Delete one Appointment
     * const Appointment = await prisma.appointment.delete({
     *   where: {
     *     // ... filter to delete one Appointment
     *   }
     * })
     * 
     */
    delete<T extends AppointmentDeleteArgs>(args: SelectSubset<T, AppointmentDeleteArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Appointment.
     * @param {AppointmentUpdateArgs} args - Arguments to update one Appointment.
     * @example
     * // Update one Appointment
     * const appointment = await prisma.appointment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppointmentUpdateArgs>(args: SelectSubset<T, AppointmentUpdateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Appointments.
     * @param {AppointmentDeleteManyArgs} args - Arguments to filter Appointments to delete.
     * @example
     * // Delete a few Appointments
     * const { count } = await prisma.appointment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppointmentDeleteManyArgs>(args?: SelectSubset<T, AppointmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Appointments
     * const appointment = await prisma.appointment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppointmentUpdateManyArgs>(args: SelectSubset<T, AppointmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments and returns the data updated in the database.
     * @param {AppointmentUpdateManyAndReturnArgs} args - Arguments to update many Appointments.
     * @example
     * // Update many Appointments
     * const appointment = await prisma.appointment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Appointments and only return the `id`
     * const appointmentWithIdOnly = await prisma.appointment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AppointmentUpdateManyAndReturnArgs>(args: SelectSubset<T, AppointmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Appointment.
     * @param {AppointmentUpsertArgs} args - Arguments to update or create a Appointment.
     * @example
     * // Update or create a Appointment
     * const appointment = await prisma.appointment.upsert({
     *   create: {
     *     // ... data to create a Appointment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Appointment we want to update
     *   }
     * })
     */
    upsert<T extends AppointmentUpsertArgs>(args: SelectSubset<T, AppointmentUpsertArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentCountArgs} args - Arguments to filter Appointments to count.
     * @example
     * // Count the number of Appointments
     * const count = await prisma.appointment.count({
     *   where: {
     *     // ... the filter for the Appointments we want to count
     *   }
     * })
    **/
    count<T extends AppointmentCountArgs>(
      args?: Subset<T, AppointmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppointmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppointmentAggregateArgs>(args: Subset<T, AppointmentAggregateArgs>): Prisma.PrismaPromise<GetAppointmentAggregateType<T>>

    /**
     * Group by Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppointmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppointmentGroupByArgs['orderBy'] }
        : { orderBy?: AppointmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppointmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppointmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Appointment model
   */
  readonly fields: AppointmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Appointment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppointmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    proposal<T extends MatchProposalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MatchProposalDefaultArgs<ExtArgs>>): Prisma__MatchProposalClient<$Result.GetResult<Prisma.$MatchProposalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    userA<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    userB<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    checks<T extends Appointment$checksArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$checksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceCheckPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reports<T extends Appointment$reportsArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends Appointment$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Appointment model
   */
  interface AppointmentFieldRefs {
    readonly id: FieldRef<"Appointment", 'String'>
    readonly proposalId: FieldRef<"Appointment", 'String'>
    readonly userAId: FieldRef<"Appointment", 'String'>
    readonly userBId: FieldRef<"Appointment", 'String'>
    readonly place: FieldRef<"Appointment", 'String'>
    readonly startsAt: FieldRef<"Appointment", 'DateTime'>
    readonly status: FieldRef<"Appointment", 'AppointmentStatus'>
    readonly checkinCode: FieldRef<"Appointment", 'String'>
    readonly createdAt: FieldRef<"Appointment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Appointment findUnique
   */
  export type AppointmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findUniqueOrThrow
   */
  export type AppointmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findFirst
   */
  export type AppointmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findFirstOrThrow
   */
  export type AppointmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findMany
   */
  export type AppointmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointments to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment create
   */
  export type AppointmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Appointment.
     */
    data: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
  }

  /**
   * Appointment createMany
   */
  export type AppointmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
  }

  /**
   * Appointment createManyAndReturn
   */
  export type AppointmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Appointment update
   */
  export type AppointmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Appointment.
     */
    data: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
    /**
     * Choose, which Appointment to update.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment updateMany
   */
  export type AppointmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Appointments.
     */
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyInput>
    /**
     * Filter which Appointments to update
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to update.
     */
    limit?: number
  }

  /**
   * Appointment updateManyAndReturn
   */
  export type AppointmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * The data used to update Appointments.
     */
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyInput>
    /**
     * Filter which Appointments to update
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Appointment upsert
   */
  export type AppointmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Appointment to update in case it exists.
     */
    where: AppointmentWhereUniqueInput
    /**
     * In case the Appointment found by the `where` argument doesn't exist, create a new Appointment with this data.
     */
    create: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
    /**
     * In case the Appointment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
  }

  /**
   * Appointment delete
   */
  export type AppointmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter which Appointment to delete.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment deleteMany
   */
  export type AppointmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointments to delete
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to delete.
     */
    limit?: number
  }

  /**
   * Appointment.checks
   */
  export type Appointment$checksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceCheck
     */
    select?: AttendanceCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceCheck
     */
    omit?: AttendanceCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceCheckInclude<ExtArgs> | null
    where?: AttendanceCheckWhereInput
    orderBy?: AttendanceCheckOrderByWithRelationInput | AttendanceCheckOrderByWithRelationInput[]
    cursor?: AttendanceCheckWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceCheckScalarFieldEnum | AttendanceCheckScalarFieldEnum[]
  }

  /**
   * Appointment.reports
   */
  export type Appointment$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Appointment.reviews
   */
  export type Appointment$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Appointment without action
   */
  export type AppointmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
  }


  /**
   * Model AttendanceCheck
   */

  export type AggregateAttendanceCheck = {
    _count: AttendanceCheckCountAggregateOutputType | null
    _min: AttendanceCheckMinAggregateOutputType | null
    _max: AttendanceCheckMaxAggregateOutputType | null
  }

  export type AttendanceCheckMinAggregateOutputType = {
    id: string | null
    appointmentId: string | null
    userId: string | null
    method: string | null
    checkedAt: Date | null
  }

  export type AttendanceCheckMaxAggregateOutputType = {
    id: string | null
    appointmentId: string | null
    userId: string | null
    method: string | null
    checkedAt: Date | null
  }

  export type AttendanceCheckCountAggregateOutputType = {
    id: number
    appointmentId: number
    userId: number
    method: number
    checkedAt: number
    _all: number
  }


  export type AttendanceCheckMinAggregateInputType = {
    id?: true
    appointmentId?: true
    userId?: true
    method?: true
    checkedAt?: true
  }

  export type AttendanceCheckMaxAggregateInputType = {
    id?: true
    appointmentId?: true
    userId?: true
    method?: true
    checkedAt?: true
  }

  export type AttendanceCheckCountAggregateInputType = {
    id?: true
    appointmentId?: true
    userId?: true
    method?: true
    checkedAt?: true
    _all?: true
  }

  export type AttendanceCheckAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceCheck to aggregate.
     */
    where?: AttendanceCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceChecks to fetch.
     */
    orderBy?: AttendanceCheckOrderByWithRelationInput | AttendanceCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AttendanceChecks
    **/
    _count?: true | AttendanceCheckCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceCheckMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceCheckMaxAggregateInputType
  }

  export type GetAttendanceCheckAggregateType<T extends AttendanceCheckAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendanceCheck]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendanceCheck[P]>
      : GetScalarType<T[P], AggregateAttendanceCheck[P]>
  }




  export type AttendanceCheckGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceCheckWhereInput
    orderBy?: AttendanceCheckOrderByWithAggregationInput | AttendanceCheckOrderByWithAggregationInput[]
    by: AttendanceCheckScalarFieldEnum[] | AttendanceCheckScalarFieldEnum
    having?: AttendanceCheckScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceCheckCountAggregateInputType | true
    _min?: AttendanceCheckMinAggregateInputType
    _max?: AttendanceCheckMaxAggregateInputType
  }

  export type AttendanceCheckGroupByOutputType = {
    id: string
    appointmentId: string
    userId: string
    method: string
    checkedAt: Date
    _count: AttendanceCheckCountAggregateOutputType | null
    _min: AttendanceCheckMinAggregateOutputType | null
    _max: AttendanceCheckMaxAggregateOutputType | null
  }

  type GetAttendanceCheckGroupByPayload<T extends AttendanceCheckGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceCheckGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceCheckGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceCheckGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceCheckGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceCheckSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appointmentId?: boolean
    userId?: boolean
    method?: boolean
    checkedAt?: boolean
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceCheck"]>

  export type AttendanceCheckSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appointmentId?: boolean
    userId?: boolean
    method?: boolean
    checkedAt?: boolean
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceCheck"]>

  export type AttendanceCheckSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appointmentId?: boolean
    userId?: boolean
    method?: boolean
    checkedAt?: boolean
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceCheck"]>

  export type AttendanceCheckSelectScalar = {
    id?: boolean
    appointmentId?: boolean
    userId?: boolean
    method?: boolean
    checkedAt?: boolean
  }

  export type AttendanceCheckOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "appointmentId" | "userId" | "method" | "checkedAt", ExtArgs["result"]["attendanceCheck"]>
  export type AttendanceCheckInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AttendanceCheckIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AttendanceCheckIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AttendanceCheckPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AttendanceCheck"
    objects: {
      appointment: Prisma.$AppointmentPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      appointmentId: string
      userId: string
      method: string
      checkedAt: Date
    }, ExtArgs["result"]["attendanceCheck"]>
    composites: {}
  }

  type AttendanceCheckGetPayload<S extends boolean | null | undefined | AttendanceCheckDefaultArgs> = $Result.GetResult<Prisma.$AttendanceCheckPayload, S>

  type AttendanceCheckCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendanceCheckFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendanceCheckCountAggregateInputType | true
    }

  export interface AttendanceCheckDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AttendanceCheck'], meta: { name: 'AttendanceCheck' } }
    /**
     * Find zero or one AttendanceCheck that matches the filter.
     * @param {AttendanceCheckFindUniqueArgs} args - Arguments to find a AttendanceCheck
     * @example
     * // Get one AttendanceCheck
     * const attendanceCheck = await prisma.attendanceCheck.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceCheckFindUniqueArgs>(args: SelectSubset<T, AttendanceCheckFindUniqueArgs<ExtArgs>>): Prisma__AttendanceCheckClient<$Result.GetResult<Prisma.$AttendanceCheckPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AttendanceCheck that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendanceCheckFindUniqueOrThrowArgs} args - Arguments to find a AttendanceCheck
     * @example
     * // Get one AttendanceCheck
     * const attendanceCheck = await prisma.attendanceCheck.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceCheckFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceCheckFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceCheckClient<$Result.GetResult<Prisma.$AttendanceCheckPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttendanceCheck that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceCheckFindFirstArgs} args - Arguments to find a AttendanceCheck
     * @example
     * // Get one AttendanceCheck
     * const attendanceCheck = await prisma.attendanceCheck.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceCheckFindFirstArgs>(args?: SelectSubset<T, AttendanceCheckFindFirstArgs<ExtArgs>>): Prisma__AttendanceCheckClient<$Result.GetResult<Prisma.$AttendanceCheckPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttendanceCheck that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceCheckFindFirstOrThrowArgs} args - Arguments to find a AttendanceCheck
     * @example
     * // Get one AttendanceCheck
     * const attendanceCheck = await prisma.attendanceCheck.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceCheckFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceCheckFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceCheckClient<$Result.GetResult<Prisma.$AttendanceCheckPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AttendanceChecks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceCheckFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AttendanceChecks
     * const attendanceChecks = await prisma.attendanceCheck.findMany()
     * 
     * // Get first 10 AttendanceChecks
     * const attendanceChecks = await prisma.attendanceCheck.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceCheckWithIdOnly = await prisma.attendanceCheck.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceCheckFindManyArgs>(args?: SelectSubset<T, AttendanceCheckFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceCheckPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AttendanceCheck.
     * @param {AttendanceCheckCreateArgs} args - Arguments to create a AttendanceCheck.
     * @example
     * // Create one AttendanceCheck
     * const AttendanceCheck = await prisma.attendanceCheck.create({
     *   data: {
     *     // ... data to create a AttendanceCheck
     *   }
     * })
     * 
     */
    create<T extends AttendanceCheckCreateArgs>(args: SelectSubset<T, AttendanceCheckCreateArgs<ExtArgs>>): Prisma__AttendanceCheckClient<$Result.GetResult<Prisma.$AttendanceCheckPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AttendanceChecks.
     * @param {AttendanceCheckCreateManyArgs} args - Arguments to create many AttendanceChecks.
     * @example
     * // Create many AttendanceChecks
     * const attendanceCheck = await prisma.attendanceCheck.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceCheckCreateManyArgs>(args?: SelectSubset<T, AttendanceCheckCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AttendanceChecks and returns the data saved in the database.
     * @param {AttendanceCheckCreateManyAndReturnArgs} args - Arguments to create many AttendanceChecks.
     * @example
     * // Create many AttendanceChecks
     * const attendanceCheck = await prisma.attendanceCheck.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AttendanceChecks and only return the `id`
     * const attendanceCheckWithIdOnly = await prisma.attendanceCheck.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendanceCheckCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendanceCheckCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceCheckPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AttendanceCheck.
     * @param {AttendanceCheckDeleteArgs} args - Arguments to delete one AttendanceCheck.
     * @example
     * // Delete one AttendanceCheck
     * const AttendanceCheck = await prisma.attendanceCheck.delete({
     *   where: {
     *     // ... filter to delete one AttendanceCheck
     *   }
     * })
     * 
     */
    delete<T extends AttendanceCheckDeleteArgs>(args: SelectSubset<T, AttendanceCheckDeleteArgs<ExtArgs>>): Prisma__AttendanceCheckClient<$Result.GetResult<Prisma.$AttendanceCheckPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AttendanceCheck.
     * @param {AttendanceCheckUpdateArgs} args - Arguments to update one AttendanceCheck.
     * @example
     * // Update one AttendanceCheck
     * const attendanceCheck = await prisma.attendanceCheck.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceCheckUpdateArgs>(args: SelectSubset<T, AttendanceCheckUpdateArgs<ExtArgs>>): Prisma__AttendanceCheckClient<$Result.GetResult<Prisma.$AttendanceCheckPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AttendanceChecks.
     * @param {AttendanceCheckDeleteManyArgs} args - Arguments to filter AttendanceChecks to delete.
     * @example
     * // Delete a few AttendanceChecks
     * const { count } = await prisma.attendanceCheck.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceCheckDeleteManyArgs>(args?: SelectSubset<T, AttendanceCheckDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceChecks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceCheckUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AttendanceChecks
     * const attendanceCheck = await prisma.attendanceCheck.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceCheckUpdateManyArgs>(args: SelectSubset<T, AttendanceCheckUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceChecks and returns the data updated in the database.
     * @param {AttendanceCheckUpdateManyAndReturnArgs} args - Arguments to update many AttendanceChecks.
     * @example
     * // Update many AttendanceChecks
     * const attendanceCheck = await prisma.attendanceCheck.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AttendanceChecks and only return the `id`
     * const attendanceCheckWithIdOnly = await prisma.attendanceCheck.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttendanceCheckUpdateManyAndReturnArgs>(args: SelectSubset<T, AttendanceCheckUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceCheckPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AttendanceCheck.
     * @param {AttendanceCheckUpsertArgs} args - Arguments to update or create a AttendanceCheck.
     * @example
     * // Update or create a AttendanceCheck
     * const attendanceCheck = await prisma.attendanceCheck.upsert({
     *   create: {
     *     // ... data to create a AttendanceCheck
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AttendanceCheck we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceCheckUpsertArgs>(args: SelectSubset<T, AttendanceCheckUpsertArgs<ExtArgs>>): Prisma__AttendanceCheckClient<$Result.GetResult<Prisma.$AttendanceCheckPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AttendanceChecks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceCheckCountArgs} args - Arguments to filter AttendanceChecks to count.
     * @example
     * // Count the number of AttendanceChecks
     * const count = await prisma.attendanceCheck.count({
     *   where: {
     *     // ... the filter for the AttendanceChecks we want to count
     *   }
     * })
    **/
    count<T extends AttendanceCheckCountArgs>(
      args?: Subset<T, AttendanceCheckCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceCheckCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AttendanceCheck.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceCheckAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceCheckAggregateArgs>(args: Subset<T, AttendanceCheckAggregateArgs>): Prisma.PrismaPromise<GetAttendanceCheckAggregateType<T>>

    /**
     * Group by AttendanceCheck.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceCheckGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceCheckGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceCheckGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceCheckGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceCheckGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceCheckGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AttendanceCheck model
   */
  readonly fields: AttendanceCheckFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AttendanceCheck.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceCheckClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    appointment<T extends AppointmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AppointmentDefaultArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AttendanceCheck model
   */
  interface AttendanceCheckFieldRefs {
    readonly id: FieldRef<"AttendanceCheck", 'String'>
    readonly appointmentId: FieldRef<"AttendanceCheck", 'String'>
    readonly userId: FieldRef<"AttendanceCheck", 'String'>
    readonly method: FieldRef<"AttendanceCheck", 'String'>
    readonly checkedAt: FieldRef<"AttendanceCheck", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AttendanceCheck findUnique
   */
  export type AttendanceCheckFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceCheck
     */
    select?: AttendanceCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceCheck
     */
    omit?: AttendanceCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceCheckInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceCheck to fetch.
     */
    where: AttendanceCheckWhereUniqueInput
  }

  /**
   * AttendanceCheck findUniqueOrThrow
   */
  export type AttendanceCheckFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceCheck
     */
    select?: AttendanceCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceCheck
     */
    omit?: AttendanceCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceCheckInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceCheck to fetch.
     */
    where: AttendanceCheckWhereUniqueInput
  }

  /**
   * AttendanceCheck findFirst
   */
  export type AttendanceCheckFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceCheck
     */
    select?: AttendanceCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceCheck
     */
    omit?: AttendanceCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceCheckInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceCheck to fetch.
     */
    where?: AttendanceCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceChecks to fetch.
     */
    orderBy?: AttendanceCheckOrderByWithRelationInput | AttendanceCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceChecks.
     */
    cursor?: AttendanceCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceChecks.
     */
    distinct?: AttendanceCheckScalarFieldEnum | AttendanceCheckScalarFieldEnum[]
  }

  /**
   * AttendanceCheck findFirstOrThrow
   */
  export type AttendanceCheckFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceCheck
     */
    select?: AttendanceCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceCheck
     */
    omit?: AttendanceCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceCheckInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceCheck to fetch.
     */
    where?: AttendanceCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceChecks to fetch.
     */
    orderBy?: AttendanceCheckOrderByWithRelationInput | AttendanceCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceChecks.
     */
    cursor?: AttendanceCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceChecks.
     */
    distinct?: AttendanceCheckScalarFieldEnum | AttendanceCheckScalarFieldEnum[]
  }

  /**
   * AttendanceCheck findMany
   */
  export type AttendanceCheckFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceCheck
     */
    select?: AttendanceCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceCheck
     */
    omit?: AttendanceCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceCheckInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceChecks to fetch.
     */
    where?: AttendanceCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceChecks to fetch.
     */
    orderBy?: AttendanceCheckOrderByWithRelationInput | AttendanceCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AttendanceChecks.
     */
    cursor?: AttendanceCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceChecks.
     */
    skip?: number
    distinct?: AttendanceCheckScalarFieldEnum | AttendanceCheckScalarFieldEnum[]
  }

  /**
   * AttendanceCheck create
   */
  export type AttendanceCheckCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceCheck
     */
    select?: AttendanceCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceCheck
     */
    omit?: AttendanceCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceCheckInclude<ExtArgs> | null
    /**
     * The data needed to create a AttendanceCheck.
     */
    data: XOR<AttendanceCheckCreateInput, AttendanceCheckUncheckedCreateInput>
  }

  /**
   * AttendanceCheck createMany
   */
  export type AttendanceCheckCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AttendanceChecks.
     */
    data: AttendanceCheckCreateManyInput | AttendanceCheckCreateManyInput[]
  }

  /**
   * AttendanceCheck createManyAndReturn
   */
  export type AttendanceCheckCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceCheck
     */
    select?: AttendanceCheckSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceCheck
     */
    omit?: AttendanceCheckOmit<ExtArgs> | null
    /**
     * The data used to create many AttendanceChecks.
     */
    data: AttendanceCheckCreateManyInput | AttendanceCheckCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceCheckIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttendanceCheck update
   */
  export type AttendanceCheckUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceCheck
     */
    select?: AttendanceCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceCheck
     */
    omit?: AttendanceCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceCheckInclude<ExtArgs> | null
    /**
     * The data needed to update a AttendanceCheck.
     */
    data: XOR<AttendanceCheckUpdateInput, AttendanceCheckUncheckedUpdateInput>
    /**
     * Choose, which AttendanceCheck to update.
     */
    where: AttendanceCheckWhereUniqueInput
  }

  /**
   * AttendanceCheck updateMany
   */
  export type AttendanceCheckUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AttendanceChecks.
     */
    data: XOR<AttendanceCheckUpdateManyMutationInput, AttendanceCheckUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceChecks to update
     */
    where?: AttendanceCheckWhereInput
    /**
     * Limit how many AttendanceChecks to update.
     */
    limit?: number
  }

  /**
   * AttendanceCheck updateManyAndReturn
   */
  export type AttendanceCheckUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceCheck
     */
    select?: AttendanceCheckSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceCheck
     */
    omit?: AttendanceCheckOmit<ExtArgs> | null
    /**
     * The data used to update AttendanceChecks.
     */
    data: XOR<AttendanceCheckUpdateManyMutationInput, AttendanceCheckUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceChecks to update
     */
    where?: AttendanceCheckWhereInput
    /**
     * Limit how many AttendanceChecks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceCheckIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttendanceCheck upsert
   */
  export type AttendanceCheckUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceCheck
     */
    select?: AttendanceCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceCheck
     */
    omit?: AttendanceCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceCheckInclude<ExtArgs> | null
    /**
     * The filter to search for the AttendanceCheck to update in case it exists.
     */
    where: AttendanceCheckWhereUniqueInput
    /**
     * In case the AttendanceCheck found by the `where` argument doesn't exist, create a new AttendanceCheck with this data.
     */
    create: XOR<AttendanceCheckCreateInput, AttendanceCheckUncheckedCreateInput>
    /**
     * In case the AttendanceCheck was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceCheckUpdateInput, AttendanceCheckUncheckedUpdateInput>
  }

  /**
   * AttendanceCheck delete
   */
  export type AttendanceCheckDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceCheck
     */
    select?: AttendanceCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceCheck
     */
    omit?: AttendanceCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceCheckInclude<ExtArgs> | null
    /**
     * Filter which AttendanceCheck to delete.
     */
    where: AttendanceCheckWhereUniqueInput
  }

  /**
   * AttendanceCheck deleteMany
   */
  export type AttendanceCheckDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceChecks to delete
     */
    where?: AttendanceCheckWhereInput
    /**
     * Limit how many AttendanceChecks to delete.
     */
    limit?: number
  }

  /**
   * AttendanceCheck without action
   */
  export type AttendanceCheckDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceCheck
     */
    select?: AttendanceCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceCheck
     */
    omit?: AttendanceCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceCheckInclude<ExtArgs> | null
  }


  /**
   * Model Report
   */

  export type AggregateReport = {
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  export type ReportMinAggregateOutputType = {
    id: string | null
    appointmentId: string | null
    reporterId: string | null
    targetUserId: string | null
    reason: string | null
    evidence: string | null
    status: $Enums.ReportStatus | null
    createdAt: Date | null
  }

  export type ReportMaxAggregateOutputType = {
    id: string | null
    appointmentId: string | null
    reporterId: string | null
    targetUserId: string | null
    reason: string | null
    evidence: string | null
    status: $Enums.ReportStatus | null
    createdAt: Date | null
  }

  export type ReportCountAggregateOutputType = {
    id: number
    appointmentId: number
    reporterId: number
    targetUserId: number
    reason: number
    evidence: number
    status: number
    createdAt: number
    _all: number
  }


  export type ReportMinAggregateInputType = {
    id?: true
    appointmentId?: true
    reporterId?: true
    targetUserId?: true
    reason?: true
    evidence?: true
    status?: true
    createdAt?: true
  }

  export type ReportMaxAggregateInputType = {
    id?: true
    appointmentId?: true
    reporterId?: true
    targetUserId?: true
    reason?: true
    evidence?: true
    status?: true
    createdAt?: true
  }

  export type ReportCountAggregateInputType = {
    id?: true
    appointmentId?: true
    reporterId?: true
    targetUserId?: true
    reason?: true
    evidence?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type ReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Report to aggregate.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reports
    **/
    _count?: true | ReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportMaxAggregateInputType
  }

  export type GetReportAggregateType<T extends ReportAggregateArgs> = {
        [P in keyof T & keyof AggregateReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport[P]>
      : GetScalarType<T[P], AggregateReport[P]>
  }




  export type ReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithAggregationInput | ReportOrderByWithAggregationInput[]
    by: ReportScalarFieldEnum[] | ReportScalarFieldEnum
    having?: ReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportCountAggregateInputType | true
    _min?: ReportMinAggregateInputType
    _max?: ReportMaxAggregateInputType
  }

  export type ReportGroupByOutputType = {
    id: string
    appointmentId: string
    reporterId: string
    targetUserId: string
    reason: string
    evidence: string | null
    status: $Enums.ReportStatus
    createdAt: Date
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  type GetReportGroupByPayload<T extends ReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportGroupByOutputType[P]>
            : GetScalarType<T[P], ReportGroupByOutputType[P]>
        }
      >
    >


  export type ReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appointmentId?: boolean
    reporterId?: boolean
    targetUserId?: boolean
    reason?: boolean
    evidence?: boolean
    status?: boolean
    createdAt?: boolean
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
    reporter?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appointmentId?: boolean
    reporterId?: boolean
    targetUserId?: boolean
    reason?: boolean
    evidence?: boolean
    status?: boolean
    createdAt?: boolean
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
    reporter?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appointmentId?: boolean
    reporterId?: boolean
    targetUserId?: boolean
    reason?: boolean
    evidence?: boolean
    status?: boolean
    createdAt?: boolean
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
    reporter?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectScalar = {
    id?: boolean
    appointmentId?: boolean
    reporterId?: boolean
    targetUserId?: boolean
    reason?: boolean
    evidence?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type ReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "appointmentId" | "reporterId" | "targetUserId" | "reason" | "evidence" | "status" | "createdAt", ExtArgs["result"]["report"]>
  export type ReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
    reporter?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
    reporter?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
    reporter?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Report"
    objects: {
      appointment: Prisma.$AppointmentPayload<ExtArgs>
      reporter: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      appointmentId: string
      reporterId: string
      targetUserId: string
      reason: string
      evidence: string | null
      status: $Enums.ReportStatus
      createdAt: Date
    }, ExtArgs["result"]["report"]>
    composites: {}
  }

  type ReportGetPayload<S extends boolean | null | undefined | ReportDefaultArgs> = $Result.GetResult<Prisma.$ReportPayload, S>

  type ReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReportCountAggregateInputType | true
    }

  export interface ReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Report'], meta: { name: 'Report' } }
    /**
     * Find zero or one Report that matches the filter.
     * @param {ReportFindUniqueArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportFindUniqueArgs>(args: SelectSubset<T, ReportFindUniqueArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Report that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReportFindUniqueOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportFindFirstArgs>(args?: SelectSubset<T, ReportFindFirstArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Report that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.report.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.report.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportWithIdOnly = await prisma.report.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportFindManyArgs>(args?: SelectSubset<T, ReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Report.
     * @param {ReportCreateArgs} args - Arguments to create a Report.
     * @example
     * // Create one Report
     * const Report = await prisma.report.create({
     *   data: {
     *     // ... data to create a Report
     *   }
     * })
     * 
     */
    create<T extends ReportCreateArgs>(args: SelectSubset<T, ReportCreateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reports.
     * @param {ReportCreateManyArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportCreateManyArgs>(args?: SelectSubset<T, ReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reports and returns the data saved in the database.
     * @param {ReportCreateManyAndReturnArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reports and only return the `id`
     * const reportWithIdOnly = await prisma.report.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Report.
     * @param {ReportDeleteArgs} args - Arguments to delete one Report.
     * @example
     * // Delete one Report
     * const Report = await prisma.report.delete({
     *   where: {
     *     // ... filter to delete one Report
     *   }
     * })
     * 
     */
    delete<T extends ReportDeleteArgs>(args: SelectSubset<T, ReportDeleteArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Report.
     * @param {ReportUpdateArgs} args - Arguments to update one Report.
     * @example
     * // Update one Report
     * const report = await prisma.report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportUpdateArgs>(args: SelectSubset<T, ReportUpdateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reports.
     * @param {ReportDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportDeleteManyArgs>(args?: SelectSubset<T, ReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportUpdateManyArgs>(args: SelectSubset<T, ReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports and returns the data updated in the database.
     * @param {ReportUpdateManyAndReturnArgs} args - Arguments to update many Reports.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reports and only return the `id`
     * const reportWithIdOnly = await prisma.report.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReportUpdateManyAndReturnArgs>(args: SelectSubset<T, ReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Report.
     * @param {ReportUpsertArgs} args - Arguments to update or create a Report.
     * @example
     * // Update or create a Report
     * const report = await prisma.report.upsert({
     *   create: {
     *     // ... data to create a Report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report we want to update
     *   }
     * })
     */
    upsert<T extends ReportUpsertArgs>(args: SelectSubset<T, ReportUpsertArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.report.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends ReportCountArgs>(
      args?: Subset<T, ReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportAggregateArgs>(args: Subset<T, ReportAggregateArgs>): Prisma.PrismaPromise<GetReportAggregateType<T>>

    /**
     * Group by Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportGroupByArgs['orderBy'] }
        : { orderBy?: ReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Report model
   */
  readonly fields: ReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    appointment<T extends AppointmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AppointmentDefaultArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reporter<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Report model
   */
  interface ReportFieldRefs {
    readonly id: FieldRef<"Report", 'String'>
    readonly appointmentId: FieldRef<"Report", 'String'>
    readonly reporterId: FieldRef<"Report", 'String'>
    readonly targetUserId: FieldRef<"Report", 'String'>
    readonly reason: FieldRef<"Report", 'String'>
    readonly evidence: FieldRef<"Report", 'String'>
    readonly status: FieldRef<"Report", 'ReportStatus'>
    readonly createdAt: FieldRef<"Report", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Report findUnique
   */
  export type ReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findUniqueOrThrow
   */
  export type ReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findFirst
   */
  export type ReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findFirstOrThrow
   */
  export type ReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findMany
   */
  export type ReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Reports to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report create
   */
  export type ReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to create a Report.
     */
    data: XOR<ReportCreateInput, ReportUncheckedCreateInput>
  }

  /**
   * Report createMany
   */
  export type ReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
  }

  /**
   * Report createManyAndReturn
   */
  export type ReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Report update
   */
  export type ReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to update a Report.
     */
    data: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
    /**
     * Choose, which Report to update.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report updateMany
   */
  export type ReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
    /**
     * Limit how many Reports to update.
     */
    limit?: number
  }

  /**
   * Report updateManyAndReturn
   */
  export type ReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
    /**
     * Limit how many Reports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Report upsert
   */
  export type ReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The filter to search for the Report to update in case it exists.
     */
    where: ReportWhereUniqueInput
    /**
     * In case the Report found by the `where` argument doesn't exist, create a new Report with this data.
     */
    create: XOR<ReportCreateInput, ReportUncheckedCreateInput>
    /**
     * In case the Report was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
  }

  /**
   * Report delete
   */
  export type ReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter which Report to delete.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report deleteMany
   */
  export type ReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reports to delete
     */
    where?: ReportWhereInput
    /**
     * Limit how many Reports to delete.
     */
    limit?: number
  }

  /**
   * Report without action
   */
  export type ReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
  }


  /**
   * Model Sanction
   */

  export type AggregateSanction = {
    _count: SanctionCountAggregateOutputType | null
    _min: SanctionMinAggregateOutputType | null
    _max: SanctionMaxAggregateOutputType | null
  }

  export type SanctionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    level: $Enums.SanctionLevel | null
    reason: string | null
    startAt: Date | null
    endAt: Date | null
    createdAt: Date | null
  }

  export type SanctionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    level: $Enums.SanctionLevel | null
    reason: string | null
    startAt: Date | null
    endAt: Date | null
    createdAt: Date | null
  }

  export type SanctionCountAggregateOutputType = {
    id: number
    userId: number
    level: number
    reason: number
    startAt: number
    endAt: number
    createdAt: number
    _all: number
  }


  export type SanctionMinAggregateInputType = {
    id?: true
    userId?: true
    level?: true
    reason?: true
    startAt?: true
    endAt?: true
    createdAt?: true
  }

  export type SanctionMaxAggregateInputType = {
    id?: true
    userId?: true
    level?: true
    reason?: true
    startAt?: true
    endAt?: true
    createdAt?: true
  }

  export type SanctionCountAggregateInputType = {
    id?: true
    userId?: true
    level?: true
    reason?: true
    startAt?: true
    endAt?: true
    createdAt?: true
    _all?: true
  }

  export type SanctionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sanction to aggregate.
     */
    where?: SanctionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sanctions to fetch.
     */
    orderBy?: SanctionOrderByWithRelationInput | SanctionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SanctionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sanctions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sanctions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sanctions
    **/
    _count?: true | SanctionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SanctionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SanctionMaxAggregateInputType
  }

  export type GetSanctionAggregateType<T extends SanctionAggregateArgs> = {
        [P in keyof T & keyof AggregateSanction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSanction[P]>
      : GetScalarType<T[P], AggregateSanction[P]>
  }




  export type SanctionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SanctionWhereInput
    orderBy?: SanctionOrderByWithAggregationInput | SanctionOrderByWithAggregationInput[]
    by: SanctionScalarFieldEnum[] | SanctionScalarFieldEnum
    having?: SanctionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SanctionCountAggregateInputType | true
    _min?: SanctionMinAggregateInputType
    _max?: SanctionMaxAggregateInputType
  }

  export type SanctionGroupByOutputType = {
    id: string
    userId: string
    level: $Enums.SanctionLevel
    reason: string
    startAt: Date
    endAt: Date | null
    createdAt: Date
    _count: SanctionCountAggregateOutputType | null
    _min: SanctionMinAggregateOutputType | null
    _max: SanctionMaxAggregateOutputType | null
  }

  type GetSanctionGroupByPayload<T extends SanctionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SanctionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SanctionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SanctionGroupByOutputType[P]>
            : GetScalarType<T[P], SanctionGroupByOutputType[P]>
        }
      >
    >


  export type SanctionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    level?: boolean
    reason?: boolean
    startAt?: boolean
    endAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sanction"]>

  export type SanctionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    level?: boolean
    reason?: boolean
    startAt?: boolean
    endAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sanction"]>

  export type SanctionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    level?: boolean
    reason?: boolean
    startAt?: boolean
    endAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sanction"]>

  export type SanctionSelectScalar = {
    id?: boolean
    userId?: boolean
    level?: boolean
    reason?: boolean
    startAt?: boolean
    endAt?: boolean
    createdAt?: boolean
  }

  export type SanctionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "level" | "reason" | "startAt" | "endAt" | "createdAt", ExtArgs["result"]["sanction"]>
  export type SanctionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SanctionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SanctionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SanctionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sanction"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      level: $Enums.SanctionLevel
      reason: string
      startAt: Date
      endAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["sanction"]>
    composites: {}
  }

  type SanctionGetPayload<S extends boolean | null | undefined | SanctionDefaultArgs> = $Result.GetResult<Prisma.$SanctionPayload, S>

  type SanctionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SanctionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SanctionCountAggregateInputType | true
    }

  export interface SanctionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sanction'], meta: { name: 'Sanction' } }
    /**
     * Find zero or one Sanction that matches the filter.
     * @param {SanctionFindUniqueArgs} args - Arguments to find a Sanction
     * @example
     * // Get one Sanction
     * const sanction = await prisma.sanction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SanctionFindUniqueArgs>(args: SelectSubset<T, SanctionFindUniqueArgs<ExtArgs>>): Prisma__SanctionClient<$Result.GetResult<Prisma.$SanctionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sanction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SanctionFindUniqueOrThrowArgs} args - Arguments to find a Sanction
     * @example
     * // Get one Sanction
     * const sanction = await prisma.sanction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SanctionFindUniqueOrThrowArgs>(args: SelectSubset<T, SanctionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SanctionClient<$Result.GetResult<Prisma.$SanctionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sanction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SanctionFindFirstArgs} args - Arguments to find a Sanction
     * @example
     * // Get one Sanction
     * const sanction = await prisma.sanction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SanctionFindFirstArgs>(args?: SelectSubset<T, SanctionFindFirstArgs<ExtArgs>>): Prisma__SanctionClient<$Result.GetResult<Prisma.$SanctionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sanction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SanctionFindFirstOrThrowArgs} args - Arguments to find a Sanction
     * @example
     * // Get one Sanction
     * const sanction = await prisma.sanction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SanctionFindFirstOrThrowArgs>(args?: SelectSubset<T, SanctionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SanctionClient<$Result.GetResult<Prisma.$SanctionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sanctions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SanctionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sanctions
     * const sanctions = await prisma.sanction.findMany()
     * 
     * // Get first 10 Sanctions
     * const sanctions = await prisma.sanction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sanctionWithIdOnly = await prisma.sanction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SanctionFindManyArgs>(args?: SelectSubset<T, SanctionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SanctionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sanction.
     * @param {SanctionCreateArgs} args - Arguments to create a Sanction.
     * @example
     * // Create one Sanction
     * const Sanction = await prisma.sanction.create({
     *   data: {
     *     // ... data to create a Sanction
     *   }
     * })
     * 
     */
    create<T extends SanctionCreateArgs>(args: SelectSubset<T, SanctionCreateArgs<ExtArgs>>): Prisma__SanctionClient<$Result.GetResult<Prisma.$SanctionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sanctions.
     * @param {SanctionCreateManyArgs} args - Arguments to create many Sanctions.
     * @example
     * // Create many Sanctions
     * const sanction = await prisma.sanction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SanctionCreateManyArgs>(args?: SelectSubset<T, SanctionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sanctions and returns the data saved in the database.
     * @param {SanctionCreateManyAndReturnArgs} args - Arguments to create many Sanctions.
     * @example
     * // Create many Sanctions
     * const sanction = await prisma.sanction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sanctions and only return the `id`
     * const sanctionWithIdOnly = await prisma.sanction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SanctionCreateManyAndReturnArgs>(args?: SelectSubset<T, SanctionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SanctionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Sanction.
     * @param {SanctionDeleteArgs} args - Arguments to delete one Sanction.
     * @example
     * // Delete one Sanction
     * const Sanction = await prisma.sanction.delete({
     *   where: {
     *     // ... filter to delete one Sanction
     *   }
     * })
     * 
     */
    delete<T extends SanctionDeleteArgs>(args: SelectSubset<T, SanctionDeleteArgs<ExtArgs>>): Prisma__SanctionClient<$Result.GetResult<Prisma.$SanctionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sanction.
     * @param {SanctionUpdateArgs} args - Arguments to update one Sanction.
     * @example
     * // Update one Sanction
     * const sanction = await prisma.sanction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SanctionUpdateArgs>(args: SelectSubset<T, SanctionUpdateArgs<ExtArgs>>): Prisma__SanctionClient<$Result.GetResult<Prisma.$SanctionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sanctions.
     * @param {SanctionDeleteManyArgs} args - Arguments to filter Sanctions to delete.
     * @example
     * // Delete a few Sanctions
     * const { count } = await prisma.sanction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SanctionDeleteManyArgs>(args?: SelectSubset<T, SanctionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sanctions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SanctionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sanctions
     * const sanction = await prisma.sanction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SanctionUpdateManyArgs>(args: SelectSubset<T, SanctionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sanctions and returns the data updated in the database.
     * @param {SanctionUpdateManyAndReturnArgs} args - Arguments to update many Sanctions.
     * @example
     * // Update many Sanctions
     * const sanction = await prisma.sanction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sanctions and only return the `id`
     * const sanctionWithIdOnly = await prisma.sanction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SanctionUpdateManyAndReturnArgs>(args: SelectSubset<T, SanctionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SanctionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Sanction.
     * @param {SanctionUpsertArgs} args - Arguments to update or create a Sanction.
     * @example
     * // Update or create a Sanction
     * const sanction = await prisma.sanction.upsert({
     *   create: {
     *     // ... data to create a Sanction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sanction we want to update
     *   }
     * })
     */
    upsert<T extends SanctionUpsertArgs>(args: SelectSubset<T, SanctionUpsertArgs<ExtArgs>>): Prisma__SanctionClient<$Result.GetResult<Prisma.$SanctionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sanctions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SanctionCountArgs} args - Arguments to filter Sanctions to count.
     * @example
     * // Count the number of Sanctions
     * const count = await prisma.sanction.count({
     *   where: {
     *     // ... the filter for the Sanctions we want to count
     *   }
     * })
    **/
    count<T extends SanctionCountArgs>(
      args?: Subset<T, SanctionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SanctionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sanction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SanctionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SanctionAggregateArgs>(args: Subset<T, SanctionAggregateArgs>): Prisma.PrismaPromise<GetSanctionAggregateType<T>>

    /**
     * Group by Sanction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SanctionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SanctionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SanctionGroupByArgs['orderBy'] }
        : { orderBy?: SanctionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SanctionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSanctionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sanction model
   */
  readonly fields: SanctionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sanction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SanctionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sanction model
   */
  interface SanctionFieldRefs {
    readonly id: FieldRef<"Sanction", 'String'>
    readonly userId: FieldRef<"Sanction", 'String'>
    readonly level: FieldRef<"Sanction", 'SanctionLevel'>
    readonly reason: FieldRef<"Sanction", 'String'>
    readonly startAt: FieldRef<"Sanction", 'DateTime'>
    readonly endAt: FieldRef<"Sanction", 'DateTime'>
    readonly createdAt: FieldRef<"Sanction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Sanction findUnique
   */
  export type SanctionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sanction
     */
    select?: SanctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sanction
     */
    omit?: SanctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SanctionInclude<ExtArgs> | null
    /**
     * Filter, which Sanction to fetch.
     */
    where: SanctionWhereUniqueInput
  }

  /**
   * Sanction findUniqueOrThrow
   */
  export type SanctionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sanction
     */
    select?: SanctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sanction
     */
    omit?: SanctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SanctionInclude<ExtArgs> | null
    /**
     * Filter, which Sanction to fetch.
     */
    where: SanctionWhereUniqueInput
  }

  /**
   * Sanction findFirst
   */
  export type SanctionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sanction
     */
    select?: SanctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sanction
     */
    omit?: SanctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SanctionInclude<ExtArgs> | null
    /**
     * Filter, which Sanction to fetch.
     */
    where?: SanctionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sanctions to fetch.
     */
    orderBy?: SanctionOrderByWithRelationInput | SanctionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sanctions.
     */
    cursor?: SanctionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sanctions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sanctions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sanctions.
     */
    distinct?: SanctionScalarFieldEnum | SanctionScalarFieldEnum[]
  }

  /**
   * Sanction findFirstOrThrow
   */
  export type SanctionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sanction
     */
    select?: SanctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sanction
     */
    omit?: SanctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SanctionInclude<ExtArgs> | null
    /**
     * Filter, which Sanction to fetch.
     */
    where?: SanctionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sanctions to fetch.
     */
    orderBy?: SanctionOrderByWithRelationInput | SanctionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sanctions.
     */
    cursor?: SanctionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sanctions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sanctions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sanctions.
     */
    distinct?: SanctionScalarFieldEnum | SanctionScalarFieldEnum[]
  }

  /**
   * Sanction findMany
   */
  export type SanctionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sanction
     */
    select?: SanctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sanction
     */
    omit?: SanctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SanctionInclude<ExtArgs> | null
    /**
     * Filter, which Sanctions to fetch.
     */
    where?: SanctionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sanctions to fetch.
     */
    orderBy?: SanctionOrderByWithRelationInput | SanctionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sanctions.
     */
    cursor?: SanctionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sanctions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sanctions.
     */
    skip?: number
    distinct?: SanctionScalarFieldEnum | SanctionScalarFieldEnum[]
  }

  /**
   * Sanction create
   */
  export type SanctionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sanction
     */
    select?: SanctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sanction
     */
    omit?: SanctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SanctionInclude<ExtArgs> | null
    /**
     * The data needed to create a Sanction.
     */
    data: XOR<SanctionCreateInput, SanctionUncheckedCreateInput>
  }

  /**
   * Sanction createMany
   */
  export type SanctionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sanctions.
     */
    data: SanctionCreateManyInput | SanctionCreateManyInput[]
  }

  /**
   * Sanction createManyAndReturn
   */
  export type SanctionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sanction
     */
    select?: SanctionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sanction
     */
    omit?: SanctionOmit<ExtArgs> | null
    /**
     * The data used to create many Sanctions.
     */
    data: SanctionCreateManyInput | SanctionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SanctionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sanction update
   */
  export type SanctionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sanction
     */
    select?: SanctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sanction
     */
    omit?: SanctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SanctionInclude<ExtArgs> | null
    /**
     * The data needed to update a Sanction.
     */
    data: XOR<SanctionUpdateInput, SanctionUncheckedUpdateInput>
    /**
     * Choose, which Sanction to update.
     */
    where: SanctionWhereUniqueInput
  }

  /**
   * Sanction updateMany
   */
  export type SanctionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sanctions.
     */
    data: XOR<SanctionUpdateManyMutationInput, SanctionUncheckedUpdateManyInput>
    /**
     * Filter which Sanctions to update
     */
    where?: SanctionWhereInput
    /**
     * Limit how many Sanctions to update.
     */
    limit?: number
  }

  /**
   * Sanction updateManyAndReturn
   */
  export type SanctionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sanction
     */
    select?: SanctionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sanction
     */
    omit?: SanctionOmit<ExtArgs> | null
    /**
     * The data used to update Sanctions.
     */
    data: XOR<SanctionUpdateManyMutationInput, SanctionUncheckedUpdateManyInput>
    /**
     * Filter which Sanctions to update
     */
    where?: SanctionWhereInput
    /**
     * Limit how many Sanctions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SanctionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sanction upsert
   */
  export type SanctionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sanction
     */
    select?: SanctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sanction
     */
    omit?: SanctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SanctionInclude<ExtArgs> | null
    /**
     * The filter to search for the Sanction to update in case it exists.
     */
    where: SanctionWhereUniqueInput
    /**
     * In case the Sanction found by the `where` argument doesn't exist, create a new Sanction with this data.
     */
    create: XOR<SanctionCreateInput, SanctionUncheckedCreateInput>
    /**
     * In case the Sanction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SanctionUpdateInput, SanctionUncheckedUpdateInput>
  }

  /**
   * Sanction delete
   */
  export type SanctionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sanction
     */
    select?: SanctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sanction
     */
    omit?: SanctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SanctionInclude<ExtArgs> | null
    /**
     * Filter which Sanction to delete.
     */
    where: SanctionWhereUniqueInput
  }

  /**
   * Sanction deleteMany
   */
  export type SanctionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sanctions to delete
     */
    where?: SanctionWhereInput
    /**
     * Limit how many Sanctions to delete.
     */
    limit?: number
  }

  /**
   * Sanction without action
   */
  export type SanctionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sanction
     */
    select?: SanctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sanction
     */
    omit?: SanctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SanctionInclude<ExtArgs> | null
  }


  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    scoreDelta: number | null
  }

  export type ReviewSumAggregateOutputType = {
    scoreDelta: number | null
  }

  export type ReviewMinAggregateOutputType = {
    id: string | null
    appointmentId: string | null
    reviewerId: string | null
    revieweeId: string | null
    comment: string | null
    scoreDelta: number | null
    createdAt: Date | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: string | null
    appointmentId: string | null
    reviewerId: string | null
    revieweeId: string | null
    comment: string | null
    scoreDelta: number | null
    createdAt: Date | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    appointmentId: number
    reviewerId: number
    revieweeId: number
    comment: number
    scoreDelta: number
    createdAt: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    scoreDelta?: true
  }

  export type ReviewSumAggregateInputType = {
    scoreDelta?: true
  }

  export type ReviewMinAggregateInputType = {
    id?: true
    appointmentId?: true
    reviewerId?: true
    revieweeId?: true
    comment?: true
    scoreDelta?: true
    createdAt?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    appointmentId?: true
    reviewerId?: true
    revieweeId?: true
    comment?: true
    scoreDelta?: true
    createdAt?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    appointmentId?: true
    reviewerId?: true
    revieweeId?: true
    comment?: true
    scoreDelta?: true
    createdAt?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    id: string
    appointmentId: string
    reviewerId: string
    revieweeId: string
    comment: string
    scoreDelta: number
    createdAt: Date
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appointmentId?: boolean
    reviewerId?: boolean
    revieweeId?: boolean
    comment?: boolean
    scoreDelta?: boolean
    createdAt?: boolean
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
    reviewee?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appointmentId?: boolean
    reviewerId?: boolean
    revieweeId?: boolean
    comment?: boolean
    scoreDelta?: boolean
    createdAt?: boolean
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
    reviewee?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appointmentId?: boolean
    reviewerId?: boolean
    revieweeId?: boolean
    comment?: boolean
    scoreDelta?: boolean
    createdAt?: boolean
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
    reviewee?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectScalar = {
    id?: boolean
    appointmentId?: boolean
    reviewerId?: boolean
    revieweeId?: boolean
    comment?: boolean
    scoreDelta?: boolean
    createdAt?: boolean
  }

  export type ReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "appointmentId" | "reviewerId" | "revieweeId" | "comment" | "scoreDelta" | "createdAt", ExtArgs["result"]["review"]>
  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
    reviewee?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
    reviewee?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
    reviewee?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review"
    objects: {
      appointment: Prisma.$AppointmentPayload<ExtArgs>
      reviewer: Prisma.$UserPayload<ExtArgs>
      reviewee: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      appointmentId: string
      reviewerId: string
      revieweeId: string
      comment: string
      scoreDelta: number
      createdAt: Date
    }, ExtArgs["result"]["review"]>
    composites: {}
  }

  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<Prisma.$ReviewPayload, S>

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Review'], meta: { name: 'Review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewFindManyArgs>(args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
     */
    create<T extends ReviewCreateArgs>(args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewCreateManyArgs>(args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {ReviewCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
     */
    delete<T extends ReviewDeleteArgs>(args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewUpdateArgs>(args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewDeleteManyArgs>(args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewUpdateManyArgs>(args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews and returns the data updated in the database.
     * @param {ReviewUpdateManyAndReturnArgs} args - Arguments to update many Reviews.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReviewUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Review model
   */
  readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    appointment<T extends AppointmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AppointmentDefaultArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reviewer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reviewee<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Review model
   */
  interface ReviewFieldRefs {
    readonly id: FieldRef<"Review", 'String'>
    readonly appointmentId: FieldRef<"Review", 'String'>
    readonly reviewerId: FieldRef<"Review", 'String'>
    readonly revieweeId: FieldRef<"Review", 'String'>
    readonly comment: FieldRef<"Review", 'String'>
    readonly scoreDelta: FieldRef<"Review", 'Int'>
    readonly createdAt: FieldRef<"Review", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
  }

  /**
   * Review createManyAndReturn
   */
  export type ReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
  }

  /**
   * Review updateManyAndReturn
   */
  export type ReviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to delete.
     */
    limit?: number
  }

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    provider: 'provider',
    nickname: 'nickname',
    bio: 'bio',
    region: 'region',
    trustScore: 'trustScore',
    phoneVerified: 'phoneVerified',
    blocked: 'blocked',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserInterestScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name'
  };

  export type UserInterestScalarFieldEnum = (typeof UserInterestScalarFieldEnum)[keyof typeof UserInterestScalarFieldEnum]


  export const AvailabilitySlotScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    weekday: 'weekday',
    startTime: 'startTime',
    endTime: 'endTime',
    area: 'area',
    createdAt: 'createdAt'
  };

  export type AvailabilitySlotScalarFieldEnum = (typeof AvailabilitySlotScalarFieldEnum)[keyof typeof AvailabilitySlotScalarFieldEnum]


  export const MatchProposalScalarFieldEnum: {
    id: 'id',
    proposerId: 'proposerId',
    partnerId: 'partnerId',
    message: 'message',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type MatchProposalScalarFieldEnum = (typeof MatchProposalScalarFieldEnum)[keyof typeof MatchProposalScalarFieldEnum]


  export const AppointmentScalarFieldEnum: {
    id: 'id',
    proposalId: 'proposalId',
    userAId: 'userAId',
    userBId: 'userBId',
    place: 'place',
    startsAt: 'startsAt',
    status: 'status',
    checkinCode: 'checkinCode',
    createdAt: 'createdAt'
  };

  export type AppointmentScalarFieldEnum = (typeof AppointmentScalarFieldEnum)[keyof typeof AppointmentScalarFieldEnum]


  export const AttendanceCheckScalarFieldEnum: {
    id: 'id',
    appointmentId: 'appointmentId',
    userId: 'userId',
    method: 'method',
    checkedAt: 'checkedAt'
  };

  export type AttendanceCheckScalarFieldEnum = (typeof AttendanceCheckScalarFieldEnum)[keyof typeof AttendanceCheckScalarFieldEnum]


  export const ReportScalarFieldEnum: {
    id: 'id',
    appointmentId: 'appointmentId',
    reporterId: 'reporterId',
    targetUserId: 'targetUserId',
    reason: 'reason',
    evidence: 'evidence',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type ReportScalarFieldEnum = (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum]


  export const SanctionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    level: 'level',
    reason: 'reason',
    startAt: 'startAt',
    endAt: 'endAt',
    createdAt: 'createdAt'
  };

  export type SanctionScalarFieldEnum = (typeof SanctionScalarFieldEnum)[keyof typeof SanctionScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    appointmentId: 'appointmentId',
    reviewerId: 'reviewerId',
    revieweeId: 'revieweeId',
    comment: 'comment',
    scoreDelta: 'scoreDelta',
    createdAt: 'createdAt'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'MatchStatus'
   */
  export type EnumMatchStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MatchStatus'>
    


  /**
   * Reference to a field of type 'AppointmentStatus'
   */
  export type EnumAppointmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentStatus'>
    


  /**
   * Reference to a field of type 'ReportStatus'
   */
  export type EnumReportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportStatus'>
    


  /**
   * Reference to a field of type 'SanctionLevel'
   */
  export type EnumSanctionLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SanctionLevel'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    provider?: StringFilter<"User"> | string
    nickname?: StringFilter<"User"> | string
    bio?: StringNullableFilter<"User"> | string | null
    region?: StringNullableFilter<"User"> | string | null
    trustScore?: IntFilter<"User"> | number
    phoneVerified?: BoolFilter<"User"> | boolean
    blocked?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    interests?: UserInterestListRelationFilter
    availability?: AvailabilitySlotListRelationFilter
    proposer?: MatchProposalListRelationFilter
    partner?: MatchProposalListRelationFilter
    appointmentsA?: AppointmentListRelationFilter
    appointmentsB?: AppointmentListRelationFilter
    checks?: AttendanceCheckListRelationFilter
    reports?: ReportListRelationFilter
    sanctions?: SanctionListRelationFilter
    reviewsGiven?: ReviewListRelationFilter
    reviewsRecv?: ReviewListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    provider?: SortOrder
    nickname?: SortOrder
    bio?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    trustScore?: SortOrder
    phoneVerified?: SortOrder
    blocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    interests?: UserInterestOrderByRelationAggregateInput
    availability?: AvailabilitySlotOrderByRelationAggregateInput
    proposer?: MatchProposalOrderByRelationAggregateInput
    partner?: MatchProposalOrderByRelationAggregateInput
    appointmentsA?: AppointmentOrderByRelationAggregateInput
    appointmentsB?: AppointmentOrderByRelationAggregateInput
    checks?: AttendanceCheckOrderByRelationAggregateInput
    reports?: ReportOrderByRelationAggregateInput
    sanctions?: SanctionOrderByRelationAggregateInput
    reviewsGiven?: ReviewOrderByRelationAggregateInput
    reviewsRecv?: ReviewOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    provider?: StringFilter<"User"> | string
    nickname?: StringFilter<"User"> | string
    bio?: StringNullableFilter<"User"> | string | null
    region?: StringNullableFilter<"User"> | string | null
    trustScore?: IntFilter<"User"> | number
    phoneVerified?: BoolFilter<"User"> | boolean
    blocked?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    interests?: UserInterestListRelationFilter
    availability?: AvailabilitySlotListRelationFilter
    proposer?: MatchProposalListRelationFilter
    partner?: MatchProposalListRelationFilter
    appointmentsA?: AppointmentListRelationFilter
    appointmentsB?: AppointmentListRelationFilter
    checks?: AttendanceCheckListRelationFilter
    reports?: ReportListRelationFilter
    sanctions?: SanctionListRelationFilter
    reviewsGiven?: ReviewListRelationFilter
    reviewsRecv?: ReviewListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    provider?: SortOrder
    nickname?: SortOrder
    bio?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    trustScore?: SortOrder
    phoneVerified?: SortOrder
    blocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    provider?: StringWithAggregatesFilter<"User"> | string
    nickname?: StringWithAggregatesFilter<"User"> | string
    bio?: StringNullableWithAggregatesFilter<"User"> | string | null
    region?: StringNullableWithAggregatesFilter<"User"> | string | null
    trustScore?: IntWithAggregatesFilter<"User"> | number
    phoneVerified?: BoolWithAggregatesFilter<"User"> | boolean
    blocked?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type UserInterestWhereInput = {
    AND?: UserInterestWhereInput | UserInterestWhereInput[]
    OR?: UserInterestWhereInput[]
    NOT?: UserInterestWhereInput | UserInterestWhereInput[]
    id?: StringFilter<"UserInterest"> | string
    userId?: StringFilter<"UserInterest"> | string
    name?: StringFilter<"UserInterest"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserInterestOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserInterestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_name?: UserInterestUserIdNameCompoundUniqueInput
    AND?: UserInterestWhereInput | UserInterestWhereInput[]
    OR?: UserInterestWhereInput[]
    NOT?: UserInterestWhereInput | UserInterestWhereInput[]
    userId?: StringFilter<"UserInterest"> | string
    name?: StringFilter<"UserInterest"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_name">

  export type UserInterestOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    _count?: UserInterestCountOrderByAggregateInput
    _max?: UserInterestMaxOrderByAggregateInput
    _min?: UserInterestMinOrderByAggregateInput
  }

  export type UserInterestScalarWhereWithAggregatesInput = {
    AND?: UserInterestScalarWhereWithAggregatesInput | UserInterestScalarWhereWithAggregatesInput[]
    OR?: UserInterestScalarWhereWithAggregatesInput[]
    NOT?: UserInterestScalarWhereWithAggregatesInput | UserInterestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserInterest"> | string
    userId?: StringWithAggregatesFilter<"UserInterest"> | string
    name?: StringWithAggregatesFilter<"UserInterest"> | string
  }

  export type AvailabilitySlotWhereInput = {
    AND?: AvailabilitySlotWhereInput | AvailabilitySlotWhereInput[]
    OR?: AvailabilitySlotWhereInput[]
    NOT?: AvailabilitySlotWhereInput | AvailabilitySlotWhereInput[]
    id?: StringFilter<"AvailabilitySlot"> | string
    userId?: StringFilter<"AvailabilitySlot"> | string
    weekday?: IntFilter<"AvailabilitySlot"> | number
    startTime?: StringFilter<"AvailabilitySlot"> | string
    endTime?: StringFilter<"AvailabilitySlot"> | string
    area?: StringFilter<"AvailabilitySlot"> | string
    createdAt?: DateTimeFilter<"AvailabilitySlot"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AvailabilitySlotOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    weekday?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    area?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AvailabilitySlotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AvailabilitySlotWhereInput | AvailabilitySlotWhereInput[]
    OR?: AvailabilitySlotWhereInput[]
    NOT?: AvailabilitySlotWhereInput | AvailabilitySlotWhereInput[]
    userId?: StringFilter<"AvailabilitySlot"> | string
    weekday?: IntFilter<"AvailabilitySlot"> | number
    startTime?: StringFilter<"AvailabilitySlot"> | string
    endTime?: StringFilter<"AvailabilitySlot"> | string
    area?: StringFilter<"AvailabilitySlot"> | string
    createdAt?: DateTimeFilter<"AvailabilitySlot"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AvailabilitySlotOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    weekday?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    area?: SortOrder
    createdAt?: SortOrder
    _count?: AvailabilitySlotCountOrderByAggregateInput
    _avg?: AvailabilitySlotAvgOrderByAggregateInput
    _max?: AvailabilitySlotMaxOrderByAggregateInput
    _min?: AvailabilitySlotMinOrderByAggregateInput
    _sum?: AvailabilitySlotSumOrderByAggregateInput
  }

  export type AvailabilitySlotScalarWhereWithAggregatesInput = {
    AND?: AvailabilitySlotScalarWhereWithAggregatesInput | AvailabilitySlotScalarWhereWithAggregatesInput[]
    OR?: AvailabilitySlotScalarWhereWithAggregatesInput[]
    NOT?: AvailabilitySlotScalarWhereWithAggregatesInput | AvailabilitySlotScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AvailabilitySlot"> | string
    userId?: StringWithAggregatesFilter<"AvailabilitySlot"> | string
    weekday?: IntWithAggregatesFilter<"AvailabilitySlot"> | number
    startTime?: StringWithAggregatesFilter<"AvailabilitySlot"> | string
    endTime?: StringWithAggregatesFilter<"AvailabilitySlot"> | string
    area?: StringWithAggregatesFilter<"AvailabilitySlot"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AvailabilitySlot"> | Date | string
  }

  export type MatchProposalWhereInput = {
    AND?: MatchProposalWhereInput | MatchProposalWhereInput[]
    OR?: MatchProposalWhereInput[]
    NOT?: MatchProposalWhereInput | MatchProposalWhereInput[]
    id?: StringFilter<"MatchProposal"> | string
    proposerId?: StringFilter<"MatchProposal"> | string
    partnerId?: StringFilter<"MatchProposal"> | string
    message?: StringNullableFilter<"MatchProposal"> | string | null
    status?: EnumMatchStatusFilter<"MatchProposal"> | $Enums.MatchStatus
    createdAt?: DateTimeFilter<"MatchProposal"> | Date | string
    proposer?: XOR<UserScalarRelationFilter, UserWhereInput>
    partner?: XOR<UserScalarRelationFilter, UserWhereInput>
    appointment?: XOR<AppointmentNullableScalarRelationFilter, AppointmentWhereInput> | null
  }

  export type MatchProposalOrderByWithRelationInput = {
    id?: SortOrder
    proposerId?: SortOrder
    partnerId?: SortOrder
    message?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    proposer?: UserOrderByWithRelationInput
    partner?: UserOrderByWithRelationInput
    appointment?: AppointmentOrderByWithRelationInput
  }

  export type MatchProposalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MatchProposalWhereInput | MatchProposalWhereInput[]
    OR?: MatchProposalWhereInput[]
    NOT?: MatchProposalWhereInput | MatchProposalWhereInput[]
    proposerId?: StringFilter<"MatchProposal"> | string
    partnerId?: StringFilter<"MatchProposal"> | string
    message?: StringNullableFilter<"MatchProposal"> | string | null
    status?: EnumMatchStatusFilter<"MatchProposal"> | $Enums.MatchStatus
    createdAt?: DateTimeFilter<"MatchProposal"> | Date | string
    proposer?: XOR<UserScalarRelationFilter, UserWhereInput>
    partner?: XOR<UserScalarRelationFilter, UserWhereInput>
    appointment?: XOR<AppointmentNullableScalarRelationFilter, AppointmentWhereInput> | null
  }, "id">

  export type MatchProposalOrderByWithAggregationInput = {
    id?: SortOrder
    proposerId?: SortOrder
    partnerId?: SortOrder
    message?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: MatchProposalCountOrderByAggregateInput
    _max?: MatchProposalMaxOrderByAggregateInput
    _min?: MatchProposalMinOrderByAggregateInput
  }

  export type MatchProposalScalarWhereWithAggregatesInput = {
    AND?: MatchProposalScalarWhereWithAggregatesInput | MatchProposalScalarWhereWithAggregatesInput[]
    OR?: MatchProposalScalarWhereWithAggregatesInput[]
    NOT?: MatchProposalScalarWhereWithAggregatesInput | MatchProposalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MatchProposal"> | string
    proposerId?: StringWithAggregatesFilter<"MatchProposal"> | string
    partnerId?: StringWithAggregatesFilter<"MatchProposal"> | string
    message?: StringNullableWithAggregatesFilter<"MatchProposal"> | string | null
    status?: EnumMatchStatusWithAggregatesFilter<"MatchProposal"> | $Enums.MatchStatus
    createdAt?: DateTimeWithAggregatesFilter<"MatchProposal"> | Date | string
  }

  export type AppointmentWhereInput = {
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    id?: StringFilter<"Appointment"> | string
    proposalId?: StringFilter<"Appointment"> | string
    userAId?: StringFilter<"Appointment"> | string
    userBId?: StringFilter<"Appointment"> | string
    place?: StringFilter<"Appointment"> | string
    startsAt?: DateTimeFilter<"Appointment"> | Date | string
    status?: EnumAppointmentStatusFilter<"Appointment"> | $Enums.AppointmentStatus
    checkinCode?: StringFilter<"Appointment"> | string
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    proposal?: XOR<MatchProposalScalarRelationFilter, MatchProposalWhereInput>
    userA?: XOR<UserScalarRelationFilter, UserWhereInput>
    userB?: XOR<UserScalarRelationFilter, UserWhereInput>
    checks?: AttendanceCheckListRelationFilter
    reports?: ReportListRelationFilter
    reviews?: ReviewListRelationFilter
  }

  export type AppointmentOrderByWithRelationInput = {
    id?: SortOrder
    proposalId?: SortOrder
    userAId?: SortOrder
    userBId?: SortOrder
    place?: SortOrder
    startsAt?: SortOrder
    status?: SortOrder
    checkinCode?: SortOrder
    createdAt?: SortOrder
    proposal?: MatchProposalOrderByWithRelationInput
    userA?: UserOrderByWithRelationInput
    userB?: UserOrderByWithRelationInput
    checks?: AttendanceCheckOrderByRelationAggregateInput
    reports?: ReportOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
  }

  export type AppointmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    proposalId?: string
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    userAId?: StringFilter<"Appointment"> | string
    userBId?: StringFilter<"Appointment"> | string
    place?: StringFilter<"Appointment"> | string
    startsAt?: DateTimeFilter<"Appointment"> | Date | string
    status?: EnumAppointmentStatusFilter<"Appointment"> | $Enums.AppointmentStatus
    checkinCode?: StringFilter<"Appointment"> | string
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    proposal?: XOR<MatchProposalScalarRelationFilter, MatchProposalWhereInput>
    userA?: XOR<UserScalarRelationFilter, UserWhereInput>
    userB?: XOR<UserScalarRelationFilter, UserWhereInput>
    checks?: AttendanceCheckListRelationFilter
    reports?: ReportListRelationFilter
    reviews?: ReviewListRelationFilter
  }, "id" | "proposalId">

  export type AppointmentOrderByWithAggregationInput = {
    id?: SortOrder
    proposalId?: SortOrder
    userAId?: SortOrder
    userBId?: SortOrder
    place?: SortOrder
    startsAt?: SortOrder
    status?: SortOrder
    checkinCode?: SortOrder
    createdAt?: SortOrder
    _count?: AppointmentCountOrderByAggregateInput
    _max?: AppointmentMaxOrderByAggregateInput
    _min?: AppointmentMinOrderByAggregateInput
  }

  export type AppointmentScalarWhereWithAggregatesInput = {
    AND?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    OR?: AppointmentScalarWhereWithAggregatesInput[]
    NOT?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Appointment"> | string
    proposalId?: StringWithAggregatesFilter<"Appointment"> | string
    userAId?: StringWithAggregatesFilter<"Appointment"> | string
    userBId?: StringWithAggregatesFilter<"Appointment"> | string
    place?: StringWithAggregatesFilter<"Appointment"> | string
    startsAt?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    status?: EnumAppointmentStatusWithAggregatesFilter<"Appointment"> | $Enums.AppointmentStatus
    checkinCode?: StringWithAggregatesFilter<"Appointment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
  }

  export type AttendanceCheckWhereInput = {
    AND?: AttendanceCheckWhereInput | AttendanceCheckWhereInput[]
    OR?: AttendanceCheckWhereInput[]
    NOT?: AttendanceCheckWhereInput | AttendanceCheckWhereInput[]
    id?: StringFilter<"AttendanceCheck"> | string
    appointmentId?: StringFilter<"AttendanceCheck"> | string
    userId?: StringFilter<"AttendanceCheck"> | string
    method?: StringFilter<"AttendanceCheck"> | string
    checkedAt?: DateTimeFilter<"AttendanceCheck"> | Date | string
    appointment?: XOR<AppointmentScalarRelationFilter, AppointmentWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AttendanceCheckOrderByWithRelationInput = {
    id?: SortOrder
    appointmentId?: SortOrder
    userId?: SortOrder
    method?: SortOrder
    checkedAt?: SortOrder
    appointment?: AppointmentOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type AttendanceCheckWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    appointmentId_userId?: AttendanceCheckAppointmentIdUserIdCompoundUniqueInput
    AND?: AttendanceCheckWhereInput | AttendanceCheckWhereInput[]
    OR?: AttendanceCheckWhereInput[]
    NOT?: AttendanceCheckWhereInput | AttendanceCheckWhereInput[]
    appointmentId?: StringFilter<"AttendanceCheck"> | string
    userId?: StringFilter<"AttendanceCheck"> | string
    method?: StringFilter<"AttendanceCheck"> | string
    checkedAt?: DateTimeFilter<"AttendanceCheck"> | Date | string
    appointment?: XOR<AppointmentScalarRelationFilter, AppointmentWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "appointmentId_userId">

  export type AttendanceCheckOrderByWithAggregationInput = {
    id?: SortOrder
    appointmentId?: SortOrder
    userId?: SortOrder
    method?: SortOrder
    checkedAt?: SortOrder
    _count?: AttendanceCheckCountOrderByAggregateInput
    _max?: AttendanceCheckMaxOrderByAggregateInput
    _min?: AttendanceCheckMinOrderByAggregateInput
  }

  export type AttendanceCheckScalarWhereWithAggregatesInput = {
    AND?: AttendanceCheckScalarWhereWithAggregatesInput | AttendanceCheckScalarWhereWithAggregatesInput[]
    OR?: AttendanceCheckScalarWhereWithAggregatesInput[]
    NOT?: AttendanceCheckScalarWhereWithAggregatesInput | AttendanceCheckScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AttendanceCheck"> | string
    appointmentId?: StringWithAggregatesFilter<"AttendanceCheck"> | string
    userId?: StringWithAggregatesFilter<"AttendanceCheck"> | string
    method?: StringWithAggregatesFilter<"AttendanceCheck"> | string
    checkedAt?: DateTimeWithAggregatesFilter<"AttendanceCheck"> | Date | string
  }

  export type ReportWhereInput = {
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    id?: StringFilter<"Report"> | string
    appointmentId?: StringFilter<"Report"> | string
    reporterId?: StringFilter<"Report"> | string
    targetUserId?: StringFilter<"Report"> | string
    reason?: StringFilter<"Report"> | string
    evidence?: StringNullableFilter<"Report"> | string | null
    status?: EnumReportStatusFilter<"Report"> | $Enums.ReportStatus
    createdAt?: DateTimeFilter<"Report"> | Date | string
    appointment?: XOR<AppointmentScalarRelationFilter, AppointmentWhereInput>
    reporter?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ReportOrderByWithRelationInput = {
    id?: SortOrder
    appointmentId?: SortOrder
    reporterId?: SortOrder
    targetUserId?: SortOrder
    reason?: SortOrder
    evidence?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    appointment?: AppointmentOrderByWithRelationInput
    reporter?: UserOrderByWithRelationInput
  }

  export type ReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    appointmentId?: StringFilter<"Report"> | string
    reporterId?: StringFilter<"Report"> | string
    targetUserId?: StringFilter<"Report"> | string
    reason?: StringFilter<"Report"> | string
    evidence?: StringNullableFilter<"Report"> | string | null
    status?: EnumReportStatusFilter<"Report"> | $Enums.ReportStatus
    createdAt?: DateTimeFilter<"Report"> | Date | string
    appointment?: XOR<AppointmentScalarRelationFilter, AppointmentWhereInput>
    reporter?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ReportOrderByWithAggregationInput = {
    id?: SortOrder
    appointmentId?: SortOrder
    reporterId?: SortOrder
    targetUserId?: SortOrder
    reason?: SortOrder
    evidence?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: ReportCountOrderByAggregateInput
    _max?: ReportMaxOrderByAggregateInput
    _min?: ReportMinOrderByAggregateInput
  }

  export type ReportScalarWhereWithAggregatesInput = {
    AND?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    OR?: ReportScalarWhereWithAggregatesInput[]
    NOT?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Report"> | string
    appointmentId?: StringWithAggregatesFilter<"Report"> | string
    reporterId?: StringWithAggregatesFilter<"Report"> | string
    targetUserId?: StringWithAggregatesFilter<"Report"> | string
    reason?: StringWithAggregatesFilter<"Report"> | string
    evidence?: StringNullableWithAggregatesFilter<"Report"> | string | null
    status?: EnumReportStatusWithAggregatesFilter<"Report"> | $Enums.ReportStatus
    createdAt?: DateTimeWithAggregatesFilter<"Report"> | Date | string
  }

  export type SanctionWhereInput = {
    AND?: SanctionWhereInput | SanctionWhereInput[]
    OR?: SanctionWhereInput[]
    NOT?: SanctionWhereInput | SanctionWhereInput[]
    id?: StringFilter<"Sanction"> | string
    userId?: StringFilter<"Sanction"> | string
    level?: EnumSanctionLevelFilter<"Sanction"> | $Enums.SanctionLevel
    reason?: StringFilter<"Sanction"> | string
    startAt?: DateTimeFilter<"Sanction"> | Date | string
    endAt?: DateTimeNullableFilter<"Sanction"> | Date | string | null
    createdAt?: DateTimeFilter<"Sanction"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SanctionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    level?: SortOrder
    reason?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SanctionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SanctionWhereInput | SanctionWhereInput[]
    OR?: SanctionWhereInput[]
    NOT?: SanctionWhereInput | SanctionWhereInput[]
    userId?: StringFilter<"Sanction"> | string
    level?: EnumSanctionLevelFilter<"Sanction"> | $Enums.SanctionLevel
    reason?: StringFilter<"Sanction"> | string
    startAt?: DateTimeFilter<"Sanction"> | Date | string
    endAt?: DateTimeNullableFilter<"Sanction"> | Date | string | null
    createdAt?: DateTimeFilter<"Sanction"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type SanctionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    level?: SortOrder
    reason?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SanctionCountOrderByAggregateInput
    _max?: SanctionMaxOrderByAggregateInput
    _min?: SanctionMinOrderByAggregateInput
  }

  export type SanctionScalarWhereWithAggregatesInput = {
    AND?: SanctionScalarWhereWithAggregatesInput | SanctionScalarWhereWithAggregatesInput[]
    OR?: SanctionScalarWhereWithAggregatesInput[]
    NOT?: SanctionScalarWhereWithAggregatesInput | SanctionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Sanction"> | string
    userId?: StringWithAggregatesFilter<"Sanction"> | string
    level?: EnumSanctionLevelWithAggregatesFilter<"Sanction"> | $Enums.SanctionLevel
    reason?: StringWithAggregatesFilter<"Sanction"> | string
    startAt?: DateTimeWithAggregatesFilter<"Sanction"> | Date | string
    endAt?: DateTimeNullableWithAggregatesFilter<"Sanction"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Sanction"> | Date | string
  }

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    id?: StringFilter<"Review"> | string
    appointmentId?: StringFilter<"Review"> | string
    reviewerId?: StringFilter<"Review"> | string
    revieweeId?: StringFilter<"Review"> | string
    comment?: StringFilter<"Review"> | string
    scoreDelta?: IntFilter<"Review"> | number
    createdAt?: DateTimeFilter<"Review"> | Date | string
    appointment?: XOR<AppointmentScalarRelationFilter, AppointmentWhereInput>
    reviewer?: XOR<UserScalarRelationFilter, UserWhereInput>
    reviewee?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder
    appointmentId?: SortOrder
    reviewerId?: SortOrder
    revieweeId?: SortOrder
    comment?: SortOrder
    scoreDelta?: SortOrder
    createdAt?: SortOrder
    appointment?: AppointmentOrderByWithRelationInput
    reviewer?: UserOrderByWithRelationInput
    reviewee?: UserOrderByWithRelationInput
  }

  export type ReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    appointmentId_reviewerId?: ReviewAppointmentIdReviewerIdCompoundUniqueInput
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    appointmentId?: StringFilter<"Review"> | string
    reviewerId?: StringFilter<"Review"> | string
    revieweeId?: StringFilter<"Review"> | string
    comment?: StringFilter<"Review"> | string
    scoreDelta?: IntFilter<"Review"> | number
    createdAt?: DateTimeFilter<"Review"> | Date | string
    appointment?: XOR<AppointmentScalarRelationFilter, AppointmentWhereInput>
    reviewer?: XOR<UserScalarRelationFilter, UserWhereInput>
    reviewee?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "appointmentId_reviewerId">

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder
    appointmentId?: SortOrder
    reviewerId?: SortOrder
    revieweeId?: SortOrder
    comment?: SortOrder
    scoreDelta?: SortOrder
    createdAt?: SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _avg?: ReviewAvgOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
    _sum?: ReviewSumOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    OR?: ReviewScalarWhereWithAggregatesInput[]
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Review"> | string
    appointmentId?: StringWithAggregatesFilter<"Review"> | string
    reviewerId?: StringWithAggregatesFilter<"Review"> | string
    revieweeId?: StringWithAggregatesFilter<"Review"> | string
    comment?: StringWithAggregatesFilter<"Review"> | string
    scoreDelta?: IntWithAggregatesFilter<"Review"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    provider: string
    nickname: string
    bio?: string | null
    region?: string | null
    trustScore?: number
    phoneVerified?: boolean
    blocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: UserInterestCreateNestedManyWithoutUserInput
    availability?: AvailabilitySlotCreateNestedManyWithoutUserInput
    proposer?: MatchProposalCreateNestedManyWithoutProposerInput
    partner?: MatchProposalCreateNestedManyWithoutPartnerInput
    appointmentsA?: AppointmentCreateNestedManyWithoutUserAInput
    appointmentsB?: AppointmentCreateNestedManyWithoutUserBInput
    checks?: AttendanceCheckCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutReporterInput
    sanctions?: SanctionCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewCreateNestedManyWithoutReviewerInput
    reviewsRecv?: ReviewCreateNestedManyWithoutRevieweeInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    provider: string
    nickname: string
    bio?: string | null
    region?: string | null
    trustScore?: number
    phoneVerified?: boolean
    blocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: UserInterestUncheckedCreateNestedManyWithoutUserInput
    availability?: AvailabilitySlotUncheckedCreateNestedManyWithoutUserInput
    proposer?: MatchProposalUncheckedCreateNestedManyWithoutProposerInput
    partner?: MatchProposalUncheckedCreateNestedManyWithoutPartnerInput
    appointmentsA?: AppointmentUncheckedCreateNestedManyWithoutUserAInput
    appointmentsB?: AppointmentUncheckedCreateNestedManyWithoutUserBInput
    checks?: AttendanceCheckUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutReporterInput
    sanctions?: SanctionUncheckedCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutReviewerInput
    reviewsRecv?: ReviewUncheckedCreateNestedManyWithoutRevieweeInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    blocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: UserInterestUpdateManyWithoutUserNestedInput
    availability?: AvailabilitySlotUpdateManyWithoutUserNestedInput
    proposer?: MatchProposalUpdateManyWithoutProposerNestedInput
    partner?: MatchProposalUpdateManyWithoutPartnerNestedInput
    appointmentsA?: AppointmentUpdateManyWithoutUserANestedInput
    appointmentsB?: AppointmentUpdateManyWithoutUserBNestedInput
    checks?: AttendanceCheckUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutReporterNestedInput
    sanctions?: SanctionUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutReviewerNestedInput
    reviewsRecv?: ReviewUpdateManyWithoutRevieweeNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    blocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: UserInterestUncheckedUpdateManyWithoutUserNestedInput
    availability?: AvailabilitySlotUncheckedUpdateManyWithoutUserNestedInput
    proposer?: MatchProposalUncheckedUpdateManyWithoutProposerNestedInput
    partner?: MatchProposalUncheckedUpdateManyWithoutPartnerNestedInput
    appointmentsA?: AppointmentUncheckedUpdateManyWithoutUserANestedInput
    appointmentsB?: AppointmentUncheckedUpdateManyWithoutUserBNestedInput
    checks?: AttendanceCheckUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    sanctions?: SanctionUncheckedUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutReviewerNestedInput
    reviewsRecv?: ReviewUncheckedUpdateManyWithoutRevieweeNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    provider: string
    nickname: string
    bio?: string | null
    region?: string | null
    trustScore?: number
    phoneVerified?: boolean
    blocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    blocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    blocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserInterestCreateInput = {
    id?: string
    name: string
    user: UserCreateNestedOneWithoutInterestsInput
  }

  export type UserInterestUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
  }

  export type UserInterestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutInterestsNestedInput
  }

  export type UserInterestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type UserInterestCreateManyInput = {
    id?: string
    userId: string
    name: string
  }

  export type UserInterestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type UserInterestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AvailabilitySlotCreateInput = {
    id?: string
    weekday: number
    startTime: string
    endTime: string
    area: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAvailabilityInput
  }

  export type AvailabilitySlotUncheckedCreateInput = {
    id?: string
    userId: string
    weekday: number
    startTime: string
    endTime: string
    area: string
    createdAt?: Date | string
  }

  export type AvailabilitySlotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekday?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAvailabilityNestedInput
  }

  export type AvailabilitySlotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    weekday?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvailabilitySlotCreateManyInput = {
    id?: string
    userId: string
    weekday: number
    startTime: string
    endTime: string
    area: string
    createdAt?: Date | string
  }

  export type AvailabilitySlotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekday?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvailabilitySlotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    weekday?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchProposalCreateInput = {
    id?: string
    message?: string | null
    status?: $Enums.MatchStatus
    createdAt?: Date | string
    proposer: UserCreateNestedOneWithoutProposerInput
    partner: UserCreateNestedOneWithoutPartnerInput
    appointment?: AppointmentCreateNestedOneWithoutProposalInput
  }

  export type MatchProposalUncheckedCreateInput = {
    id?: string
    proposerId: string
    partnerId: string
    message?: string | null
    status?: $Enums.MatchStatus
    createdAt?: Date | string
    appointment?: AppointmentUncheckedCreateNestedOneWithoutProposalInput
  }

  export type MatchProposalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proposer?: UserUpdateOneRequiredWithoutProposerNestedInput
    partner?: UserUpdateOneRequiredWithoutPartnerNestedInput
    appointment?: AppointmentUpdateOneWithoutProposalNestedInput
  }

  export type MatchProposalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposerId?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUncheckedUpdateOneWithoutProposalNestedInput
  }

  export type MatchProposalCreateManyInput = {
    id?: string
    proposerId: string
    partnerId: string
    message?: string | null
    status?: $Enums.MatchStatus
    createdAt?: Date | string
  }

  export type MatchProposalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchProposalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposerId?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentCreateInput = {
    id?: string
    place: string
    startsAt: Date | string
    status?: $Enums.AppointmentStatus
    checkinCode: string
    createdAt?: Date | string
    proposal: MatchProposalCreateNestedOneWithoutAppointmentInput
    userA: UserCreateNestedOneWithoutAppointmentsAInput
    userB: UserCreateNestedOneWithoutAppointmentsBInput
    checks?: AttendanceCheckCreateNestedManyWithoutAppointmentInput
    reports?: ReportCreateNestedManyWithoutAppointmentInput
    reviews?: ReviewCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateInput = {
    id?: string
    proposalId: string
    userAId: string
    userBId: string
    place: string
    startsAt: Date | string
    status?: $Enums.AppointmentStatus
    checkinCode: string
    createdAt?: Date | string
    checks?: AttendanceCheckUncheckedCreateNestedManyWithoutAppointmentInput
    reports?: ReportUncheckedCreateNestedManyWithoutAppointmentInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    place?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    checkinCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proposal?: MatchProposalUpdateOneRequiredWithoutAppointmentNestedInput
    userA?: UserUpdateOneRequiredWithoutAppointmentsANestedInput
    userB?: UserUpdateOneRequiredWithoutAppointmentsBNestedInput
    checks?: AttendanceCheckUpdateManyWithoutAppointmentNestedInput
    reports?: ReportUpdateManyWithoutAppointmentNestedInput
    reviews?: ReviewUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposalId?: StringFieldUpdateOperationsInput | string
    userAId?: StringFieldUpdateOperationsInput | string
    userBId?: StringFieldUpdateOperationsInput | string
    place?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    checkinCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checks?: AttendanceCheckUncheckedUpdateManyWithoutAppointmentNestedInput
    reports?: ReportUncheckedUpdateManyWithoutAppointmentNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentCreateManyInput = {
    id?: string
    proposalId: string
    userAId: string
    userBId: string
    place: string
    startsAt: Date | string
    status?: $Enums.AppointmentStatus
    checkinCode: string
    createdAt?: Date | string
  }

  export type AppointmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    place?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    checkinCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposalId?: StringFieldUpdateOperationsInput | string
    userAId?: StringFieldUpdateOperationsInput | string
    userBId?: StringFieldUpdateOperationsInput | string
    place?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    checkinCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCheckCreateInput = {
    id?: string
    method: string
    checkedAt?: Date | string
    appointment: AppointmentCreateNestedOneWithoutChecksInput
    user: UserCreateNestedOneWithoutChecksInput
  }

  export type AttendanceCheckUncheckedCreateInput = {
    id?: string
    appointmentId: string
    userId: string
    method: string
    checkedAt?: Date | string
  }

  export type AttendanceCheckUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneRequiredWithoutChecksNestedInput
    user?: UserUpdateOneRequiredWithoutChecksNestedInput
  }

  export type AttendanceCheckUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCheckCreateManyInput = {
    id?: string
    appointmentId: string
    userId: string
    method: string
    checkedAt?: Date | string
  }

  export type AttendanceCheckUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCheckUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCreateInput = {
    id?: string
    targetUserId: string
    reason: string
    evidence?: string | null
    status?: $Enums.ReportStatus
    createdAt?: Date | string
    appointment: AppointmentCreateNestedOneWithoutReportsInput
    reporter: UserCreateNestedOneWithoutReportsInput
  }

  export type ReportUncheckedCreateInput = {
    id?: string
    appointmentId: string
    reporterId: string
    targetUserId: string
    reason: string
    evidence?: string | null
    status?: $Enums.ReportStatus
    createdAt?: Date | string
  }

  export type ReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetUserId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneRequiredWithoutReportsNestedInput
    reporter?: UserUpdateOneRequiredWithoutReportsNestedInput
  }

  export type ReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: StringFieldUpdateOperationsInput | string
    reporterId?: StringFieldUpdateOperationsInput | string
    targetUserId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCreateManyInput = {
    id?: string
    appointmentId: string
    reporterId: string
    targetUserId: string
    reason: string
    evidence?: string | null
    status?: $Enums.ReportStatus
    createdAt?: Date | string
  }

  export type ReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetUserId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: StringFieldUpdateOperationsInput | string
    reporterId?: StringFieldUpdateOperationsInput | string
    targetUserId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SanctionCreateInput = {
    id?: string
    level: $Enums.SanctionLevel
    reason: string
    startAt?: Date | string
    endAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSanctionsInput
  }

  export type SanctionUncheckedCreateInput = {
    id?: string
    userId: string
    level: $Enums.SanctionLevel
    reason: string
    startAt?: Date | string
    endAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SanctionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumSanctionLevelFieldUpdateOperationsInput | $Enums.SanctionLevel
    reason?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSanctionsNestedInput
  }

  export type SanctionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    level?: EnumSanctionLevelFieldUpdateOperationsInput | $Enums.SanctionLevel
    reason?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SanctionCreateManyInput = {
    id?: string
    userId: string
    level: $Enums.SanctionLevel
    reason: string
    startAt?: Date | string
    endAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SanctionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumSanctionLevelFieldUpdateOperationsInput | $Enums.SanctionLevel
    reason?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SanctionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    level?: EnumSanctionLevelFieldUpdateOperationsInput | $Enums.SanctionLevel
    reason?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateInput = {
    id?: string
    comment: string
    scoreDelta?: number
    createdAt?: Date | string
    appointment: AppointmentCreateNestedOneWithoutReviewsInput
    reviewer: UserCreateNestedOneWithoutReviewsGivenInput
    reviewee: UserCreateNestedOneWithoutReviewsRecvInput
  }

  export type ReviewUncheckedCreateInput = {
    id?: string
    appointmentId: string
    reviewerId: string
    revieweeId: string
    comment: string
    scoreDelta?: number
    createdAt?: Date | string
  }

  export type ReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    scoreDelta?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneRequiredWithoutReviewsNestedInput
    reviewer?: UserUpdateOneRequiredWithoutReviewsGivenNestedInput
    reviewee?: UserUpdateOneRequiredWithoutReviewsRecvNestedInput
  }

  export type ReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: StringFieldUpdateOperationsInput | string
    reviewerId?: StringFieldUpdateOperationsInput | string
    revieweeId?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    scoreDelta?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateManyInput = {
    id?: string
    appointmentId: string
    reviewerId: string
    revieweeId: string
    comment: string
    scoreDelta?: number
    createdAt?: Date | string
  }

  export type ReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    scoreDelta?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: StringFieldUpdateOperationsInput | string
    reviewerId?: StringFieldUpdateOperationsInput | string
    revieweeId?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    scoreDelta?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserInterestListRelationFilter = {
    every?: UserInterestWhereInput
    some?: UserInterestWhereInput
    none?: UserInterestWhereInput
  }

  export type AvailabilitySlotListRelationFilter = {
    every?: AvailabilitySlotWhereInput
    some?: AvailabilitySlotWhereInput
    none?: AvailabilitySlotWhereInput
  }

  export type MatchProposalListRelationFilter = {
    every?: MatchProposalWhereInput
    some?: MatchProposalWhereInput
    none?: MatchProposalWhereInput
  }

  export type AppointmentListRelationFilter = {
    every?: AppointmentWhereInput
    some?: AppointmentWhereInput
    none?: AppointmentWhereInput
  }

  export type AttendanceCheckListRelationFilter = {
    every?: AttendanceCheckWhereInput
    some?: AttendanceCheckWhereInput
    none?: AttendanceCheckWhereInput
  }

  export type ReportListRelationFilter = {
    every?: ReportWhereInput
    some?: ReportWhereInput
    none?: ReportWhereInput
  }

  export type SanctionListRelationFilter = {
    every?: SanctionWhereInput
    some?: SanctionWhereInput
    none?: SanctionWhereInput
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserInterestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AvailabilitySlotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MatchProposalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AppointmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttendanceCheckOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SanctionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    provider?: SortOrder
    nickname?: SortOrder
    bio?: SortOrder
    region?: SortOrder
    trustScore?: SortOrder
    phoneVerified?: SortOrder
    blocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    trustScore?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    provider?: SortOrder
    nickname?: SortOrder
    bio?: SortOrder
    region?: SortOrder
    trustScore?: SortOrder
    phoneVerified?: SortOrder
    blocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    provider?: SortOrder
    nickname?: SortOrder
    bio?: SortOrder
    region?: SortOrder
    trustScore?: SortOrder
    phoneVerified?: SortOrder
    blocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    trustScore?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserInterestUserIdNameCompoundUniqueInput = {
    userId: string
    name: string
  }

  export type UserInterestCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
  }

  export type UserInterestMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
  }

  export type UserInterestMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
  }

  export type AvailabilitySlotCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    weekday?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    area?: SortOrder
    createdAt?: SortOrder
  }

  export type AvailabilitySlotAvgOrderByAggregateInput = {
    weekday?: SortOrder
  }

  export type AvailabilitySlotMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    weekday?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    area?: SortOrder
    createdAt?: SortOrder
  }

  export type AvailabilitySlotMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    weekday?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    area?: SortOrder
    createdAt?: SortOrder
  }

  export type AvailabilitySlotSumOrderByAggregateInput = {
    weekday?: SortOrder
  }

  export type EnumMatchStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchStatus | EnumMatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MatchStatus[]
    notIn?: $Enums.MatchStatus[]
    not?: NestedEnumMatchStatusFilter<$PrismaModel> | $Enums.MatchStatus
  }

  export type AppointmentNullableScalarRelationFilter = {
    is?: AppointmentWhereInput | null
    isNot?: AppointmentWhereInput | null
  }

  export type MatchProposalCountOrderByAggregateInput = {
    id?: SortOrder
    proposerId?: SortOrder
    partnerId?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type MatchProposalMaxOrderByAggregateInput = {
    id?: SortOrder
    proposerId?: SortOrder
    partnerId?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type MatchProposalMinOrderByAggregateInput = {
    id?: SortOrder
    proposerId?: SortOrder
    partnerId?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumMatchStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchStatus | EnumMatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MatchStatus[]
    notIn?: $Enums.MatchStatus[]
    not?: NestedEnumMatchStatusWithAggregatesFilter<$PrismaModel> | $Enums.MatchStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMatchStatusFilter<$PrismaModel>
    _max?: NestedEnumMatchStatusFilter<$PrismaModel>
  }

  export type EnumAppointmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[]
    notIn?: $Enums.AppointmentStatus[]
    not?: NestedEnumAppointmentStatusFilter<$PrismaModel> | $Enums.AppointmentStatus
  }

  export type MatchProposalScalarRelationFilter = {
    is?: MatchProposalWhereInput
    isNot?: MatchProposalWhereInput
  }

  export type AppointmentCountOrderByAggregateInput = {
    id?: SortOrder
    proposalId?: SortOrder
    userAId?: SortOrder
    userBId?: SortOrder
    place?: SortOrder
    startsAt?: SortOrder
    status?: SortOrder
    checkinCode?: SortOrder
    createdAt?: SortOrder
  }

  export type AppointmentMaxOrderByAggregateInput = {
    id?: SortOrder
    proposalId?: SortOrder
    userAId?: SortOrder
    userBId?: SortOrder
    place?: SortOrder
    startsAt?: SortOrder
    status?: SortOrder
    checkinCode?: SortOrder
    createdAt?: SortOrder
  }

  export type AppointmentMinOrderByAggregateInput = {
    id?: SortOrder
    proposalId?: SortOrder
    userAId?: SortOrder
    userBId?: SortOrder
    place?: SortOrder
    startsAt?: SortOrder
    status?: SortOrder
    checkinCode?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumAppointmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[]
    notIn?: $Enums.AppointmentStatus[]
    not?: NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AppointmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppointmentStatusFilter<$PrismaModel>
    _max?: NestedEnumAppointmentStatusFilter<$PrismaModel>
  }

  export type AppointmentScalarRelationFilter = {
    is?: AppointmentWhereInput
    isNot?: AppointmentWhereInput
  }

  export type AttendanceCheckAppointmentIdUserIdCompoundUniqueInput = {
    appointmentId: string
    userId: string
  }

  export type AttendanceCheckCountOrderByAggregateInput = {
    id?: SortOrder
    appointmentId?: SortOrder
    userId?: SortOrder
    method?: SortOrder
    checkedAt?: SortOrder
  }

  export type AttendanceCheckMaxOrderByAggregateInput = {
    id?: SortOrder
    appointmentId?: SortOrder
    userId?: SortOrder
    method?: SortOrder
    checkedAt?: SortOrder
  }

  export type AttendanceCheckMinOrderByAggregateInput = {
    id?: SortOrder
    appointmentId?: SortOrder
    userId?: SortOrder
    method?: SortOrder
    checkedAt?: SortOrder
  }

  export type EnumReportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[]
    notIn?: $Enums.ReportStatus[]
    not?: NestedEnumReportStatusFilter<$PrismaModel> | $Enums.ReportStatus
  }

  export type ReportCountOrderByAggregateInput = {
    id?: SortOrder
    appointmentId?: SortOrder
    reporterId?: SortOrder
    targetUserId?: SortOrder
    reason?: SortOrder
    evidence?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ReportMaxOrderByAggregateInput = {
    id?: SortOrder
    appointmentId?: SortOrder
    reporterId?: SortOrder
    targetUserId?: SortOrder
    reason?: SortOrder
    evidence?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ReportMinOrderByAggregateInput = {
    id?: SortOrder
    appointmentId?: SortOrder
    reporterId?: SortOrder
    targetUserId?: SortOrder
    reason?: SortOrder
    evidence?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumReportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[]
    notIn?: $Enums.ReportStatus[]
    not?: NestedEnumReportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportStatusFilter<$PrismaModel>
    _max?: NestedEnumReportStatusFilter<$PrismaModel>
  }

  export type EnumSanctionLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.SanctionLevel | EnumSanctionLevelFieldRefInput<$PrismaModel>
    in?: $Enums.SanctionLevel[]
    notIn?: $Enums.SanctionLevel[]
    not?: NestedEnumSanctionLevelFilter<$PrismaModel> | $Enums.SanctionLevel
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type SanctionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    level?: SortOrder
    reason?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SanctionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    level?: SortOrder
    reason?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SanctionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    level?: SortOrder
    reason?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumSanctionLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SanctionLevel | EnumSanctionLevelFieldRefInput<$PrismaModel>
    in?: $Enums.SanctionLevel[]
    notIn?: $Enums.SanctionLevel[]
    not?: NestedEnumSanctionLevelWithAggregatesFilter<$PrismaModel> | $Enums.SanctionLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSanctionLevelFilter<$PrismaModel>
    _max?: NestedEnumSanctionLevelFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type ReviewAppointmentIdReviewerIdCompoundUniqueInput = {
    appointmentId: string
    reviewerId: string
  }

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder
    appointmentId?: SortOrder
    reviewerId?: SortOrder
    revieweeId?: SortOrder
    comment?: SortOrder
    scoreDelta?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewAvgOrderByAggregateInput = {
    scoreDelta?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    appointmentId?: SortOrder
    reviewerId?: SortOrder
    revieweeId?: SortOrder
    comment?: SortOrder
    scoreDelta?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder
    appointmentId?: SortOrder
    reviewerId?: SortOrder
    revieweeId?: SortOrder
    comment?: SortOrder
    scoreDelta?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewSumOrderByAggregateInput = {
    scoreDelta?: SortOrder
  }

  export type UserInterestCreateNestedManyWithoutUserInput = {
    create?: XOR<UserInterestCreateWithoutUserInput, UserInterestUncheckedCreateWithoutUserInput> | UserInterestCreateWithoutUserInput[] | UserInterestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserInterestCreateOrConnectWithoutUserInput | UserInterestCreateOrConnectWithoutUserInput[]
    createMany?: UserInterestCreateManyUserInputEnvelope
    connect?: UserInterestWhereUniqueInput | UserInterestWhereUniqueInput[]
  }

  export type AvailabilitySlotCreateNestedManyWithoutUserInput = {
    create?: XOR<AvailabilitySlotCreateWithoutUserInput, AvailabilitySlotUncheckedCreateWithoutUserInput> | AvailabilitySlotCreateWithoutUserInput[] | AvailabilitySlotUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AvailabilitySlotCreateOrConnectWithoutUserInput | AvailabilitySlotCreateOrConnectWithoutUserInput[]
    createMany?: AvailabilitySlotCreateManyUserInputEnvelope
    connect?: AvailabilitySlotWhereUniqueInput | AvailabilitySlotWhereUniqueInput[]
  }

  export type MatchProposalCreateNestedManyWithoutProposerInput = {
    create?: XOR<MatchProposalCreateWithoutProposerInput, MatchProposalUncheckedCreateWithoutProposerInput> | MatchProposalCreateWithoutProposerInput[] | MatchProposalUncheckedCreateWithoutProposerInput[]
    connectOrCreate?: MatchProposalCreateOrConnectWithoutProposerInput | MatchProposalCreateOrConnectWithoutProposerInput[]
    createMany?: MatchProposalCreateManyProposerInputEnvelope
    connect?: MatchProposalWhereUniqueInput | MatchProposalWhereUniqueInput[]
  }

  export type MatchProposalCreateNestedManyWithoutPartnerInput = {
    create?: XOR<MatchProposalCreateWithoutPartnerInput, MatchProposalUncheckedCreateWithoutPartnerInput> | MatchProposalCreateWithoutPartnerInput[] | MatchProposalUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: MatchProposalCreateOrConnectWithoutPartnerInput | MatchProposalCreateOrConnectWithoutPartnerInput[]
    createMany?: MatchProposalCreateManyPartnerInputEnvelope
    connect?: MatchProposalWhereUniqueInput | MatchProposalWhereUniqueInput[]
  }

  export type AppointmentCreateNestedManyWithoutUserAInput = {
    create?: XOR<AppointmentCreateWithoutUserAInput, AppointmentUncheckedCreateWithoutUserAInput> | AppointmentCreateWithoutUserAInput[] | AppointmentUncheckedCreateWithoutUserAInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutUserAInput | AppointmentCreateOrConnectWithoutUserAInput[]
    createMany?: AppointmentCreateManyUserAInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type AppointmentCreateNestedManyWithoutUserBInput = {
    create?: XOR<AppointmentCreateWithoutUserBInput, AppointmentUncheckedCreateWithoutUserBInput> | AppointmentCreateWithoutUserBInput[] | AppointmentUncheckedCreateWithoutUserBInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutUserBInput | AppointmentCreateOrConnectWithoutUserBInput[]
    createMany?: AppointmentCreateManyUserBInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type AttendanceCheckCreateNestedManyWithoutUserInput = {
    create?: XOR<AttendanceCheckCreateWithoutUserInput, AttendanceCheckUncheckedCreateWithoutUserInput> | AttendanceCheckCreateWithoutUserInput[] | AttendanceCheckUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceCheckCreateOrConnectWithoutUserInput | AttendanceCheckCreateOrConnectWithoutUserInput[]
    createMany?: AttendanceCheckCreateManyUserInputEnvelope
    connect?: AttendanceCheckWhereUniqueInput | AttendanceCheckWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutReporterInput = {
    create?: XOR<ReportCreateWithoutReporterInput, ReportUncheckedCreateWithoutReporterInput> | ReportCreateWithoutReporterInput[] | ReportUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReporterInput | ReportCreateOrConnectWithoutReporterInput[]
    createMany?: ReportCreateManyReporterInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type SanctionCreateNestedManyWithoutUserInput = {
    create?: XOR<SanctionCreateWithoutUserInput, SanctionUncheckedCreateWithoutUserInput> | SanctionCreateWithoutUserInput[] | SanctionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SanctionCreateOrConnectWithoutUserInput | SanctionCreateOrConnectWithoutUserInput[]
    createMany?: SanctionCreateManyUserInputEnvelope
    connect?: SanctionWhereUniqueInput | SanctionWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutReviewerInput = {
    create?: XOR<ReviewCreateWithoutReviewerInput, ReviewUncheckedCreateWithoutReviewerInput> | ReviewCreateWithoutReviewerInput[] | ReviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutReviewerInput | ReviewCreateOrConnectWithoutReviewerInput[]
    createMany?: ReviewCreateManyReviewerInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutRevieweeInput = {
    create?: XOR<ReviewCreateWithoutRevieweeInput, ReviewUncheckedCreateWithoutRevieweeInput> | ReviewCreateWithoutRevieweeInput[] | ReviewUncheckedCreateWithoutRevieweeInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutRevieweeInput | ReviewCreateOrConnectWithoutRevieweeInput[]
    createMany?: ReviewCreateManyRevieweeInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type UserInterestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserInterestCreateWithoutUserInput, UserInterestUncheckedCreateWithoutUserInput> | UserInterestCreateWithoutUserInput[] | UserInterestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserInterestCreateOrConnectWithoutUserInput | UserInterestCreateOrConnectWithoutUserInput[]
    createMany?: UserInterestCreateManyUserInputEnvelope
    connect?: UserInterestWhereUniqueInput | UserInterestWhereUniqueInput[]
  }

  export type AvailabilitySlotUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AvailabilitySlotCreateWithoutUserInput, AvailabilitySlotUncheckedCreateWithoutUserInput> | AvailabilitySlotCreateWithoutUserInput[] | AvailabilitySlotUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AvailabilitySlotCreateOrConnectWithoutUserInput | AvailabilitySlotCreateOrConnectWithoutUserInput[]
    createMany?: AvailabilitySlotCreateManyUserInputEnvelope
    connect?: AvailabilitySlotWhereUniqueInput | AvailabilitySlotWhereUniqueInput[]
  }

  export type MatchProposalUncheckedCreateNestedManyWithoutProposerInput = {
    create?: XOR<MatchProposalCreateWithoutProposerInput, MatchProposalUncheckedCreateWithoutProposerInput> | MatchProposalCreateWithoutProposerInput[] | MatchProposalUncheckedCreateWithoutProposerInput[]
    connectOrCreate?: MatchProposalCreateOrConnectWithoutProposerInput | MatchProposalCreateOrConnectWithoutProposerInput[]
    createMany?: MatchProposalCreateManyProposerInputEnvelope
    connect?: MatchProposalWhereUniqueInput | MatchProposalWhereUniqueInput[]
  }

  export type MatchProposalUncheckedCreateNestedManyWithoutPartnerInput = {
    create?: XOR<MatchProposalCreateWithoutPartnerInput, MatchProposalUncheckedCreateWithoutPartnerInput> | MatchProposalCreateWithoutPartnerInput[] | MatchProposalUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: MatchProposalCreateOrConnectWithoutPartnerInput | MatchProposalCreateOrConnectWithoutPartnerInput[]
    createMany?: MatchProposalCreateManyPartnerInputEnvelope
    connect?: MatchProposalWhereUniqueInput | MatchProposalWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutUserAInput = {
    create?: XOR<AppointmentCreateWithoutUserAInput, AppointmentUncheckedCreateWithoutUserAInput> | AppointmentCreateWithoutUserAInput[] | AppointmentUncheckedCreateWithoutUserAInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutUserAInput | AppointmentCreateOrConnectWithoutUserAInput[]
    createMany?: AppointmentCreateManyUserAInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutUserBInput = {
    create?: XOR<AppointmentCreateWithoutUserBInput, AppointmentUncheckedCreateWithoutUserBInput> | AppointmentCreateWithoutUserBInput[] | AppointmentUncheckedCreateWithoutUserBInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutUserBInput | AppointmentCreateOrConnectWithoutUserBInput[]
    createMany?: AppointmentCreateManyUserBInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type AttendanceCheckUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AttendanceCheckCreateWithoutUserInput, AttendanceCheckUncheckedCreateWithoutUserInput> | AttendanceCheckCreateWithoutUserInput[] | AttendanceCheckUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceCheckCreateOrConnectWithoutUserInput | AttendanceCheckCreateOrConnectWithoutUserInput[]
    createMany?: AttendanceCheckCreateManyUserInputEnvelope
    connect?: AttendanceCheckWhereUniqueInput | AttendanceCheckWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutReporterInput = {
    create?: XOR<ReportCreateWithoutReporterInput, ReportUncheckedCreateWithoutReporterInput> | ReportCreateWithoutReporterInput[] | ReportUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReporterInput | ReportCreateOrConnectWithoutReporterInput[]
    createMany?: ReportCreateManyReporterInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type SanctionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SanctionCreateWithoutUserInput, SanctionUncheckedCreateWithoutUserInput> | SanctionCreateWithoutUserInput[] | SanctionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SanctionCreateOrConnectWithoutUserInput | SanctionCreateOrConnectWithoutUserInput[]
    createMany?: SanctionCreateManyUserInputEnvelope
    connect?: SanctionWhereUniqueInput | SanctionWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutReviewerInput = {
    create?: XOR<ReviewCreateWithoutReviewerInput, ReviewUncheckedCreateWithoutReviewerInput> | ReviewCreateWithoutReviewerInput[] | ReviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutReviewerInput | ReviewCreateOrConnectWithoutReviewerInput[]
    createMany?: ReviewCreateManyReviewerInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutRevieweeInput = {
    create?: XOR<ReviewCreateWithoutRevieweeInput, ReviewUncheckedCreateWithoutRevieweeInput> | ReviewCreateWithoutRevieweeInput[] | ReviewUncheckedCreateWithoutRevieweeInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutRevieweeInput | ReviewCreateOrConnectWithoutRevieweeInput[]
    createMany?: ReviewCreateManyRevieweeInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserInterestUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserInterestCreateWithoutUserInput, UserInterestUncheckedCreateWithoutUserInput> | UserInterestCreateWithoutUserInput[] | UserInterestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserInterestCreateOrConnectWithoutUserInput | UserInterestCreateOrConnectWithoutUserInput[]
    upsert?: UserInterestUpsertWithWhereUniqueWithoutUserInput | UserInterestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserInterestCreateManyUserInputEnvelope
    set?: UserInterestWhereUniqueInput | UserInterestWhereUniqueInput[]
    disconnect?: UserInterestWhereUniqueInput | UserInterestWhereUniqueInput[]
    delete?: UserInterestWhereUniqueInput | UserInterestWhereUniqueInput[]
    connect?: UserInterestWhereUniqueInput | UserInterestWhereUniqueInput[]
    update?: UserInterestUpdateWithWhereUniqueWithoutUserInput | UserInterestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserInterestUpdateManyWithWhereWithoutUserInput | UserInterestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserInterestScalarWhereInput | UserInterestScalarWhereInput[]
  }

  export type AvailabilitySlotUpdateManyWithoutUserNestedInput = {
    create?: XOR<AvailabilitySlotCreateWithoutUserInput, AvailabilitySlotUncheckedCreateWithoutUserInput> | AvailabilitySlotCreateWithoutUserInput[] | AvailabilitySlotUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AvailabilitySlotCreateOrConnectWithoutUserInput | AvailabilitySlotCreateOrConnectWithoutUserInput[]
    upsert?: AvailabilitySlotUpsertWithWhereUniqueWithoutUserInput | AvailabilitySlotUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AvailabilitySlotCreateManyUserInputEnvelope
    set?: AvailabilitySlotWhereUniqueInput | AvailabilitySlotWhereUniqueInput[]
    disconnect?: AvailabilitySlotWhereUniqueInput | AvailabilitySlotWhereUniqueInput[]
    delete?: AvailabilitySlotWhereUniqueInput | AvailabilitySlotWhereUniqueInput[]
    connect?: AvailabilitySlotWhereUniqueInput | AvailabilitySlotWhereUniqueInput[]
    update?: AvailabilitySlotUpdateWithWhereUniqueWithoutUserInput | AvailabilitySlotUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AvailabilitySlotUpdateManyWithWhereWithoutUserInput | AvailabilitySlotUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AvailabilitySlotScalarWhereInput | AvailabilitySlotScalarWhereInput[]
  }

  export type MatchProposalUpdateManyWithoutProposerNestedInput = {
    create?: XOR<MatchProposalCreateWithoutProposerInput, MatchProposalUncheckedCreateWithoutProposerInput> | MatchProposalCreateWithoutProposerInput[] | MatchProposalUncheckedCreateWithoutProposerInput[]
    connectOrCreate?: MatchProposalCreateOrConnectWithoutProposerInput | MatchProposalCreateOrConnectWithoutProposerInput[]
    upsert?: MatchProposalUpsertWithWhereUniqueWithoutProposerInput | MatchProposalUpsertWithWhereUniqueWithoutProposerInput[]
    createMany?: MatchProposalCreateManyProposerInputEnvelope
    set?: MatchProposalWhereUniqueInput | MatchProposalWhereUniqueInput[]
    disconnect?: MatchProposalWhereUniqueInput | MatchProposalWhereUniqueInput[]
    delete?: MatchProposalWhereUniqueInput | MatchProposalWhereUniqueInput[]
    connect?: MatchProposalWhereUniqueInput | MatchProposalWhereUniqueInput[]
    update?: MatchProposalUpdateWithWhereUniqueWithoutProposerInput | MatchProposalUpdateWithWhereUniqueWithoutProposerInput[]
    updateMany?: MatchProposalUpdateManyWithWhereWithoutProposerInput | MatchProposalUpdateManyWithWhereWithoutProposerInput[]
    deleteMany?: MatchProposalScalarWhereInput | MatchProposalScalarWhereInput[]
  }

  export type MatchProposalUpdateManyWithoutPartnerNestedInput = {
    create?: XOR<MatchProposalCreateWithoutPartnerInput, MatchProposalUncheckedCreateWithoutPartnerInput> | MatchProposalCreateWithoutPartnerInput[] | MatchProposalUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: MatchProposalCreateOrConnectWithoutPartnerInput | MatchProposalCreateOrConnectWithoutPartnerInput[]
    upsert?: MatchProposalUpsertWithWhereUniqueWithoutPartnerInput | MatchProposalUpsertWithWhereUniqueWithoutPartnerInput[]
    createMany?: MatchProposalCreateManyPartnerInputEnvelope
    set?: MatchProposalWhereUniqueInput | MatchProposalWhereUniqueInput[]
    disconnect?: MatchProposalWhereUniqueInput | MatchProposalWhereUniqueInput[]
    delete?: MatchProposalWhereUniqueInput | MatchProposalWhereUniqueInput[]
    connect?: MatchProposalWhereUniqueInput | MatchProposalWhereUniqueInput[]
    update?: MatchProposalUpdateWithWhereUniqueWithoutPartnerInput | MatchProposalUpdateWithWhereUniqueWithoutPartnerInput[]
    updateMany?: MatchProposalUpdateManyWithWhereWithoutPartnerInput | MatchProposalUpdateManyWithWhereWithoutPartnerInput[]
    deleteMany?: MatchProposalScalarWhereInput | MatchProposalScalarWhereInput[]
  }

  export type AppointmentUpdateManyWithoutUserANestedInput = {
    create?: XOR<AppointmentCreateWithoutUserAInput, AppointmentUncheckedCreateWithoutUserAInput> | AppointmentCreateWithoutUserAInput[] | AppointmentUncheckedCreateWithoutUserAInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutUserAInput | AppointmentCreateOrConnectWithoutUserAInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutUserAInput | AppointmentUpsertWithWhereUniqueWithoutUserAInput[]
    createMany?: AppointmentCreateManyUserAInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutUserAInput | AppointmentUpdateWithWhereUniqueWithoutUserAInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutUserAInput | AppointmentUpdateManyWithWhereWithoutUserAInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type AppointmentUpdateManyWithoutUserBNestedInput = {
    create?: XOR<AppointmentCreateWithoutUserBInput, AppointmentUncheckedCreateWithoutUserBInput> | AppointmentCreateWithoutUserBInput[] | AppointmentUncheckedCreateWithoutUserBInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutUserBInput | AppointmentCreateOrConnectWithoutUserBInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutUserBInput | AppointmentUpsertWithWhereUniqueWithoutUserBInput[]
    createMany?: AppointmentCreateManyUserBInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutUserBInput | AppointmentUpdateWithWhereUniqueWithoutUserBInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutUserBInput | AppointmentUpdateManyWithWhereWithoutUserBInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type AttendanceCheckUpdateManyWithoutUserNestedInput = {
    create?: XOR<AttendanceCheckCreateWithoutUserInput, AttendanceCheckUncheckedCreateWithoutUserInput> | AttendanceCheckCreateWithoutUserInput[] | AttendanceCheckUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceCheckCreateOrConnectWithoutUserInput | AttendanceCheckCreateOrConnectWithoutUserInput[]
    upsert?: AttendanceCheckUpsertWithWhereUniqueWithoutUserInput | AttendanceCheckUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AttendanceCheckCreateManyUserInputEnvelope
    set?: AttendanceCheckWhereUniqueInput | AttendanceCheckWhereUniqueInput[]
    disconnect?: AttendanceCheckWhereUniqueInput | AttendanceCheckWhereUniqueInput[]
    delete?: AttendanceCheckWhereUniqueInput | AttendanceCheckWhereUniqueInput[]
    connect?: AttendanceCheckWhereUniqueInput | AttendanceCheckWhereUniqueInput[]
    update?: AttendanceCheckUpdateWithWhereUniqueWithoutUserInput | AttendanceCheckUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AttendanceCheckUpdateManyWithWhereWithoutUserInput | AttendanceCheckUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AttendanceCheckScalarWhereInput | AttendanceCheckScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutReporterNestedInput = {
    create?: XOR<ReportCreateWithoutReporterInput, ReportUncheckedCreateWithoutReporterInput> | ReportCreateWithoutReporterInput[] | ReportUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReporterInput | ReportCreateOrConnectWithoutReporterInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutReporterInput | ReportUpsertWithWhereUniqueWithoutReporterInput[]
    createMany?: ReportCreateManyReporterInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutReporterInput | ReportUpdateWithWhereUniqueWithoutReporterInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutReporterInput | ReportUpdateManyWithWhereWithoutReporterInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type SanctionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SanctionCreateWithoutUserInput, SanctionUncheckedCreateWithoutUserInput> | SanctionCreateWithoutUserInput[] | SanctionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SanctionCreateOrConnectWithoutUserInput | SanctionCreateOrConnectWithoutUserInput[]
    upsert?: SanctionUpsertWithWhereUniqueWithoutUserInput | SanctionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SanctionCreateManyUserInputEnvelope
    set?: SanctionWhereUniqueInput | SanctionWhereUniqueInput[]
    disconnect?: SanctionWhereUniqueInput | SanctionWhereUniqueInput[]
    delete?: SanctionWhereUniqueInput | SanctionWhereUniqueInput[]
    connect?: SanctionWhereUniqueInput | SanctionWhereUniqueInput[]
    update?: SanctionUpdateWithWhereUniqueWithoutUserInput | SanctionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SanctionUpdateManyWithWhereWithoutUserInput | SanctionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SanctionScalarWhereInput | SanctionScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<ReviewCreateWithoutReviewerInput, ReviewUncheckedCreateWithoutReviewerInput> | ReviewCreateWithoutReviewerInput[] | ReviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutReviewerInput | ReviewCreateOrConnectWithoutReviewerInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutReviewerInput | ReviewUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: ReviewCreateManyReviewerInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutReviewerInput | ReviewUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutReviewerInput | ReviewUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutRevieweeNestedInput = {
    create?: XOR<ReviewCreateWithoutRevieweeInput, ReviewUncheckedCreateWithoutRevieweeInput> | ReviewCreateWithoutRevieweeInput[] | ReviewUncheckedCreateWithoutRevieweeInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutRevieweeInput | ReviewCreateOrConnectWithoutRevieweeInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutRevieweeInput | ReviewUpsertWithWhereUniqueWithoutRevieweeInput[]
    createMany?: ReviewCreateManyRevieweeInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutRevieweeInput | ReviewUpdateWithWhereUniqueWithoutRevieweeInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutRevieweeInput | ReviewUpdateManyWithWhereWithoutRevieweeInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type UserInterestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserInterestCreateWithoutUserInput, UserInterestUncheckedCreateWithoutUserInput> | UserInterestCreateWithoutUserInput[] | UserInterestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserInterestCreateOrConnectWithoutUserInput | UserInterestCreateOrConnectWithoutUserInput[]
    upsert?: UserInterestUpsertWithWhereUniqueWithoutUserInput | UserInterestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserInterestCreateManyUserInputEnvelope
    set?: UserInterestWhereUniqueInput | UserInterestWhereUniqueInput[]
    disconnect?: UserInterestWhereUniqueInput | UserInterestWhereUniqueInput[]
    delete?: UserInterestWhereUniqueInput | UserInterestWhereUniqueInput[]
    connect?: UserInterestWhereUniqueInput | UserInterestWhereUniqueInput[]
    update?: UserInterestUpdateWithWhereUniqueWithoutUserInput | UserInterestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserInterestUpdateManyWithWhereWithoutUserInput | UserInterestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserInterestScalarWhereInput | UserInterestScalarWhereInput[]
  }

  export type AvailabilitySlotUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AvailabilitySlotCreateWithoutUserInput, AvailabilitySlotUncheckedCreateWithoutUserInput> | AvailabilitySlotCreateWithoutUserInput[] | AvailabilitySlotUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AvailabilitySlotCreateOrConnectWithoutUserInput | AvailabilitySlotCreateOrConnectWithoutUserInput[]
    upsert?: AvailabilitySlotUpsertWithWhereUniqueWithoutUserInput | AvailabilitySlotUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AvailabilitySlotCreateManyUserInputEnvelope
    set?: AvailabilitySlotWhereUniqueInput | AvailabilitySlotWhereUniqueInput[]
    disconnect?: AvailabilitySlotWhereUniqueInput | AvailabilitySlotWhereUniqueInput[]
    delete?: AvailabilitySlotWhereUniqueInput | AvailabilitySlotWhereUniqueInput[]
    connect?: AvailabilitySlotWhereUniqueInput | AvailabilitySlotWhereUniqueInput[]
    update?: AvailabilitySlotUpdateWithWhereUniqueWithoutUserInput | AvailabilitySlotUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AvailabilitySlotUpdateManyWithWhereWithoutUserInput | AvailabilitySlotUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AvailabilitySlotScalarWhereInput | AvailabilitySlotScalarWhereInput[]
  }

  export type MatchProposalUncheckedUpdateManyWithoutProposerNestedInput = {
    create?: XOR<MatchProposalCreateWithoutProposerInput, MatchProposalUncheckedCreateWithoutProposerInput> | MatchProposalCreateWithoutProposerInput[] | MatchProposalUncheckedCreateWithoutProposerInput[]
    connectOrCreate?: MatchProposalCreateOrConnectWithoutProposerInput | MatchProposalCreateOrConnectWithoutProposerInput[]
    upsert?: MatchProposalUpsertWithWhereUniqueWithoutProposerInput | MatchProposalUpsertWithWhereUniqueWithoutProposerInput[]
    createMany?: MatchProposalCreateManyProposerInputEnvelope
    set?: MatchProposalWhereUniqueInput | MatchProposalWhereUniqueInput[]
    disconnect?: MatchProposalWhereUniqueInput | MatchProposalWhereUniqueInput[]
    delete?: MatchProposalWhereUniqueInput | MatchProposalWhereUniqueInput[]
    connect?: MatchProposalWhereUniqueInput | MatchProposalWhereUniqueInput[]
    update?: MatchProposalUpdateWithWhereUniqueWithoutProposerInput | MatchProposalUpdateWithWhereUniqueWithoutProposerInput[]
    updateMany?: MatchProposalUpdateManyWithWhereWithoutProposerInput | MatchProposalUpdateManyWithWhereWithoutProposerInput[]
    deleteMany?: MatchProposalScalarWhereInput | MatchProposalScalarWhereInput[]
  }

  export type MatchProposalUncheckedUpdateManyWithoutPartnerNestedInput = {
    create?: XOR<MatchProposalCreateWithoutPartnerInput, MatchProposalUncheckedCreateWithoutPartnerInput> | MatchProposalCreateWithoutPartnerInput[] | MatchProposalUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: MatchProposalCreateOrConnectWithoutPartnerInput | MatchProposalCreateOrConnectWithoutPartnerInput[]
    upsert?: MatchProposalUpsertWithWhereUniqueWithoutPartnerInput | MatchProposalUpsertWithWhereUniqueWithoutPartnerInput[]
    createMany?: MatchProposalCreateManyPartnerInputEnvelope
    set?: MatchProposalWhereUniqueInput | MatchProposalWhereUniqueInput[]
    disconnect?: MatchProposalWhereUniqueInput | MatchProposalWhereUniqueInput[]
    delete?: MatchProposalWhereUniqueInput | MatchProposalWhereUniqueInput[]
    connect?: MatchProposalWhereUniqueInput | MatchProposalWhereUniqueInput[]
    update?: MatchProposalUpdateWithWhereUniqueWithoutPartnerInput | MatchProposalUpdateWithWhereUniqueWithoutPartnerInput[]
    updateMany?: MatchProposalUpdateManyWithWhereWithoutPartnerInput | MatchProposalUpdateManyWithWhereWithoutPartnerInput[]
    deleteMany?: MatchProposalScalarWhereInput | MatchProposalScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutUserANestedInput = {
    create?: XOR<AppointmentCreateWithoutUserAInput, AppointmentUncheckedCreateWithoutUserAInput> | AppointmentCreateWithoutUserAInput[] | AppointmentUncheckedCreateWithoutUserAInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutUserAInput | AppointmentCreateOrConnectWithoutUserAInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutUserAInput | AppointmentUpsertWithWhereUniqueWithoutUserAInput[]
    createMany?: AppointmentCreateManyUserAInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutUserAInput | AppointmentUpdateWithWhereUniqueWithoutUserAInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutUserAInput | AppointmentUpdateManyWithWhereWithoutUserAInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutUserBNestedInput = {
    create?: XOR<AppointmentCreateWithoutUserBInput, AppointmentUncheckedCreateWithoutUserBInput> | AppointmentCreateWithoutUserBInput[] | AppointmentUncheckedCreateWithoutUserBInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutUserBInput | AppointmentCreateOrConnectWithoutUserBInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutUserBInput | AppointmentUpsertWithWhereUniqueWithoutUserBInput[]
    createMany?: AppointmentCreateManyUserBInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutUserBInput | AppointmentUpdateWithWhereUniqueWithoutUserBInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutUserBInput | AppointmentUpdateManyWithWhereWithoutUserBInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type AttendanceCheckUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AttendanceCheckCreateWithoutUserInput, AttendanceCheckUncheckedCreateWithoutUserInput> | AttendanceCheckCreateWithoutUserInput[] | AttendanceCheckUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceCheckCreateOrConnectWithoutUserInput | AttendanceCheckCreateOrConnectWithoutUserInput[]
    upsert?: AttendanceCheckUpsertWithWhereUniqueWithoutUserInput | AttendanceCheckUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AttendanceCheckCreateManyUserInputEnvelope
    set?: AttendanceCheckWhereUniqueInput | AttendanceCheckWhereUniqueInput[]
    disconnect?: AttendanceCheckWhereUniqueInput | AttendanceCheckWhereUniqueInput[]
    delete?: AttendanceCheckWhereUniqueInput | AttendanceCheckWhereUniqueInput[]
    connect?: AttendanceCheckWhereUniqueInput | AttendanceCheckWhereUniqueInput[]
    update?: AttendanceCheckUpdateWithWhereUniqueWithoutUserInput | AttendanceCheckUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AttendanceCheckUpdateManyWithWhereWithoutUserInput | AttendanceCheckUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AttendanceCheckScalarWhereInput | AttendanceCheckScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutReporterNestedInput = {
    create?: XOR<ReportCreateWithoutReporterInput, ReportUncheckedCreateWithoutReporterInput> | ReportCreateWithoutReporterInput[] | ReportUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReporterInput | ReportCreateOrConnectWithoutReporterInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutReporterInput | ReportUpsertWithWhereUniqueWithoutReporterInput[]
    createMany?: ReportCreateManyReporterInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutReporterInput | ReportUpdateWithWhereUniqueWithoutReporterInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutReporterInput | ReportUpdateManyWithWhereWithoutReporterInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type SanctionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SanctionCreateWithoutUserInput, SanctionUncheckedCreateWithoutUserInput> | SanctionCreateWithoutUserInput[] | SanctionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SanctionCreateOrConnectWithoutUserInput | SanctionCreateOrConnectWithoutUserInput[]
    upsert?: SanctionUpsertWithWhereUniqueWithoutUserInput | SanctionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SanctionCreateManyUserInputEnvelope
    set?: SanctionWhereUniqueInput | SanctionWhereUniqueInput[]
    disconnect?: SanctionWhereUniqueInput | SanctionWhereUniqueInput[]
    delete?: SanctionWhereUniqueInput | SanctionWhereUniqueInput[]
    connect?: SanctionWhereUniqueInput | SanctionWhereUniqueInput[]
    update?: SanctionUpdateWithWhereUniqueWithoutUserInput | SanctionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SanctionUpdateManyWithWhereWithoutUserInput | SanctionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SanctionScalarWhereInput | SanctionScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<ReviewCreateWithoutReviewerInput, ReviewUncheckedCreateWithoutReviewerInput> | ReviewCreateWithoutReviewerInput[] | ReviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutReviewerInput | ReviewCreateOrConnectWithoutReviewerInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutReviewerInput | ReviewUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: ReviewCreateManyReviewerInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutReviewerInput | ReviewUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutReviewerInput | ReviewUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutRevieweeNestedInput = {
    create?: XOR<ReviewCreateWithoutRevieweeInput, ReviewUncheckedCreateWithoutRevieweeInput> | ReviewCreateWithoutRevieweeInput[] | ReviewUncheckedCreateWithoutRevieweeInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutRevieweeInput | ReviewCreateOrConnectWithoutRevieweeInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutRevieweeInput | ReviewUpsertWithWhereUniqueWithoutRevieweeInput[]
    createMany?: ReviewCreateManyRevieweeInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutRevieweeInput | ReviewUpdateWithWhereUniqueWithoutRevieweeInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutRevieweeInput | ReviewUpdateManyWithWhereWithoutRevieweeInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutInterestsInput = {
    create?: XOR<UserCreateWithoutInterestsInput, UserUncheckedCreateWithoutInterestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInterestsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutInterestsNestedInput = {
    create?: XOR<UserCreateWithoutInterestsInput, UserUncheckedCreateWithoutInterestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInterestsInput
    upsert?: UserUpsertWithoutInterestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInterestsInput, UserUpdateWithoutInterestsInput>, UserUncheckedUpdateWithoutInterestsInput>
  }

  export type UserCreateNestedOneWithoutAvailabilityInput = {
    create?: XOR<UserCreateWithoutAvailabilityInput, UserUncheckedCreateWithoutAvailabilityInput>
    connectOrCreate?: UserCreateOrConnectWithoutAvailabilityInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAvailabilityNestedInput = {
    create?: XOR<UserCreateWithoutAvailabilityInput, UserUncheckedCreateWithoutAvailabilityInput>
    connectOrCreate?: UserCreateOrConnectWithoutAvailabilityInput
    upsert?: UserUpsertWithoutAvailabilityInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAvailabilityInput, UserUpdateWithoutAvailabilityInput>, UserUncheckedUpdateWithoutAvailabilityInput>
  }

  export type UserCreateNestedOneWithoutProposerInput = {
    create?: XOR<UserCreateWithoutProposerInput, UserUncheckedCreateWithoutProposerInput>
    connectOrCreate?: UserCreateOrConnectWithoutProposerInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPartnerInput = {
    create?: XOR<UserCreateWithoutPartnerInput, UserUncheckedCreateWithoutPartnerInput>
    connectOrCreate?: UserCreateOrConnectWithoutPartnerInput
    connect?: UserWhereUniqueInput
  }

  export type AppointmentCreateNestedOneWithoutProposalInput = {
    create?: XOR<AppointmentCreateWithoutProposalInput, AppointmentUncheckedCreateWithoutProposalInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutProposalInput
    connect?: AppointmentWhereUniqueInput
  }

  export type AppointmentUncheckedCreateNestedOneWithoutProposalInput = {
    create?: XOR<AppointmentCreateWithoutProposalInput, AppointmentUncheckedCreateWithoutProposalInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutProposalInput
    connect?: AppointmentWhereUniqueInput
  }

  export type EnumMatchStatusFieldUpdateOperationsInput = {
    set?: $Enums.MatchStatus
  }

  export type UserUpdateOneRequiredWithoutProposerNestedInput = {
    create?: XOR<UserCreateWithoutProposerInput, UserUncheckedCreateWithoutProposerInput>
    connectOrCreate?: UserCreateOrConnectWithoutProposerInput
    upsert?: UserUpsertWithoutProposerInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProposerInput, UserUpdateWithoutProposerInput>, UserUncheckedUpdateWithoutProposerInput>
  }

  export type UserUpdateOneRequiredWithoutPartnerNestedInput = {
    create?: XOR<UserCreateWithoutPartnerInput, UserUncheckedCreateWithoutPartnerInput>
    connectOrCreate?: UserCreateOrConnectWithoutPartnerInput
    upsert?: UserUpsertWithoutPartnerInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPartnerInput, UserUpdateWithoutPartnerInput>, UserUncheckedUpdateWithoutPartnerInput>
  }

  export type AppointmentUpdateOneWithoutProposalNestedInput = {
    create?: XOR<AppointmentCreateWithoutProposalInput, AppointmentUncheckedCreateWithoutProposalInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutProposalInput
    upsert?: AppointmentUpsertWithoutProposalInput
    disconnect?: AppointmentWhereInput | boolean
    delete?: AppointmentWhereInput | boolean
    connect?: AppointmentWhereUniqueInput
    update?: XOR<XOR<AppointmentUpdateToOneWithWhereWithoutProposalInput, AppointmentUpdateWithoutProposalInput>, AppointmentUncheckedUpdateWithoutProposalInput>
  }

  export type AppointmentUncheckedUpdateOneWithoutProposalNestedInput = {
    create?: XOR<AppointmentCreateWithoutProposalInput, AppointmentUncheckedCreateWithoutProposalInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutProposalInput
    upsert?: AppointmentUpsertWithoutProposalInput
    disconnect?: AppointmentWhereInput | boolean
    delete?: AppointmentWhereInput | boolean
    connect?: AppointmentWhereUniqueInput
    update?: XOR<XOR<AppointmentUpdateToOneWithWhereWithoutProposalInput, AppointmentUpdateWithoutProposalInput>, AppointmentUncheckedUpdateWithoutProposalInput>
  }

  export type MatchProposalCreateNestedOneWithoutAppointmentInput = {
    create?: XOR<MatchProposalCreateWithoutAppointmentInput, MatchProposalUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: MatchProposalCreateOrConnectWithoutAppointmentInput
    connect?: MatchProposalWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAppointmentsAInput = {
    create?: XOR<UserCreateWithoutAppointmentsAInput, UserUncheckedCreateWithoutAppointmentsAInput>
    connectOrCreate?: UserCreateOrConnectWithoutAppointmentsAInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAppointmentsBInput = {
    create?: XOR<UserCreateWithoutAppointmentsBInput, UserUncheckedCreateWithoutAppointmentsBInput>
    connectOrCreate?: UserCreateOrConnectWithoutAppointmentsBInput
    connect?: UserWhereUniqueInput
  }

  export type AttendanceCheckCreateNestedManyWithoutAppointmentInput = {
    create?: XOR<AttendanceCheckCreateWithoutAppointmentInput, AttendanceCheckUncheckedCreateWithoutAppointmentInput> | AttendanceCheckCreateWithoutAppointmentInput[] | AttendanceCheckUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: AttendanceCheckCreateOrConnectWithoutAppointmentInput | AttendanceCheckCreateOrConnectWithoutAppointmentInput[]
    createMany?: AttendanceCheckCreateManyAppointmentInputEnvelope
    connect?: AttendanceCheckWhereUniqueInput | AttendanceCheckWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutAppointmentInput = {
    create?: XOR<ReportCreateWithoutAppointmentInput, ReportUncheckedCreateWithoutAppointmentInput> | ReportCreateWithoutAppointmentInput[] | ReportUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutAppointmentInput | ReportCreateOrConnectWithoutAppointmentInput[]
    createMany?: ReportCreateManyAppointmentInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutAppointmentInput = {
    create?: XOR<ReviewCreateWithoutAppointmentInput, ReviewUncheckedCreateWithoutAppointmentInput> | ReviewCreateWithoutAppointmentInput[] | ReviewUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutAppointmentInput | ReviewCreateOrConnectWithoutAppointmentInput[]
    createMany?: ReviewCreateManyAppointmentInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type AttendanceCheckUncheckedCreateNestedManyWithoutAppointmentInput = {
    create?: XOR<AttendanceCheckCreateWithoutAppointmentInput, AttendanceCheckUncheckedCreateWithoutAppointmentInput> | AttendanceCheckCreateWithoutAppointmentInput[] | AttendanceCheckUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: AttendanceCheckCreateOrConnectWithoutAppointmentInput | AttendanceCheckCreateOrConnectWithoutAppointmentInput[]
    createMany?: AttendanceCheckCreateManyAppointmentInputEnvelope
    connect?: AttendanceCheckWhereUniqueInput | AttendanceCheckWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutAppointmentInput = {
    create?: XOR<ReportCreateWithoutAppointmentInput, ReportUncheckedCreateWithoutAppointmentInput> | ReportCreateWithoutAppointmentInput[] | ReportUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutAppointmentInput | ReportCreateOrConnectWithoutAppointmentInput[]
    createMany?: ReportCreateManyAppointmentInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutAppointmentInput = {
    create?: XOR<ReviewCreateWithoutAppointmentInput, ReviewUncheckedCreateWithoutAppointmentInput> | ReviewCreateWithoutAppointmentInput[] | ReviewUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutAppointmentInput | ReviewCreateOrConnectWithoutAppointmentInput[]
    createMany?: ReviewCreateManyAppointmentInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type EnumAppointmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.AppointmentStatus
  }

  export type MatchProposalUpdateOneRequiredWithoutAppointmentNestedInput = {
    create?: XOR<MatchProposalCreateWithoutAppointmentInput, MatchProposalUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: MatchProposalCreateOrConnectWithoutAppointmentInput
    upsert?: MatchProposalUpsertWithoutAppointmentInput
    connect?: MatchProposalWhereUniqueInput
    update?: XOR<XOR<MatchProposalUpdateToOneWithWhereWithoutAppointmentInput, MatchProposalUpdateWithoutAppointmentInput>, MatchProposalUncheckedUpdateWithoutAppointmentInput>
  }

  export type UserUpdateOneRequiredWithoutAppointmentsANestedInput = {
    create?: XOR<UserCreateWithoutAppointmentsAInput, UserUncheckedCreateWithoutAppointmentsAInput>
    connectOrCreate?: UserCreateOrConnectWithoutAppointmentsAInput
    upsert?: UserUpsertWithoutAppointmentsAInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAppointmentsAInput, UserUpdateWithoutAppointmentsAInput>, UserUncheckedUpdateWithoutAppointmentsAInput>
  }

  export type UserUpdateOneRequiredWithoutAppointmentsBNestedInput = {
    create?: XOR<UserCreateWithoutAppointmentsBInput, UserUncheckedCreateWithoutAppointmentsBInput>
    connectOrCreate?: UserCreateOrConnectWithoutAppointmentsBInput
    upsert?: UserUpsertWithoutAppointmentsBInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAppointmentsBInput, UserUpdateWithoutAppointmentsBInput>, UserUncheckedUpdateWithoutAppointmentsBInput>
  }

  export type AttendanceCheckUpdateManyWithoutAppointmentNestedInput = {
    create?: XOR<AttendanceCheckCreateWithoutAppointmentInput, AttendanceCheckUncheckedCreateWithoutAppointmentInput> | AttendanceCheckCreateWithoutAppointmentInput[] | AttendanceCheckUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: AttendanceCheckCreateOrConnectWithoutAppointmentInput | AttendanceCheckCreateOrConnectWithoutAppointmentInput[]
    upsert?: AttendanceCheckUpsertWithWhereUniqueWithoutAppointmentInput | AttendanceCheckUpsertWithWhereUniqueWithoutAppointmentInput[]
    createMany?: AttendanceCheckCreateManyAppointmentInputEnvelope
    set?: AttendanceCheckWhereUniqueInput | AttendanceCheckWhereUniqueInput[]
    disconnect?: AttendanceCheckWhereUniqueInput | AttendanceCheckWhereUniqueInput[]
    delete?: AttendanceCheckWhereUniqueInput | AttendanceCheckWhereUniqueInput[]
    connect?: AttendanceCheckWhereUniqueInput | AttendanceCheckWhereUniqueInput[]
    update?: AttendanceCheckUpdateWithWhereUniqueWithoutAppointmentInput | AttendanceCheckUpdateWithWhereUniqueWithoutAppointmentInput[]
    updateMany?: AttendanceCheckUpdateManyWithWhereWithoutAppointmentInput | AttendanceCheckUpdateManyWithWhereWithoutAppointmentInput[]
    deleteMany?: AttendanceCheckScalarWhereInput | AttendanceCheckScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutAppointmentNestedInput = {
    create?: XOR<ReportCreateWithoutAppointmentInput, ReportUncheckedCreateWithoutAppointmentInput> | ReportCreateWithoutAppointmentInput[] | ReportUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutAppointmentInput | ReportCreateOrConnectWithoutAppointmentInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutAppointmentInput | ReportUpsertWithWhereUniqueWithoutAppointmentInput[]
    createMany?: ReportCreateManyAppointmentInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutAppointmentInput | ReportUpdateWithWhereUniqueWithoutAppointmentInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutAppointmentInput | ReportUpdateManyWithWhereWithoutAppointmentInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutAppointmentNestedInput = {
    create?: XOR<ReviewCreateWithoutAppointmentInput, ReviewUncheckedCreateWithoutAppointmentInput> | ReviewCreateWithoutAppointmentInput[] | ReviewUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutAppointmentInput | ReviewCreateOrConnectWithoutAppointmentInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutAppointmentInput | ReviewUpsertWithWhereUniqueWithoutAppointmentInput[]
    createMany?: ReviewCreateManyAppointmentInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutAppointmentInput | ReviewUpdateWithWhereUniqueWithoutAppointmentInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutAppointmentInput | ReviewUpdateManyWithWhereWithoutAppointmentInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type AttendanceCheckUncheckedUpdateManyWithoutAppointmentNestedInput = {
    create?: XOR<AttendanceCheckCreateWithoutAppointmentInput, AttendanceCheckUncheckedCreateWithoutAppointmentInput> | AttendanceCheckCreateWithoutAppointmentInput[] | AttendanceCheckUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: AttendanceCheckCreateOrConnectWithoutAppointmentInput | AttendanceCheckCreateOrConnectWithoutAppointmentInput[]
    upsert?: AttendanceCheckUpsertWithWhereUniqueWithoutAppointmentInput | AttendanceCheckUpsertWithWhereUniqueWithoutAppointmentInput[]
    createMany?: AttendanceCheckCreateManyAppointmentInputEnvelope
    set?: AttendanceCheckWhereUniqueInput | AttendanceCheckWhereUniqueInput[]
    disconnect?: AttendanceCheckWhereUniqueInput | AttendanceCheckWhereUniqueInput[]
    delete?: AttendanceCheckWhereUniqueInput | AttendanceCheckWhereUniqueInput[]
    connect?: AttendanceCheckWhereUniqueInput | AttendanceCheckWhereUniqueInput[]
    update?: AttendanceCheckUpdateWithWhereUniqueWithoutAppointmentInput | AttendanceCheckUpdateWithWhereUniqueWithoutAppointmentInput[]
    updateMany?: AttendanceCheckUpdateManyWithWhereWithoutAppointmentInput | AttendanceCheckUpdateManyWithWhereWithoutAppointmentInput[]
    deleteMany?: AttendanceCheckScalarWhereInput | AttendanceCheckScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutAppointmentNestedInput = {
    create?: XOR<ReportCreateWithoutAppointmentInput, ReportUncheckedCreateWithoutAppointmentInput> | ReportCreateWithoutAppointmentInput[] | ReportUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutAppointmentInput | ReportCreateOrConnectWithoutAppointmentInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutAppointmentInput | ReportUpsertWithWhereUniqueWithoutAppointmentInput[]
    createMany?: ReportCreateManyAppointmentInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutAppointmentInput | ReportUpdateWithWhereUniqueWithoutAppointmentInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutAppointmentInput | ReportUpdateManyWithWhereWithoutAppointmentInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutAppointmentNestedInput = {
    create?: XOR<ReviewCreateWithoutAppointmentInput, ReviewUncheckedCreateWithoutAppointmentInput> | ReviewCreateWithoutAppointmentInput[] | ReviewUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutAppointmentInput | ReviewCreateOrConnectWithoutAppointmentInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutAppointmentInput | ReviewUpsertWithWhereUniqueWithoutAppointmentInput[]
    createMany?: ReviewCreateManyAppointmentInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutAppointmentInput | ReviewUpdateWithWhereUniqueWithoutAppointmentInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutAppointmentInput | ReviewUpdateManyWithWhereWithoutAppointmentInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type AppointmentCreateNestedOneWithoutChecksInput = {
    create?: XOR<AppointmentCreateWithoutChecksInput, AppointmentUncheckedCreateWithoutChecksInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutChecksInput
    connect?: AppointmentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutChecksInput = {
    create?: XOR<UserCreateWithoutChecksInput, UserUncheckedCreateWithoutChecksInput>
    connectOrCreate?: UserCreateOrConnectWithoutChecksInput
    connect?: UserWhereUniqueInput
  }

  export type AppointmentUpdateOneRequiredWithoutChecksNestedInput = {
    create?: XOR<AppointmentCreateWithoutChecksInput, AppointmentUncheckedCreateWithoutChecksInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutChecksInput
    upsert?: AppointmentUpsertWithoutChecksInput
    connect?: AppointmentWhereUniqueInput
    update?: XOR<XOR<AppointmentUpdateToOneWithWhereWithoutChecksInput, AppointmentUpdateWithoutChecksInput>, AppointmentUncheckedUpdateWithoutChecksInput>
  }

  export type UserUpdateOneRequiredWithoutChecksNestedInput = {
    create?: XOR<UserCreateWithoutChecksInput, UserUncheckedCreateWithoutChecksInput>
    connectOrCreate?: UserCreateOrConnectWithoutChecksInput
    upsert?: UserUpsertWithoutChecksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChecksInput, UserUpdateWithoutChecksInput>, UserUncheckedUpdateWithoutChecksInput>
  }

  export type AppointmentCreateNestedOneWithoutReportsInput = {
    create?: XOR<AppointmentCreateWithoutReportsInput, AppointmentUncheckedCreateWithoutReportsInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutReportsInput
    connect?: AppointmentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReportsInput = {
    create?: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumReportStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReportStatus
  }

  export type AppointmentUpdateOneRequiredWithoutReportsNestedInput = {
    create?: XOR<AppointmentCreateWithoutReportsInput, AppointmentUncheckedCreateWithoutReportsInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutReportsInput
    upsert?: AppointmentUpsertWithoutReportsInput
    connect?: AppointmentWhereUniqueInput
    update?: XOR<XOR<AppointmentUpdateToOneWithWhereWithoutReportsInput, AppointmentUpdateWithoutReportsInput>, AppointmentUncheckedUpdateWithoutReportsInput>
  }

  export type UserUpdateOneRequiredWithoutReportsNestedInput = {
    create?: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportsInput
    upsert?: UserUpsertWithoutReportsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReportsInput, UserUpdateWithoutReportsInput>, UserUncheckedUpdateWithoutReportsInput>
  }

  export type UserCreateNestedOneWithoutSanctionsInput = {
    create?: XOR<UserCreateWithoutSanctionsInput, UserUncheckedCreateWithoutSanctionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSanctionsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumSanctionLevelFieldUpdateOperationsInput = {
    set?: $Enums.SanctionLevel
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutSanctionsNestedInput = {
    create?: XOR<UserCreateWithoutSanctionsInput, UserUncheckedCreateWithoutSanctionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSanctionsInput
    upsert?: UserUpsertWithoutSanctionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSanctionsInput, UserUpdateWithoutSanctionsInput>, UserUncheckedUpdateWithoutSanctionsInput>
  }

  export type AppointmentCreateNestedOneWithoutReviewsInput = {
    create?: XOR<AppointmentCreateWithoutReviewsInput, AppointmentUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutReviewsInput
    connect?: AppointmentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReviewsGivenInput = {
    create?: XOR<UserCreateWithoutReviewsGivenInput, UserUncheckedCreateWithoutReviewsGivenInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsGivenInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReviewsRecvInput = {
    create?: XOR<UserCreateWithoutReviewsRecvInput, UserUncheckedCreateWithoutReviewsRecvInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsRecvInput
    connect?: UserWhereUniqueInput
  }

  export type AppointmentUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<AppointmentCreateWithoutReviewsInput, AppointmentUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutReviewsInput
    upsert?: AppointmentUpsertWithoutReviewsInput
    connect?: AppointmentWhereUniqueInput
    update?: XOR<XOR<AppointmentUpdateToOneWithWhereWithoutReviewsInput, AppointmentUpdateWithoutReviewsInput>, AppointmentUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateOneRequiredWithoutReviewsGivenNestedInput = {
    create?: XOR<UserCreateWithoutReviewsGivenInput, UserUncheckedCreateWithoutReviewsGivenInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsGivenInput
    upsert?: UserUpsertWithoutReviewsGivenInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewsGivenInput, UserUpdateWithoutReviewsGivenInput>, UserUncheckedUpdateWithoutReviewsGivenInput>
  }

  export type UserUpdateOneRequiredWithoutReviewsRecvNestedInput = {
    create?: XOR<UserCreateWithoutReviewsRecvInput, UserUncheckedCreateWithoutReviewsRecvInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsRecvInput
    upsert?: UserUpsertWithoutReviewsRecvInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewsRecvInput, UserUpdateWithoutReviewsRecvInput>, UserUncheckedUpdateWithoutReviewsRecvInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumMatchStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchStatus | EnumMatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MatchStatus[]
    notIn?: $Enums.MatchStatus[]
    not?: NestedEnumMatchStatusFilter<$PrismaModel> | $Enums.MatchStatus
  }

  export type NestedEnumMatchStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchStatus | EnumMatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MatchStatus[]
    notIn?: $Enums.MatchStatus[]
    not?: NestedEnumMatchStatusWithAggregatesFilter<$PrismaModel> | $Enums.MatchStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMatchStatusFilter<$PrismaModel>
    _max?: NestedEnumMatchStatusFilter<$PrismaModel>
  }

  export type NestedEnumAppointmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[]
    notIn?: $Enums.AppointmentStatus[]
    not?: NestedEnumAppointmentStatusFilter<$PrismaModel> | $Enums.AppointmentStatus
  }

  export type NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[]
    notIn?: $Enums.AppointmentStatus[]
    not?: NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AppointmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppointmentStatusFilter<$PrismaModel>
    _max?: NestedEnumAppointmentStatusFilter<$PrismaModel>
  }

  export type NestedEnumReportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[]
    notIn?: $Enums.ReportStatus[]
    not?: NestedEnumReportStatusFilter<$PrismaModel> | $Enums.ReportStatus
  }

  export type NestedEnumReportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[]
    notIn?: $Enums.ReportStatus[]
    not?: NestedEnumReportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportStatusFilter<$PrismaModel>
    _max?: NestedEnumReportStatusFilter<$PrismaModel>
  }

  export type NestedEnumSanctionLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.SanctionLevel | EnumSanctionLevelFieldRefInput<$PrismaModel>
    in?: $Enums.SanctionLevel[]
    notIn?: $Enums.SanctionLevel[]
    not?: NestedEnumSanctionLevelFilter<$PrismaModel> | $Enums.SanctionLevel
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumSanctionLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SanctionLevel | EnumSanctionLevelFieldRefInput<$PrismaModel>
    in?: $Enums.SanctionLevel[]
    notIn?: $Enums.SanctionLevel[]
    not?: NestedEnumSanctionLevelWithAggregatesFilter<$PrismaModel> | $Enums.SanctionLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSanctionLevelFilter<$PrismaModel>
    _max?: NestedEnumSanctionLevelFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type UserInterestCreateWithoutUserInput = {
    id?: string
    name: string
  }

  export type UserInterestUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
  }

  export type UserInterestCreateOrConnectWithoutUserInput = {
    where: UserInterestWhereUniqueInput
    create: XOR<UserInterestCreateWithoutUserInput, UserInterestUncheckedCreateWithoutUserInput>
  }

  export type UserInterestCreateManyUserInputEnvelope = {
    data: UserInterestCreateManyUserInput | UserInterestCreateManyUserInput[]
  }

  export type AvailabilitySlotCreateWithoutUserInput = {
    id?: string
    weekday: number
    startTime: string
    endTime: string
    area: string
    createdAt?: Date | string
  }

  export type AvailabilitySlotUncheckedCreateWithoutUserInput = {
    id?: string
    weekday: number
    startTime: string
    endTime: string
    area: string
    createdAt?: Date | string
  }

  export type AvailabilitySlotCreateOrConnectWithoutUserInput = {
    where: AvailabilitySlotWhereUniqueInput
    create: XOR<AvailabilitySlotCreateWithoutUserInput, AvailabilitySlotUncheckedCreateWithoutUserInput>
  }

  export type AvailabilitySlotCreateManyUserInputEnvelope = {
    data: AvailabilitySlotCreateManyUserInput | AvailabilitySlotCreateManyUserInput[]
  }

  export type MatchProposalCreateWithoutProposerInput = {
    id?: string
    message?: string | null
    status?: $Enums.MatchStatus
    createdAt?: Date | string
    partner: UserCreateNestedOneWithoutPartnerInput
    appointment?: AppointmentCreateNestedOneWithoutProposalInput
  }

  export type MatchProposalUncheckedCreateWithoutProposerInput = {
    id?: string
    partnerId: string
    message?: string | null
    status?: $Enums.MatchStatus
    createdAt?: Date | string
    appointment?: AppointmentUncheckedCreateNestedOneWithoutProposalInput
  }

  export type MatchProposalCreateOrConnectWithoutProposerInput = {
    where: MatchProposalWhereUniqueInput
    create: XOR<MatchProposalCreateWithoutProposerInput, MatchProposalUncheckedCreateWithoutProposerInput>
  }

  export type MatchProposalCreateManyProposerInputEnvelope = {
    data: MatchProposalCreateManyProposerInput | MatchProposalCreateManyProposerInput[]
  }

  export type MatchProposalCreateWithoutPartnerInput = {
    id?: string
    message?: string | null
    status?: $Enums.MatchStatus
    createdAt?: Date | string
    proposer: UserCreateNestedOneWithoutProposerInput
    appointment?: AppointmentCreateNestedOneWithoutProposalInput
  }

  export type MatchProposalUncheckedCreateWithoutPartnerInput = {
    id?: string
    proposerId: string
    message?: string | null
    status?: $Enums.MatchStatus
    createdAt?: Date | string
    appointment?: AppointmentUncheckedCreateNestedOneWithoutProposalInput
  }

  export type MatchProposalCreateOrConnectWithoutPartnerInput = {
    where: MatchProposalWhereUniqueInput
    create: XOR<MatchProposalCreateWithoutPartnerInput, MatchProposalUncheckedCreateWithoutPartnerInput>
  }

  export type MatchProposalCreateManyPartnerInputEnvelope = {
    data: MatchProposalCreateManyPartnerInput | MatchProposalCreateManyPartnerInput[]
  }

  export type AppointmentCreateWithoutUserAInput = {
    id?: string
    place: string
    startsAt: Date | string
    status?: $Enums.AppointmentStatus
    checkinCode: string
    createdAt?: Date | string
    proposal: MatchProposalCreateNestedOneWithoutAppointmentInput
    userB: UserCreateNestedOneWithoutAppointmentsBInput
    checks?: AttendanceCheckCreateNestedManyWithoutAppointmentInput
    reports?: ReportCreateNestedManyWithoutAppointmentInput
    reviews?: ReviewCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutUserAInput = {
    id?: string
    proposalId: string
    userBId: string
    place: string
    startsAt: Date | string
    status?: $Enums.AppointmentStatus
    checkinCode: string
    createdAt?: Date | string
    checks?: AttendanceCheckUncheckedCreateNestedManyWithoutAppointmentInput
    reports?: ReportUncheckedCreateNestedManyWithoutAppointmentInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutUserAInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutUserAInput, AppointmentUncheckedCreateWithoutUserAInput>
  }

  export type AppointmentCreateManyUserAInputEnvelope = {
    data: AppointmentCreateManyUserAInput | AppointmentCreateManyUserAInput[]
  }

  export type AppointmentCreateWithoutUserBInput = {
    id?: string
    place: string
    startsAt: Date | string
    status?: $Enums.AppointmentStatus
    checkinCode: string
    createdAt?: Date | string
    proposal: MatchProposalCreateNestedOneWithoutAppointmentInput
    userA: UserCreateNestedOneWithoutAppointmentsAInput
    checks?: AttendanceCheckCreateNestedManyWithoutAppointmentInput
    reports?: ReportCreateNestedManyWithoutAppointmentInput
    reviews?: ReviewCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutUserBInput = {
    id?: string
    proposalId: string
    userAId: string
    place: string
    startsAt: Date | string
    status?: $Enums.AppointmentStatus
    checkinCode: string
    createdAt?: Date | string
    checks?: AttendanceCheckUncheckedCreateNestedManyWithoutAppointmentInput
    reports?: ReportUncheckedCreateNestedManyWithoutAppointmentInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutUserBInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutUserBInput, AppointmentUncheckedCreateWithoutUserBInput>
  }

  export type AppointmentCreateManyUserBInputEnvelope = {
    data: AppointmentCreateManyUserBInput | AppointmentCreateManyUserBInput[]
  }

  export type AttendanceCheckCreateWithoutUserInput = {
    id?: string
    method: string
    checkedAt?: Date | string
    appointment: AppointmentCreateNestedOneWithoutChecksInput
  }

  export type AttendanceCheckUncheckedCreateWithoutUserInput = {
    id?: string
    appointmentId: string
    method: string
    checkedAt?: Date | string
  }

  export type AttendanceCheckCreateOrConnectWithoutUserInput = {
    where: AttendanceCheckWhereUniqueInput
    create: XOR<AttendanceCheckCreateWithoutUserInput, AttendanceCheckUncheckedCreateWithoutUserInput>
  }

  export type AttendanceCheckCreateManyUserInputEnvelope = {
    data: AttendanceCheckCreateManyUserInput | AttendanceCheckCreateManyUserInput[]
  }

  export type ReportCreateWithoutReporterInput = {
    id?: string
    targetUserId: string
    reason: string
    evidence?: string | null
    status?: $Enums.ReportStatus
    createdAt?: Date | string
    appointment: AppointmentCreateNestedOneWithoutReportsInput
  }

  export type ReportUncheckedCreateWithoutReporterInput = {
    id?: string
    appointmentId: string
    targetUserId: string
    reason: string
    evidence?: string | null
    status?: $Enums.ReportStatus
    createdAt?: Date | string
  }

  export type ReportCreateOrConnectWithoutReporterInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutReporterInput, ReportUncheckedCreateWithoutReporterInput>
  }

  export type ReportCreateManyReporterInputEnvelope = {
    data: ReportCreateManyReporterInput | ReportCreateManyReporterInput[]
  }

  export type SanctionCreateWithoutUserInput = {
    id?: string
    level: $Enums.SanctionLevel
    reason: string
    startAt?: Date | string
    endAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SanctionUncheckedCreateWithoutUserInput = {
    id?: string
    level: $Enums.SanctionLevel
    reason: string
    startAt?: Date | string
    endAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SanctionCreateOrConnectWithoutUserInput = {
    where: SanctionWhereUniqueInput
    create: XOR<SanctionCreateWithoutUserInput, SanctionUncheckedCreateWithoutUserInput>
  }

  export type SanctionCreateManyUserInputEnvelope = {
    data: SanctionCreateManyUserInput | SanctionCreateManyUserInput[]
  }

  export type ReviewCreateWithoutReviewerInput = {
    id?: string
    comment: string
    scoreDelta?: number
    createdAt?: Date | string
    appointment: AppointmentCreateNestedOneWithoutReviewsInput
    reviewee: UserCreateNestedOneWithoutReviewsRecvInput
  }

  export type ReviewUncheckedCreateWithoutReviewerInput = {
    id?: string
    appointmentId: string
    revieweeId: string
    comment: string
    scoreDelta?: number
    createdAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutReviewerInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutReviewerInput, ReviewUncheckedCreateWithoutReviewerInput>
  }

  export type ReviewCreateManyReviewerInputEnvelope = {
    data: ReviewCreateManyReviewerInput | ReviewCreateManyReviewerInput[]
  }

  export type ReviewCreateWithoutRevieweeInput = {
    id?: string
    comment: string
    scoreDelta?: number
    createdAt?: Date | string
    appointment: AppointmentCreateNestedOneWithoutReviewsInput
    reviewer: UserCreateNestedOneWithoutReviewsGivenInput
  }

  export type ReviewUncheckedCreateWithoutRevieweeInput = {
    id?: string
    appointmentId: string
    reviewerId: string
    comment: string
    scoreDelta?: number
    createdAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutRevieweeInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutRevieweeInput, ReviewUncheckedCreateWithoutRevieweeInput>
  }

  export type ReviewCreateManyRevieweeInputEnvelope = {
    data: ReviewCreateManyRevieweeInput | ReviewCreateManyRevieweeInput[]
  }

  export type UserInterestUpsertWithWhereUniqueWithoutUserInput = {
    where: UserInterestWhereUniqueInput
    update: XOR<UserInterestUpdateWithoutUserInput, UserInterestUncheckedUpdateWithoutUserInput>
    create: XOR<UserInterestCreateWithoutUserInput, UserInterestUncheckedCreateWithoutUserInput>
  }

  export type UserInterestUpdateWithWhereUniqueWithoutUserInput = {
    where: UserInterestWhereUniqueInput
    data: XOR<UserInterestUpdateWithoutUserInput, UserInterestUncheckedUpdateWithoutUserInput>
  }

  export type UserInterestUpdateManyWithWhereWithoutUserInput = {
    where: UserInterestScalarWhereInput
    data: XOR<UserInterestUpdateManyMutationInput, UserInterestUncheckedUpdateManyWithoutUserInput>
  }

  export type UserInterestScalarWhereInput = {
    AND?: UserInterestScalarWhereInput | UserInterestScalarWhereInput[]
    OR?: UserInterestScalarWhereInput[]
    NOT?: UserInterestScalarWhereInput | UserInterestScalarWhereInput[]
    id?: StringFilter<"UserInterest"> | string
    userId?: StringFilter<"UserInterest"> | string
    name?: StringFilter<"UserInterest"> | string
  }

  export type AvailabilitySlotUpsertWithWhereUniqueWithoutUserInput = {
    where: AvailabilitySlotWhereUniqueInput
    update: XOR<AvailabilitySlotUpdateWithoutUserInput, AvailabilitySlotUncheckedUpdateWithoutUserInput>
    create: XOR<AvailabilitySlotCreateWithoutUserInput, AvailabilitySlotUncheckedCreateWithoutUserInput>
  }

  export type AvailabilitySlotUpdateWithWhereUniqueWithoutUserInput = {
    where: AvailabilitySlotWhereUniqueInput
    data: XOR<AvailabilitySlotUpdateWithoutUserInput, AvailabilitySlotUncheckedUpdateWithoutUserInput>
  }

  export type AvailabilitySlotUpdateManyWithWhereWithoutUserInput = {
    where: AvailabilitySlotScalarWhereInput
    data: XOR<AvailabilitySlotUpdateManyMutationInput, AvailabilitySlotUncheckedUpdateManyWithoutUserInput>
  }

  export type AvailabilitySlotScalarWhereInput = {
    AND?: AvailabilitySlotScalarWhereInput | AvailabilitySlotScalarWhereInput[]
    OR?: AvailabilitySlotScalarWhereInput[]
    NOT?: AvailabilitySlotScalarWhereInput | AvailabilitySlotScalarWhereInput[]
    id?: StringFilter<"AvailabilitySlot"> | string
    userId?: StringFilter<"AvailabilitySlot"> | string
    weekday?: IntFilter<"AvailabilitySlot"> | number
    startTime?: StringFilter<"AvailabilitySlot"> | string
    endTime?: StringFilter<"AvailabilitySlot"> | string
    area?: StringFilter<"AvailabilitySlot"> | string
    createdAt?: DateTimeFilter<"AvailabilitySlot"> | Date | string
  }

  export type MatchProposalUpsertWithWhereUniqueWithoutProposerInput = {
    where: MatchProposalWhereUniqueInput
    update: XOR<MatchProposalUpdateWithoutProposerInput, MatchProposalUncheckedUpdateWithoutProposerInput>
    create: XOR<MatchProposalCreateWithoutProposerInput, MatchProposalUncheckedCreateWithoutProposerInput>
  }

  export type MatchProposalUpdateWithWhereUniqueWithoutProposerInput = {
    where: MatchProposalWhereUniqueInput
    data: XOR<MatchProposalUpdateWithoutProposerInput, MatchProposalUncheckedUpdateWithoutProposerInput>
  }

  export type MatchProposalUpdateManyWithWhereWithoutProposerInput = {
    where: MatchProposalScalarWhereInput
    data: XOR<MatchProposalUpdateManyMutationInput, MatchProposalUncheckedUpdateManyWithoutProposerInput>
  }

  export type MatchProposalScalarWhereInput = {
    AND?: MatchProposalScalarWhereInput | MatchProposalScalarWhereInput[]
    OR?: MatchProposalScalarWhereInput[]
    NOT?: MatchProposalScalarWhereInput | MatchProposalScalarWhereInput[]
    id?: StringFilter<"MatchProposal"> | string
    proposerId?: StringFilter<"MatchProposal"> | string
    partnerId?: StringFilter<"MatchProposal"> | string
    message?: StringNullableFilter<"MatchProposal"> | string | null
    status?: EnumMatchStatusFilter<"MatchProposal"> | $Enums.MatchStatus
    createdAt?: DateTimeFilter<"MatchProposal"> | Date | string
  }

  export type MatchProposalUpsertWithWhereUniqueWithoutPartnerInput = {
    where: MatchProposalWhereUniqueInput
    update: XOR<MatchProposalUpdateWithoutPartnerInput, MatchProposalUncheckedUpdateWithoutPartnerInput>
    create: XOR<MatchProposalCreateWithoutPartnerInput, MatchProposalUncheckedCreateWithoutPartnerInput>
  }

  export type MatchProposalUpdateWithWhereUniqueWithoutPartnerInput = {
    where: MatchProposalWhereUniqueInput
    data: XOR<MatchProposalUpdateWithoutPartnerInput, MatchProposalUncheckedUpdateWithoutPartnerInput>
  }

  export type MatchProposalUpdateManyWithWhereWithoutPartnerInput = {
    where: MatchProposalScalarWhereInput
    data: XOR<MatchProposalUpdateManyMutationInput, MatchProposalUncheckedUpdateManyWithoutPartnerInput>
  }

  export type AppointmentUpsertWithWhereUniqueWithoutUserAInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutUserAInput, AppointmentUncheckedUpdateWithoutUserAInput>
    create: XOR<AppointmentCreateWithoutUserAInput, AppointmentUncheckedCreateWithoutUserAInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutUserAInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutUserAInput, AppointmentUncheckedUpdateWithoutUserAInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutUserAInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutUserAInput>
  }

  export type AppointmentScalarWhereInput = {
    AND?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    OR?: AppointmentScalarWhereInput[]
    NOT?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    id?: StringFilter<"Appointment"> | string
    proposalId?: StringFilter<"Appointment"> | string
    userAId?: StringFilter<"Appointment"> | string
    userBId?: StringFilter<"Appointment"> | string
    place?: StringFilter<"Appointment"> | string
    startsAt?: DateTimeFilter<"Appointment"> | Date | string
    status?: EnumAppointmentStatusFilter<"Appointment"> | $Enums.AppointmentStatus
    checkinCode?: StringFilter<"Appointment"> | string
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
  }

  export type AppointmentUpsertWithWhereUniqueWithoutUserBInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutUserBInput, AppointmentUncheckedUpdateWithoutUserBInput>
    create: XOR<AppointmentCreateWithoutUserBInput, AppointmentUncheckedCreateWithoutUserBInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutUserBInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutUserBInput, AppointmentUncheckedUpdateWithoutUserBInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutUserBInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutUserBInput>
  }

  export type AttendanceCheckUpsertWithWhereUniqueWithoutUserInput = {
    where: AttendanceCheckWhereUniqueInput
    update: XOR<AttendanceCheckUpdateWithoutUserInput, AttendanceCheckUncheckedUpdateWithoutUserInput>
    create: XOR<AttendanceCheckCreateWithoutUserInput, AttendanceCheckUncheckedCreateWithoutUserInput>
  }

  export type AttendanceCheckUpdateWithWhereUniqueWithoutUserInput = {
    where: AttendanceCheckWhereUniqueInput
    data: XOR<AttendanceCheckUpdateWithoutUserInput, AttendanceCheckUncheckedUpdateWithoutUserInput>
  }

  export type AttendanceCheckUpdateManyWithWhereWithoutUserInput = {
    where: AttendanceCheckScalarWhereInput
    data: XOR<AttendanceCheckUpdateManyMutationInput, AttendanceCheckUncheckedUpdateManyWithoutUserInput>
  }

  export type AttendanceCheckScalarWhereInput = {
    AND?: AttendanceCheckScalarWhereInput | AttendanceCheckScalarWhereInput[]
    OR?: AttendanceCheckScalarWhereInput[]
    NOT?: AttendanceCheckScalarWhereInput | AttendanceCheckScalarWhereInput[]
    id?: StringFilter<"AttendanceCheck"> | string
    appointmentId?: StringFilter<"AttendanceCheck"> | string
    userId?: StringFilter<"AttendanceCheck"> | string
    method?: StringFilter<"AttendanceCheck"> | string
    checkedAt?: DateTimeFilter<"AttendanceCheck"> | Date | string
  }

  export type ReportUpsertWithWhereUniqueWithoutReporterInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutReporterInput, ReportUncheckedUpdateWithoutReporterInput>
    create: XOR<ReportCreateWithoutReporterInput, ReportUncheckedCreateWithoutReporterInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutReporterInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutReporterInput, ReportUncheckedUpdateWithoutReporterInput>
  }

  export type ReportUpdateManyWithWhereWithoutReporterInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutReporterInput>
  }

  export type ReportScalarWhereInput = {
    AND?: ReportScalarWhereInput | ReportScalarWhereInput[]
    OR?: ReportScalarWhereInput[]
    NOT?: ReportScalarWhereInput | ReportScalarWhereInput[]
    id?: StringFilter<"Report"> | string
    appointmentId?: StringFilter<"Report"> | string
    reporterId?: StringFilter<"Report"> | string
    targetUserId?: StringFilter<"Report"> | string
    reason?: StringFilter<"Report"> | string
    evidence?: StringNullableFilter<"Report"> | string | null
    status?: EnumReportStatusFilter<"Report"> | $Enums.ReportStatus
    createdAt?: DateTimeFilter<"Report"> | Date | string
  }

  export type SanctionUpsertWithWhereUniqueWithoutUserInput = {
    where: SanctionWhereUniqueInput
    update: XOR<SanctionUpdateWithoutUserInput, SanctionUncheckedUpdateWithoutUserInput>
    create: XOR<SanctionCreateWithoutUserInput, SanctionUncheckedCreateWithoutUserInput>
  }

  export type SanctionUpdateWithWhereUniqueWithoutUserInput = {
    where: SanctionWhereUniqueInput
    data: XOR<SanctionUpdateWithoutUserInput, SanctionUncheckedUpdateWithoutUserInput>
  }

  export type SanctionUpdateManyWithWhereWithoutUserInput = {
    where: SanctionScalarWhereInput
    data: XOR<SanctionUpdateManyMutationInput, SanctionUncheckedUpdateManyWithoutUserInput>
  }

  export type SanctionScalarWhereInput = {
    AND?: SanctionScalarWhereInput | SanctionScalarWhereInput[]
    OR?: SanctionScalarWhereInput[]
    NOT?: SanctionScalarWhereInput | SanctionScalarWhereInput[]
    id?: StringFilter<"Sanction"> | string
    userId?: StringFilter<"Sanction"> | string
    level?: EnumSanctionLevelFilter<"Sanction"> | $Enums.SanctionLevel
    reason?: StringFilter<"Sanction"> | string
    startAt?: DateTimeFilter<"Sanction"> | Date | string
    endAt?: DateTimeNullableFilter<"Sanction"> | Date | string | null
    createdAt?: DateTimeFilter<"Sanction"> | Date | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutReviewerInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutReviewerInput, ReviewUncheckedUpdateWithoutReviewerInput>
    create: XOR<ReviewCreateWithoutReviewerInput, ReviewUncheckedCreateWithoutReviewerInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutReviewerInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutReviewerInput, ReviewUncheckedUpdateWithoutReviewerInput>
  }

  export type ReviewUpdateManyWithWhereWithoutReviewerInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutReviewerInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    OR?: ReviewScalarWhereInput[]
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    id?: StringFilter<"Review"> | string
    appointmentId?: StringFilter<"Review"> | string
    reviewerId?: StringFilter<"Review"> | string
    revieweeId?: StringFilter<"Review"> | string
    comment?: StringFilter<"Review"> | string
    scoreDelta?: IntFilter<"Review"> | number
    createdAt?: DateTimeFilter<"Review"> | Date | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutRevieweeInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutRevieweeInput, ReviewUncheckedUpdateWithoutRevieweeInput>
    create: XOR<ReviewCreateWithoutRevieweeInput, ReviewUncheckedCreateWithoutRevieweeInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutRevieweeInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutRevieweeInput, ReviewUncheckedUpdateWithoutRevieweeInput>
  }

  export type ReviewUpdateManyWithWhereWithoutRevieweeInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutRevieweeInput>
  }

  export type UserCreateWithoutInterestsInput = {
    id?: string
    email: string
    provider: string
    nickname: string
    bio?: string | null
    region?: string | null
    trustScore?: number
    phoneVerified?: boolean
    blocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    availability?: AvailabilitySlotCreateNestedManyWithoutUserInput
    proposer?: MatchProposalCreateNestedManyWithoutProposerInput
    partner?: MatchProposalCreateNestedManyWithoutPartnerInput
    appointmentsA?: AppointmentCreateNestedManyWithoutUserAInput
    appointmentsB?: AppointmentCreateNestedManyWithoutUserBInput
    checks?: AttendanceCheckCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutReporterInput
    sanctions?: SanctionCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewCreateNestedManyWithoutReviewerInput
    reviewsRecv?: ReviewCreateNestedManyWithoutRevieweeInput
  }

  export type UserUncheckedCreateWithoutInterestsInput = {
    id?: string
    email: string
    provider: string
    nickname: string
    bio?: string | null
    region?: string | null
    trustScore?: number
    phoneVerified?: boolean
    blocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    availability?: AvailabilitySlotUncheckedCreateNestedManyWithoutUserInput
    proposer?: MatchProposalUncheckedCreateNestedManyWithoutProposerInput
    partner?: MatchProposalUncheckedCreateNestedManyWithoutPartnerInput
    appointmentsA?: AppointmentUncheckedCreateNestedManyWithoutUserAInput
    appointmentsB?: AppointmentUncheckedCreateNestedManyWithoutUserBInput
    checks?: AttendanceCheckUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutReporterInput
    sanctions?: SanctionUncheckedCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutReviewerInput
    reviewsRecv?: ReviewUncheckedCreateNestedManyWithoutRevieweeInput
  }

  export type UserCreateOrConnectWithoutInterestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInterestsInput, UserUncheckedCreateWithoutInterestsInput>
  }

  export type UserUpsertWithoutInterestsInput = {
    update: XOR<UserUpdateWithoutInterestsInput, UserUncheckedUpdateWithoutInterestsInput>
    create: XOR<UserCreateWithoutInterestsInput, UserUncheckedCreateWithoutInterestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInterestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInterestsInput, UserUncheckedUpdateWithoutInterestsInput>
  }

  export type UserUpdateWithoutInterestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    blocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    availability?: AvailabilitySlotUpdateManyWithoutUserNestedInput
    proposer?: MatchProposalUpdateManyWithoutProposerNestedInput
    partner?: MatchProposalUpdateManyWithoutPartnerNestedInput
    appointmentsA?: AppointmentUpdateManyWithoutUserANestedInput
    appointmentsB?: AppointmentUpdateManyWithoutUserBNestedInput
    checks?: AttendanceCheckUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutReporterNestedInput
    sanctions?: SanctionUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutReviewerNestedInput
    reviewsRecv?: ReviewUpdateManyWithoutRevieweeNestedInput
  }

  export type UserUncheckedUpdateWithoutInterestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    blocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    availability?: AvailabilitySlotUncheckedUpdateManyWithoutUserNestedInput
    proposer?: MatchProposalUncheckedUpdateManyWithoutProposerNestedInput
    partner?: MatchProposalUncheckedUpdateManyWithoutPartnerNestedInput
    appointmentsA?: AppointmentUncheckedUpdateManyWithoutUserANestedInput
    appointmentsB?: AppointmentUncheckedUpdateManyWithoutUserBNestedInput
    checks?: AttendanceCheckUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    sanctions?: SanctionUncheckedUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutReviewerNestedInput
    reviewsRecv?: ReviewUncheckedUpdateManyWithoutRevieweeNestedInput
  }

  export type UserCreateWithoutAvailabilityInput = {
    id?: string
    email: string
    provider: string
    nickname: string
    bio?: string | null
    region?: string | null
    trustScore?: number
    phoneVerified?: boolean
    blocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: UserInterestCreateNestedManyWithoutUserInput
    proposer?: MatchProposalCreateNestedManyWithoutProposerInput
    partner?: MatchProposalCreateNestedManyWithoutPartnerInput
    appointmentsA?: AppointmentCreateNestedManyWithoutUserAInput
    appointmentsB?: AppointmentCreateNestedManyWithoutUserBInput
    checks?: AttendanceCheckCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutReporterInput
    sanctions?: SanctionCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewCreateNestedManyWithoutReviewerInput
    reviewsRecv?: ReviewCreateNestedManyWithoutRevieweeInput
  }

  export type UserUncheckedCreateWithoutAvailabilityInput = {
    id?: string
    email: string
    provider: string
    nickname: string
    bio?: string | null
    region?: string | null
    trustScore?: number
    phoneVerified?: boolean
    blocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: UserInterestUncheckedCreateNestedManyWithoutUserInput
    proposer?: MatchProposalUncheckedCreateNestedManyWithoutProposerInput
    partner?: MatchProposalUncheckedCreateNestedManyWithoutPartnerInput
    appointmentsA?: AppointmentUncheckedCreateNestedManyWithoutUserAInput
    appointmentsB?: AppointmentUncheckedCreateNestedManyWithoutUserBInput
    checks?: AttendanceCheckUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutReporterInput
    sanctions?: SanctionUncheckedCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutReviewerInput
    reviewsRecv?: ReviewUncheckedCreateNestedManyWithoutRevieweeInput
  }

  export type UserCreateOrConnectWithoutAvailabilityInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAvailabilityInput, UserUncheckedCreateWithoutAvailabilityInput>
  }

  export type UserUpsertWithoutAvailabilityInput = {
    update: XOR<UserUpdateWithoutAvailabilityInput, UserUncheckedUpdateWithoutAvailabilityInput>
    create: XOR<UserCreateWithoutAvailabilityInput, UserUncheckedCreateWithoutAvailabilityInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAvailabilityInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAvailabilityInput, UserUncheckedUpdateWithoutAvailabilityInput>
  }

  export type UserUpdateWithoutAvailabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    blocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: UserInterestUpdateManyWithoutUserNestedInput
    proposer?: MatchProposalUpdateManyWithoutProposerNestedInput
    partner?: MatchProposalUpdateManyWithoutPartnerNestedInput
    appointmentsA?: AppointmentUpdateManyWithoutUserANestedInput
    appointmentsB?: AppointmentUpdateManyWithoutUserBNestedInput
    checks?: AttendanceCheckUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutReporterNestedInput
    sanctions?: SanctionUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutReviewerNestedInput
    reviewsRecv?: ReviewUpdateManyWithoutRevieweeNestedInput
  }

  export type UserUncheckedUpdateWithoutAvailabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    blocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: UserInterestUncheckedUpdateManyWithoutUserNestedInput
    proposer?: MatchProposalUncheckedUpdateManyWithoutProposerNestedInput
    partner?: MatchProposalUncheckedUpdateManyWithoutPartnerNestedInput
    appointmentsA?: AppointmentUncheckedUpdateManyWithoutUserANestedInput
    appointmentsB?: AppointmentUncheckedUpdateManyWithoutUserBNestedInput
    checks?: AttendanceCheckUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    sanctions?: SanctionUncheckedUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutReviewerNestedInput
    reviewsRecv?: ReviewUncheckedUpdateManyWithoutRevieweeNestedInput
  }

  export type UserCreateWithoutProposerInput = {
    id?: string
    email: string
    provider: string
    nickname: string
    bio?: string | null
    region?: string | null
    trustScore?: number
    phoneVerified?: boolean
    blocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: UserInterestCreateNestedManyWithoutUserInput
    availability?: AvailabilitySlotCreateNestedManyWithoutUserInput
    partner?: MatchProposalCreateNestedManyWithoutPartnerInput
    appointmentsA?: AppointmentCreateNestedManyWithoutUserAInput
    appointmentsB?: AppointmentCreateNestedManyWithoutUserBInput
    checks?: AttendanceCheckCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutReporterInput
    sanctions?: SanctionCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewCreateNestedManyWithoutReviewerInput
    reviewsRecv?: ReviewCreateNestedManyWithoutRevieweeInput
  }

  export type UserUncheckedCreateWithoutProposerInput = {
    id?: string
    email: string
    provider: string
    nickname: string
    bio?: string | null
    region?: string | null
    trustScore?: number
    phoneVerified?: boolean
    blocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: UserInterestUncheckedCreateNestedManyWithoutUserInput
    availability?: AvailabilitySlotUncheckedCreateNestedManyWithoutUserInput
    partner?: MatchProposalUncheckedCreateNestedManyWithoutPartnerInput
    appointmentsA?: AppointmentUncheckedCreateNestedManyWithoutUserAInput
    appointmentsB?: AppointmentUncheckedCreateNestedManyWithoutUserBInput
    checks?: AttendanceCheckUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutReporterInput
    sanctions?: SanctionUncheckedCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutReviewerInput
    reviewsRecv?: ReviewUncheckedCreateNestedManyWithoutRevieweeInput
  }

  export type UserCreateOrConnectWithoutProposerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProposerInput, UserUncheckedCreateWithoutProposerInput>
  }

  export type UserCreateWithoutPartnerInput = {
    id?: string
    email: string
    provider: string
    nickname: string
    bio?: string | null
    region?: string | null
    trustScore?: number
    phoneVerified?: boolean
    blocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: UserInterestCreateNestedManyWithoutUserInput
    availability?: AvailabilitySlotCreateNestedManyWithoutUserInput
    proposer?: MatchProposalCreateNestedManyWithoutProposerInput
    appointmentsA?: AppointmentCreateNestedManyWithoutUserAInput
    appointmentsB?: AppointmentCreateNestedManyWithoutUserBInput
    checks?: AttendanceCheckCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutReporterInput
    sanctions?: SanctionCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewCreateNestedManyWithoutReviewerInput
    reviewsRecv?: ReviewCreateNestedManyWithoutRevieweeInput
  }

  export type UserUncheckedCreateWithoutPartnerInput = {
    id?: string
    email: string
    provider: string
    nickname: string
    bio?: string | null
    region?: string | null
    trustScore?: number
    phoneVerified?: boolean
    blocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: UserInterestUncheckedCreateNestedManyWithoutUserInput
    availability?: AvailabilitySlotUncheckedCreateNestedManyWithoutUserInput
    proposer?: MatchProposalUncheckedCreateNestedManyWithoutProposerInput
    appointmentsA?: AppointmentUncheckedCreateNestedManyWithoutUserAInput
    appointmentsB?: AppointmentUncheckedCreateNestedManyWithoutUserBInput
    checks?: AttendanceCheckUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutReporterInput
    sanctions?: SanctionUncheckedCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutReviewerInput
    reviewsRecv?: ReviewUncheckedCreateNestedManyWithoutRevieweeInput
  }

  export type UserCreateOrConnectWithoutPartnerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPartnerInput, UserUncheckedCreateWithoutPartnerInput>
  }

  export type AppointmentCreateWithoutProposalInput = {
    id?: string
    place: string
    startsAt: Date | string
    status?: $Enums.AppointmentStatus
    checkinCode: string
    createdAt?: Date | string
    userA: UserCreateNestedOneWithoutAppointmentsAInput
    userB: UserCreateNestedOneWithoutAppointmentsBInput
    checks?: AttendanceCheckCreateNestedManyWithoutAppointmentInput
    reports?: ReportCreateNestedManyWithoutAppointmentInput
    reviews?: ReviewCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutProposalInput = {
    id?: string
    userAId: string
    userBId: string
    place: string
    startsAt: Date | string
    status?: $Enums.AppointmentStatus
    checkinCode: string
    createdAt?: Date | string
    checks?: AttendanceCheckUncheckedCreateNestedManyWithoutAppointmentInput
    reports?: ReportUncheckedCreateNestedManyWithoutAppointmentInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutProposalInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutProposalInput, AppointmentUncheckedCreateWithoutProposalInput>
  }

  export type UserUpsertWithoutProposerInput = {
    update: XOR<UserUpdateWithoutProposerInput, UserUncheckedUpdateWithoutProposerInput>
    create: XOR<UserCreateWithoutProposerInput, UserUncheckedCreateWithoutProposerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProposerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProposerInput, UserUncheckedUpdateWithoutProposerInput>
  }

  export type UserUpdateWithoutProposerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    blocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: UserInterestUpdateManyWithoutUserNestedInput
    availability?: AvailabilitySlotUpdateManyWithoutUserNestedInput
    partner?: MatchProposalUpdateManyWithoutPartnerNestedInput
    appointmentsA?: AppointmentUpdateManyWithoutUserANestedInput
    appointmentsB?: AppointmentUpdateManyWithoutUserBNestedInput
    checks?: AttendanceCheckUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutReporterNestedInput
    sanctions?: SanctionUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutReviewerNestedInput
    reviewsRecv?: ReviewUpdateManyWithoutRevieweeNestedInput
  }

  export type UserUncheckedUpdateWithoutProposerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    blocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: UserInterestUncheckedUpdateManyWithoutUserNestedInput
    availability?: AvailabilitySlotUncheckedUpdateManyWithoutUserNestedInput
    partner?: MatchProposalUncheckedUpdateManyWithoutPartnerNestedInput
    appointmentsA?: AppointmentUncheckedUpdateManyWithoutUserANestedInput
    appointmentsB?: AppointmentUncheckedUpdateManyWithoutUserBNestedInput
    checks?: AttendanceCheckUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    sanctions?: SanctionUncheckedUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutReviewerNestedInput
    reviewsRecv?: ReviewUncheckedUpdateManyWithoutRevieweeNestedInput
  }

  export type UserUpsertWithoutPartnerInput = {
    update: XOR<UserUpdateWithoutPartnerInput, UserUncheckedUpdateWithoutPartnerInput>
    create: XOR<UserCreateWithoutPartnerInput, UserUncheckedCreateWithoutPartnerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPartnerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPartnerInput, UserUncheckedUpdateWithoutPartnerInput>
  }

  export type UserUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    blocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: UserInterestUpdateManyWithoutUserNestedInput
    availability?: AvailabilitySlotUpdateManyWithoutUserNestedInput
    proposer?: MatchProposalUpdateManyWithoutProposerNestedInput
    appointmentsA?: AppointmentUpdateManyWithoutUserANestedInput
    appointmentsB?: AppointmentUpdateManyWithoutUserBNestedInput
    checks?: AttendanceCheckUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutReporterNestedInput
    sanctions?: SanctionUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutReviewerNestedInput
    reviewsRecv?: ReviewUpdateManyWithoutRevieweeNestedInput
  }

  export type UserUncheckedUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    blocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: UserInterestUncheckedUpdateManyWithoutUserNestedInput
    availability?: AvailabilitySlotUncheckedUpdateManyWithoutUserNestedInput
    proposer?: MatchProposalUncheckedUpdateManyWithoutProposerNestedInput
    appointmentsA?: AppointmentUncheckedUpdateManyWithoutUserANestedInput
    appointmentsB?: AppointmentUncheckedUpdateManyWithoutUserBNestedInput
    checks?: AttendanceCheckUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    sanctions?: SanctionUncheckedUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutReviewerNestedInput
    reviewsRecv?: ReviewUncheckedUpdateManyWithoutRevieweeNestedInput
  }

  export type AppointmentUpsertWithoutProposalInput = {
    update: XOR<AppointmentUpdateWithoutProposalInput, AppointmentUncheckedUpdateWithoutProposalInput>
    create: XOR<AppointmentCreateWithoutProposalInput, AppointmentUncheckedCreateWithoutProposalInput>
    where?: AppointmentWhereInput
  }

  export type AppointmentUpdateToOneWithWhereWithoutProposalInput = {
    where?: AppointmentWhereInput
    data: XOR<AppointmentUpdateWithoutProposalInput, AppointmentUncheckedUpdateWithoutProposalInput>
  }

  export type AppointmentUpdateWithoutProposalInput = {
    id?: StringFieldUpdateOperationsInput | string
    place?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    checkinCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userA?: UserUpdateOneRequiredWithoutAppointmentsANestedInput
    userB?: UserUpdateOneRequiredWithoutAppointmentsBNestedInput
    checks?: AttendanceCheckUpdateManyWithoutAppointmentNestedInput
    reports?: ReportUpdateManyWithoutAppointmentNestedInput
    reviews?: ReviewUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutProposalInput = {
    id?: StringFieldUpdateOperationsInput | string
    userAId?: StringFieldUpdateOperationsInput | string
    userBId?: StringFieldUpdateOperationsInput | string
    place?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    checkinCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checks?: AttendanceCheckUncheckedUpdateManyWithoutAppointmentNestedInput
    reports?: ReportUncheckedUpdateManyWithoutAppointmentNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type MatchProposalCreateWithoutAppointmentInput = {
    id?: string
    message?: string | null
    status?: $Enums.MatchStatus
    createdAt?: Date | string
    proposer: UserCreateNestedOneWithoutProposerInput
    partner: UserCreateNestedOneWithoutPartnerInput
  }

  export type MatchProposalUncheckedCreateWithoutAppointmentInput = {
    id?: string
    proposerId: string
    partnerId: string
    message?: string | null
    status?: $Enums.MatchStatus
    createdAt?: Date | string
  }

  export type MatchProposalCreateOrConnectWithoutAppointmentInput = {
    where: MatchProposalWhereUniqueInput
    create: XOR<MatchProposalCreateWithoutAppointmentInput, MatchProposalUncheckedCreateWithoutAppointmentInput>
  }

  export type UserCreateWithoutAppointmentsAInput = {
    id?: string
    email: string
    provider: string
    nickname: string
    bio?: string | null
    region?: string | null
    trustScore?: number
    phoneVerified?: boolean
    blocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: UserInterestCreateNestedManyWithoutUserInput
    availability?: AvailabilitySlotCreateNestedManyWithoutUserInput
    proposer?: MatchProposalCreateNestedManyWithoutProposerInput
    partner?: MatchProposalCreateNestedManyWithoutPartnerInput
    appointmentsB?: AppointmentCreateNestedManyWithoutUserBInput
    checks?: AttendanceCheckCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutReporterInput
    sanctions?: SanctionCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewCreateNestedManyWithoutReviewerInput
    reviewsRecv?: ReviewCreateNestedManyWithoutRevieweeInput
  }

  export type UserUncheckedCreateWithoutAppointmentsAInput = {
    id?: string
    email: string
    provider: string
    nickname: string
    bio?: string | null
    region?: string | null
    trustScore?: number
    phoneVerified?: boolean
    blocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: UserInterestUncheckedCreateNestedManyWithoutUserInput
    availability?: AvailabilitySlotUncheckedCreateNestedManyWithoutUserInput
    proposer?: MatchProposalUncheckedCreateNestedManyWithoutProposerInput
    partner?: MatchProposalUncheckedCreateNestedManyWithoutPartnerInput
    appointmentsB?: AppointmentUncheckedCreateNestedManyWithoutUserBInput
    checks?: AttendanceCheckUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutReporterInput
    sanctions?: SanctionUncheckedCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutReviewerInput
    reviewsRecv?: ReviewUncheckedCreateNestedManyWithoutRevieweeInput
  }

  export type UserCreateOrConnectWithoutAppointmentsAInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAppointmentsAInput, UserUncheckedCreateWithoutAppointmentsAInput>
  }

  export type UserCreateWithoutAppointmentsBInput = {
    id?: string
    email: string
    provider: string
    nickname: string
    bio?: string | null
    region?: string | null
    trustScore?: number
    phoneVerified?: boolean
    blocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: UserInterestCreateNestedManyWithoutUserInput
    availability?: AvailabilitySlotCreateNestedManyWithoutUserInput
    proposer?: MatchProposalCreateNestedManyWithoutProposerInput
    partner?: MatchProposalCreateNestedManyWithoutPartnerInput
    appointmentsA?: AppointmentCreateNestedManyWithoutUserAInput
    checks?: AttendanceCheckCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutReporterInput
    sanctions?: SanctionCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewCreateNestedManyWithoutReviewerInput
    reviewsRecv?: ReviewCreateNestedManyWithoutRevieweeInput
  }

  export type UserUncheckedCreateWithoutAppointmentsBInput = {
    id?: string
    email: string
    provider: string
    nickname: string
    bio?: string | null
    region?: string | null
    trustScore?: number
    phoneVerified?: boolean
    blocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: UserInterestUncheckedCreateNestedManyWithoutUserInput
    availability?: AvailabilitySlotUncheckedCreateNestedManyWithoutUserInput
    proposer?: MatchProposalUncheckedCreateNestedManyWithoutProposerInput
    partner?: MatchProposalUncheckedCreateNestedManyWithoutPartnerInput
    appointmentsA?: AppointmentUncheckedCreateNestedManyWithoutUserAInput
    checks?: AttendanceCheckUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutReporterInput
    sanctions?: SanctionUncheckedCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutReviewerInput
    reviewsRecv?: ReviewUncheckedCreateNestedManyWithoutRevieweeInput
  }

  export type UserCreateOrConnectWithoutAppointmentsBInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAppointmentsBInput, UserUncheckedCreateWithoutAppointmentsBInput>
  }

  export type AttendanceCheckCreateWithoutAppointmentInput = {
    id?: string
    method: string
    checkedAt?: Date | string
    user: UserCreateNestedOneWithoutChecksInput
  }

  export type AttendanceCheckUncheckedCreateWithoutAppointmentInput = {
    id?: string
    userId: string
    method: string
    checkedAt?: Date | string
  }

  export type AttendanceCheckCreateOrConnectWithoutAppointmentInput = {
    where: AttendanceCheckWhereUniqueInput
    create: XOR<AttendanceCheckCreateWithoutAppointmentInput, AttendanceCheckUncheckedCreateWithoutAppointmentInput>
  }

  export type AttendanceCheckCreateManyAppointmentInputEnvelope = {
    data: AttendanceCheckCreateManyAppointmentInput | AttendanceCheckCreateManyAppointmentInput[]
  }

  export type ReportCreateWithoutAppointmentInput = {
    id?: string
    targetUserId: string
    reason: string
    evidence?: string | null
    status?: $Enums.ReportStatus
    createdAt?: Date | string
    reporter: UserCreateNestedOneWithoutReportsInput
  }

  export type ReportUncheckedCreateWithoutAppointmentInput = {
    id?: string
    reporterId: string
    targetUserId: string
    reason: string
    evidence?: string | null
    status?: $Enums.ReportStatus
    createdAt?: Date | string
  }

  export type ReportCreateOrConnectWithoutAppointmentInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutAppointmentInput, ReportUncheckedCreateWithoutAppointmentInput>
  }

  export type ReportCreateManyAppointmentInputEnvelope = {
    data: ReportCreateManyAppointmentInput | ReportCreateManyAppointmentInput[]
  }

  export type ReviewCreateWithoutAppointmentInput = {
    id?: string
    comment: string
    scoreDelta?: number
    createdAt?: Date | string
    reviewer: UserCreateNestedOneWithoutReviewsGivenInput
    reviewee: UserCreateNestedOneWithoutReviewsRecvInput
  }

  export type ReviewUncheckedCreateWithoutAppointmentInput = {
    id?: string
    reviewerId: string
    revieweeId: string
    comment: string
    scoreDelta?: number
    createdAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutAppointmentInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutAppointmentInput, ReviewUncheckedCreateWithoutAppointmentInput>
  }

  export type ReviewCreateManyAppointmentInputEnvelope = {
    data: ReviewCreateManyAppointmentInput | ReviewCreateManyAppointmentInput[]
  }

  export type MatchProposalUpsertWithoutAppointmentInput = {
    update: XOR<MatchProposalUpdateWithoutAppointmentInput, MatchProposalUncheckedUpdateWithoutAppointmentInput>
    create: XOR<MatchProposalCreateWithoutAppointmentInput, MatchProposalUncheckedCreateWithoutAppointmentInput>
    where?: MatchProposalWhereInput
  }

  export type MatchProposalUpdateToOneWithWhereWithoutAppointmentInput = {
    where?: MatchProposalWhereInput
    data: XOR<MatchProposalUpdateWithoutAppointmentInput, MatchProposalUncheckedUpdateWithoutAppointmentInput>
  }

  export type MatchProposalUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proposer?: UserUpdateOneRequiredWithoutProposerNestedInput
    partner?: UserUpdateOneRequiredWithoutPartnerNestedInput
  }

  export type MatchProposalUncheckedUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposerId?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutAppointmentsAInput = {
    update: XOR<UserUpdateWithoutAppointmentsAInput, UserUncheckedUpdateWithoutAppointmentsAInput>
    create: XOR<UserCreateWithoutAppointmentsAInput, UserUncheckedCreateWithoutAppointmentsAInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAppointmentsAInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAppointmentsAInput, UserUncheckedUpdateWithoutAppointmentsAInput>
  }

  export type UserUpdateWithoutAppointmentsAInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    blocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: UserInterestUpdateManyWithoutUserNestedInput
    availability?: AvailabilitySlotUpdateManyWithoutUserNestedInput
    proposer?: MatchProposalUpdateManyWithoutProposerNestedInput
    partner?: MatchProposalUpdateManyWithoutPartnerNestedInput
    appointmentsB?: AppointmentUpdateManyWithoutUserBNestedInput
    checks?: AttendanceCheckUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutReporterNestedInput
    sanctions?: SanctionUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutReviewerNestedInput
    reviewsRecv?: ReviewUpdateManyWithoutRevieweeNestedInput
  }

  export type UserUncheckedUpdateWithoutAppointmentsAInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    blocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: UserInterestUncheckedUpdateManyWithoutUserNestedInput
    availability?: AvailabilitySlotUncheckedUpdateManyWithoutUserNestedInput
    proposer?: MatchProposalUncheckedUpdateManyWithoutProposerNestedInput
    partner?: MatchProposalUncheckedUpdateManyWithoutPartnerNestedInput
    appointmentsB?: AppointmentUncheckedUpdateManyWithoutUserBNestedInput
    checks?: AttendanceCheckUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    sanctions?: SanctionUncheckedUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutReviewerNestedInput
    reviewsRecv?: ReviewUncheckedUpdateManyWithoutRevieweeNestedInput
  }

  export type UserUpsertWithoutAppointmentsBInput = {
    update: XOR<UserUpdateWithoutAppointmentsBInput, UserUncheckedUpdateWithoutAppointmentsBInput>
    create: XOR<UserCreateWithoutAppointmentsBInput, UserUncheckedCreateWithoutAppointmentsBInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAppointmentsBInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAppointmentsBInput, UserUncheckedUpdateWithoutAppointmentsBInput>
  }

  export type UserUpdateWithoutAppointmentsBInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    blocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: UserInterestUpdateManyWithoutUserNestedInput
    availability?: AvailabilitySlotUpdateManyWithoutUserNestedInput
    proposer?: MatchProposalUpdateManyWithoutProposerNestedInput
    partner?: MatchProposalUpdateManyWithoutPartnerNestedInput
    appointmentsA?: AppointmentUpdateManyWithoutUserANestedInput
    checks?: AttendanceCheckUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutReporterNestedInput
    sanctions?: SanctionUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutReviewerNestedInput
    reviewsRecv?: ReviewUpdateManyWithoutRevieweeNestedInput
  }

  export type UserUncheckedUpdateWithoutAppointmentsBInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    blocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: UserInterestUncheckedUpdateManyWithoutUserNestedInput
    availability?: AvailabilitySlotUncheckedUpdateManyWithoutUserNestedInput
    proposer?: MatchProposalUncheckedUpdateManyWithoutProposerNestedInput
    partner?: MatchProposalUncheckedUpdateManyWithoutPartnerNestedInput
    appointmentsA?: AppointmentUncheckedUpdateManyWithoutUserANestedInput
    checks?: AttendanceCheckUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    sanctions?: SanctionUncheckedUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutReviewerNestedInput
    reviewsRecv?: ReviewUncheckedUpdateManyWithoutRevieweeNestedInput
  }

  export type AttendanceCheckUpsertWithWhereUniqueWithoutAppointmentInput = {
    where: AttendanceCheckWhereUniqueInput
    update: XOR<AttendanceCheckUpdateWithoutAppointmentInput, AttendanceCheckUncheckedUpdateWithoutAppointmentInput>
    create: XOR<AttendanceCheckCreateWithoutAppointmentInput, AttendanceCheckUncheckedCreateWithoutAppointmentInput>
  }

  export type AttendanceCheckUpdateWithWhereUniqueWithoutAppointmentInput = {
    where: AttendanceCheckWhereUniqueInput
    data: XOR<AttendanceCheckUpdateWithoutAppointmentInput, AttendanceCheckUncheckedUpdateWithoutAppointmentInput>
  }

  export type AttendanceCheckUpdateManyWithWhereWithoutAppointmentInput = {
    where: AttendanceCheckScalarWhereInput
    data: XOR<AttendanceCheckUpdateManyMutationInput, AttendanceCheckUncheckedUpdateManyWithoutAppointmentInput>
  }

  export type ReportUpsertWithWhereUniqueWithoutAppointmentInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutAppointmentInput, ReportUncheckedUpdateWithoutAppointmentInput>
    create: XOR<ReportCreateWithoutAppointmentInput, ReportUncheckedCreateWithoutAppointmentInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutAppointmentInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutAppointmentInput, ReportUncheckedUpdateWithoutAppointmentInput>
  }

  export type ReportUpdateManyWithWhereWithoutAppointmentInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutAppointmentInput>
  }

  export type ReviewUpsertWithWhereUniqueWithoutAppointmentInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutAppointmentInput, ReviewUncheckedUpdateWithoutAppointmentInput>
    create: XOR<ReviewCreateWithoutAppointmentInput, ReviewUncheckedCreateWithoutAppointmentInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutAppointmentInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutAppointmentInput, ReviewUncheckedUpdateWithoutAppointmentInput>
  }

  export type ReviewUpdateManyWithWhereWithoutAppointmentInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutAppointmentInput>
  }

  export type AppointmentCreateWithoutChecksInput = {
    id?: string
    place: string
    startsAt: Date | string
    status?: $Enums.AppointmentStatus
    checkinCode: string
    createdAt?: Date | string
    proposal: MatchProposalCreateNestedOneWithoutAppointmentInput
    userA: UserCreateNestedOneWithoutAppointmentsAInput
    userB: UserCreateNestedOneWithoutAppointmentsBInput
    reports?: ReportCreateNestedManyWithoutAppointmentInput
    reviews?: ReviewCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutChecksInput = {
    id?: string
    proposalId: string
    userAId: string
    userBId: string
    place: string
    startsAt: Date | string
    status?: $Enums.AppointmentStatus
    checkinCode: string
    createdAt?: Date | string
    reports?: ReportUncheckedCreateNestedManyWithoutAppointmentInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutChecksInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutChecksInput, AppointmentUncheckedCreateWithoutChecksInput>
  }

  export type UserCreateWithoutChecksInput = {
    id?: string
    email: string
    provider: string
    nickname: string
    bio?: string | null
    region?: string | null
    trustScore?: number
    phoneVerified?: boolean
    blocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: UserInterestCreateNestedManyWithoutUserInput
    availability?: AvailabilitySlotCreateNestedManyWithoutUserInput
    proposer?: MatchProposalCreateNestedManyWithoutProposerInput
    partner?: MatchProposalCreateNestedManyWithoutPartnerInput
    appointmentsA?: AppointmentCreateNestedManyWithoutUserAInput
    appointmentsB?: AppointmentCreateNestedManyWithoutUserBInput
    reports?: ReportCreateNestedManyWithoutReporterInput
    sanctions?: SanctionCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewCreateNestedManyWithoutReviewerInput
    reviewsRecv?: ReviewCreateNestedManyWithoutRevieweeInput
  }

  export type UserUncheckedCreateWithoutChecksInput = {
    id?: string
    email: string
    provider: string
    nickname: string
    bio?: string | null
    region?: string | null
    trustScore?: number
    phoneVerified?: boolean
    blocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: UserInterestUncheckedCreateNestedManyWithoutUserInput
    availability?: AvailabilitySlotUncheckedCreateNestedManyWithoutUserInput
    proposer?: MatchProposalUncheckedCreateNestedManyWithoutProposerInput
    partner?: MatchProposalUncheckedCreateNestedManyWithoutPartnerInput
    appointmentsA?: AppointmentUncheckedCreateNestedManyWithoutUserAInput
    appointmentsB?: AppointmentUncheckedCreateNestedManyWithoutUserBInput
    reports?: ReportUncheckedCreateNestedManyWithoutReporterInput
    sanctions?: SanctionUncheckedCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutReviewerInput
    reviewsRecv?: ReviewUncheckedCreateNestedManyWithoutRevieweeInput
  }

  export type UserCreateOrConnectWithoutChecksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChecksInput, UserUncheckedCreateWithoutChecksInput>
  }

  export type AppointmentUpsertWithoutChecksInput = {
    update: XOR<AppointmentUpdateWithoutChecksInput, AppointmentUncheckedUpdateWithoutChecksInput>
    create: XOR<AppointmentCreateWithoutChecksInput, AppointmentUncheckedCreateWithoutChecksInput>
    where?: AppointmentWhereInput
  }

  export type AppointmentUpdateToOneWithWhereWithoutChecksInput = {
    where?: AppointmentWhereInput
    data: XOR<AppointmentUpdateWithoutChecksInput, AppointmentUncheckedUpdateWithoutChecksInput>
  }

  export type AppointmentUpdateWithoutChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    place?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    checkinCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proposal?: MatchProposalUpdateOneRequiredWithoutAppointmentNestedInput
    userA?: UserUpdateOneRequiredWithoutAppointmentsANestedInput
    userB?: UserUpdateOneRequiredWithoutAppointmentsBNestedInput
    reports?: ReportUpdateManyWithoutAppointmentNestedInput
    reviews?: ReviewUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposalId?: StringFieldUpdateOperationsInput | string
    userAId?: StringFieldUpdateOperationsInput | string
    userBId?: StringFieldUpdateOperationsInput | string
    place?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    checkinCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: ReportUncheckedUpdateManyWithoutAppointmentNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type UserUpsertWithoutChecksInput = {
    update: XOR<UserUpdateWithoutChecksInput, UserUncheckedUpdateWithoutChecksInput>
    create: XOR<UserCreateWithoutChecksInput, UserUncheckedCreateWithoutChecksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChecksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChecksInput, UserUncheckedUpdateWithoutChecksInput>
  }

  export type UserUpdateWithoutChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    blocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: UserInterestUpdateManyWithoutUserNestedInput
    availability?: AvailabilitySlotUpdateManyWithoutUserNestedInput
    proposer?: MatchProposalUpdateManyWithoutProposerNestedInput
    partner?: MatchProposalUpdateManyWithoutPartnerNestedInput
    appointmentsA?: AppointmentUpdateManyWithoutUserANestedInput
    appointmentsB?: AppointmentUpdateManyWithoutUserBNestedInput
    reports?: ReportUpdateManyWithoutReporterNestedInput
    sanctions?: SanctionUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutReviewerNestedInput
    reviewsRecv?: ReviewUpdateManyWithoutRevieweeNestedInput
  }

  export type UserUncheckedUpdateWithoutChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    blocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: UserInterestUncheckedUpdateManyWithoutUserNestedInput
    availability?: AvailabilitySlotUncheckedUpdateManyWithoutUserNestedInput
    proposer?: MatchProposalUncheckedUpdateManyWithoutProposerNestedInput
    partner?: MatchProposalUncheckedUpdateManyWithoutPartnerNestedInput
    appointmentsA?: AppointmentUncheckedUpdateManyWithoutUserANestedInput
    appointmentsB?: AppointmentUncheckedUpdateManyWithoutUserBNestedInput
    reports?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    sanctions?: SanctionUncheckedUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutReviewerNestedInput
    reviewsRecv?: ReviewUncheckedUpdateManyWithoutRevieweeNestedInput
  }

  export type AppointmentCreateWithoutReportsInput = {
    id?: string
    place: string
    startsAt: Date | string
    status?: $Enums.AppointmentStatus
    checkinCode: string
    createdAt?: Date | string
    proposal: MatchProposalCreateNestedOneWithoutAppointmentInput
    userA: UserCreateNestedOneWithoutAppointmentsAInput
    userB: UserCreateNestedOneWithoutAppointmentsBInput
    checks?: AttendanceCheckCreateNestedManyWithoutAppointmentInput
    reviews?: ReviewCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutReportsInput = {
    id?: string
    proposalId: string
    userAId: string
    userBId: string
    place: string
    startsAt: Date | string
    status?: $Enums.AppointmentStatus
    checkinCode: string
    createdAt?: Date | string
    checks?: AttendanceCheckUncheckedCreateNestedManyWithoutAppointmentInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutReportsInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutReportsInput, AppointmentUncheckedCreateWithoutReportsInput>
  }

  export type UserCreateWithoutReportsInput = {
    id?: string
    email: string
    provider: string
    nickname: string
    bio?: string | null
    region?: string | null
    trustScore?: number
    phoneVerified?: boolean
    blocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: UserInterestCreateNestedManyWithoutUserInput
    availability?: AvailabilitySlotCreateNestedManyWithoutUserInput
    proposer?: MatchProposalCreateNestedManyWithoutProposerInput
    partner?: MatchProposalCreateNestedManyWithoutPartnerInput
    appointmentsA?: AppointmentCreateNestedManyWithoutUserAInput
    appointmentsB?: AppointmentCreateNestedManyWithoutUserBInput
    checks?: AttendanceCheckCreateNestedManyWithoutUserInput
    sanctions?: SanctionCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewCreateNestedManyWithoutReviewerInput
    reviewsRecv?: ReviewCreateNestedManyWithoutRevieweeInput
  }

  export type UserUncheckedCreateWithoutReportsInput = {
    id?: string
    email: string
    provider: string
    nickname: string
    bio?: string | null
    region?: string | null
    trustScore?: number
    phoneVerified?: boolean
    blocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: UserInterestUncheckedCreateNestedManyWithoutUserInput
    availability?: AvailabilitySlotUncheckedCreateNestedManyWithoutUserInput
    proposer?: MatchProposalUncheckedCreateNestedManyWithoutProposerInput
    partner?: MatchProposalUncheckedCreateNestedManyWithoutPartnerInput
    appointmentsA?: AppointmentUncheckedCreateNestedManyWithoutUserAInput
    appointmentsB?: AppointmentUncheckedCreateNestedManyWithoutUserBInput
    checks?: AttendanceCheckUncheckedCreateNestedManyWithoutUserInput
    sanctions?: SanctionUncheckedCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutReviewerInput
    reviewsRecv?: ReviewUncheckedCreateNestedManyWithoutRevieweeInput
  }

  export type UserCreateOrConnectWithoutReportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
  }

  export type AppointmentUpsertWithoutReportsInput = {
    update: XOR<AppointmentUpdateWithoutReportsInput, AppointmentUncheckedUpdateWithoutReportsInput>
    create: XOR<AppointmentCreateWithoutReportsInput, AppointmentUncheckedCreateWithoutReportsInput>
    where?: AppointmentWhereInput
  }

  export type AppointmentUpdateToOneWithWhereWithoutReportsInput = {
    where?: AppointmentWhereInput
    data: XOR<AppointmentUpdateWithoutReportsInput, AppointmentUncheckedUpdateWithoutReportsInput>
  }

  export type AppointmentUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    place?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    checkinCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proposal?: MatchProposalUpdateOneRequiredWithoutAppointmentNestedInput
    userA?: UserUpdateOneRequiredWithoutAppointmentsANestedInput
    userB?: UserUpdateOneRequiredWithoutAppointmentsBNestedInput
    checks?: AttendanceCheckUpdateManyWithoutAppointmentNestedInput
    reviews?: ReviewUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposalId?: StringFieldUpdateOperationsInput | string
    userAId?: StringFieldUpdateOperationsInput | string
    userBId?: StringFieldUpdateOperationsInput | string
    place?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    checkinCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checks?: AttendanceCheckUncheckedUpdateManyWithoutAppointmentNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type UserUpsertWithoutReportsInput = {
    update: XOR<UserUpdateWithoutReportsInput, UserUncheckedUpdateWithoutReportsInput>
    create: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReportsInput, UserUncheckedUpdateWithoutReportsInput>
  }

  export type UserUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    blocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: UserInterestUpdateManyWithoutUserNestedInput
    availability?: AvailabilitySlotUpdateManyWithoutUserNestedInput
    proposer?: MatchProposalUpdateManyWithoutProposerNestedInput
    partner?: MatchProposalUpdateManyWithoutPartnerNestedInput
    appointmentsA?: AppointmentUpdateManyWithoutUserANestedInput
    appointmentsB?: AppointmentUpdateManyWithoutUserBNestedInput
    checks?: AttendanceCheckUpdateManyWithoutUserNestedInput
    sanctions?: SanctionUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutReviewerNestedInput
    reviewsRecv?: ReviewUpdateManyWithoutRevieweeNestedInput
  }

  export type UserUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    blocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: UserInterestUncheckedUpdateManyWithoutUserNestedInput
    availability?: AvailabilitySlotUncheckedUpdateManyWithoutUserNestedInput
    proposer?: MatchProposalUncheckedUpdateManyWithoutProposerNestedInput
    partner?: MatchProposalUncheckedUpdateManyWithoutPartnerNestedInput
    appointmentsA?: AppointmentUncheckedUpdateManyWithoutUserANestedInput
    appointmentsB?: AppointmentUncheckedUpdateManyWithoutUserBNestedInput
    checks?: AttendanceCheckUncheckedUpdateManyWithoutUserNestedInput
    sanctions?: SanctionUncheckedUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutReviewerNestedInput
    reviewsRecv?: ReviewUncheckedUpdateManyWithoutRevieweeNestedInput
  }

  export type UserCreateWithoutSanctionsInput = {
    id?: string
    email: string
    provider: string
    nickname: string
    bio?: string | null
    region?: string | null
    trustScore?: number
    phoneVerified?: boolean
    blocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: UserInterestCreateNestedManyWithoutUserInput
    availability?: AvailabilitySlotCreateNestedManyWithoutUserInput
    proposer?: MatchProposalCreateNestedManyWithoutProposerInput
    partner?: MatchProposalCreateNestedManyWithoutPartnerInput
    appointmentsA?: AppointmentCreateNestedManyWithoutUserAInput
    appointmentsB?: AppointmentCreateNestedManyWithoutUserBInput
    checks?: AttendanceCheckCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutReporterInput
    reviewsGiven?: ReviewCreateNestedManyWithoutReviewerInput
    reviewsRecv?: ReviewCreateNestedManyWithoutRevieweeInput
  }

  export type UserUncheckedCreateWithoutSanctionsInput = {
    id?: string
    email: string
    provider: string
    nickname: string
    bio?: string | null
    region?: string | null
    trustScore?: number
    phoneVerified?: boolean
    blocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: UserInterestUncheckedCreateNestedManyWithoutUserInput
    availability?: AvailabilitySlotUncheckedCreateNestedManyWithoutUserInput
    proposer?: MatchProposalUncheckedCreateNestedManyWithoutProposerInput
    partner?: MatchProposalUncheckedCreateNestedManyWithoutPartnerInput
    appointmentsA?: AppointmentUncheckedCreateNestedManyWithoutUserAInput
    appointmentsB?: AppointmentUncheckedCreateNestedManyWithoutUserBInput
    checks?: AttendanceCheckUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutReviewerInput
    reviewsRecv?: ReviewUncheckedCreateNestedManyWithoutRevieweeInput
  }

  export type UserCreateOrConnectWithoutSanctionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSanctionsInput, UserUncheckedCreateWithoutSanctionsInput>
  }

  export type UserUpsertWithoutSanctionsInput = {
    update: XOR<UserUpdateWithoutSanctionsInput, UserUncheckedUpdateWithoutSanctionsInput>
    create: XOR<UserCreateWithoutSanctionsInput, UserUncheckedCreateWithoutSanctionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSanctionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSanctionsInput, UserUncheckedUpdateWithoutSanctionsInput>
  }

  export type UserUpdateWithoutSanctionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    blocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: UserInterestUpdateManyWithoutUserNestedInput
    availability?: AvailabilitySlotUpdateManyWithoutUserNestedInput
    proposer?: MatchProposalUpdateManyWithoutProposerNestedInput
    partner?: MatchProposalUpdateManyWithoutPartnerNestedInput
    appointmentsA?: AppointmentUpdateManyWithoutUserANestedInput
    appointmentsB?: AppointmentUpdateManyWithoutUserBNestedInput
    checks?: AttendanceCheckUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutReporterNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutReviewerNestedInput
    reviewsRecv?: ReviewUpdateManyWithoutRevieweeNestedInput
  }

  export type UserUncheckedUpdateWithoutSanctionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    blocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: UserInterestUncheckedUpdateManyWithoutUserNestedInput
    availability?: AvailabilitySlotUncheckedUpdateManyWithoutUserNestedInput
    proposer?: MatchProposalUncheckedUpdateManyWithoutProposerNestedInput
    partner?: MatchProposalUncheckedUpdateManyWithoutPartnerNestedInput
    appointmentsA?: AppointmentUncheckedUpdateManyWithoutUserANestedInput
    appointmentsB?: AppointmentUncheckedUpdateManyWithoutUserBNestedInput
    checks?: AttendanceCheckUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutReviewerNestedInput
    reviewsRecv?: ReviewUncheckedUpdateManyWithoutRevieweeNestedInput
  }

  export type AppointmentCreateWithoutReviewsInput = {
    id?: string
    place: string
    startsAt: Date | string
    status?: $Enums.AppointmentStatus
    checkinCode: string
    createdAt?: Date | string
    proposal: MatchProposalCreateNestedOneWithoutAppointmentInput
    userA: UserCreateNestedOneWithoutAppointmentsAInput
    userB: UserCreateNestedOneWithoutAppointmentsBInput
    checks?: AttendanceCheckCreateNestedManyWithoutAppointmentInput
    reports?: ReportCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutReviewsInput = {
    id?: string
    proposalId: string
    userAId: string
    userBId: string
    place: string
    startsAt: Date | string
    status?: $Enums.AppointmentStatus
    checkinCode: string
    createdAt?: Date | string
    checks?: AttendanceCheckUncheckedCreateNestedManyWithoutAppointmentInput
    reports?: ReportUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutReviewsInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutReviewsInput, AppointmentUncheckedCreateWithoutReviewsInput>
  }

  export type UserCreateWithoutReviewsGivenInput = {
    id?: string
    email: string
    provider: string
    nickname: string
    bio?: string | null
    region?: string | null
    trustScore?: number
    phoneVerified?: boolean
    blocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: UserInterestCreateNestedManyWithoutUserInput
    availability?: AvailabilitySlotCreateNestedManyWithoutUserInput
    proposer?: MatchProposalCreateNestedManyWithoutProposerInput
    partner?: MatchProposalCreateNestedManyWithoutPartnerInput
    appointmentsA?: AppointmentCreateNestedManyWithoutUserAInput
    appointmentsB?: AppointmentCreateNestedManyWithoutUserBInput
    checks?: AttendanceCheckCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutReporterInput
    sanctions?: SanctionCreateNestedManyWithoutUserInput
    reviewsRecv?: ReviewCreateNestedManyWithoutRevieweeInput
  }

  export type UserUncheckedCreateWithoutReviewsGivenInput = {
    id?: string
    email: string
    provider: string
    nickname: string
    bio?: string | null
    region?: string | null
    trustScore?: number
    phoneVerified?: boolean
    blocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: UserInterestUncheckedCreateNestedManyWithoutUserInput
    availability?: AvailabilitySlotUncheckedCreateNestedManyWithoutUserInput
    proposer?: MatchProposalUncheckedCreateNestedManyWithoutProposerInput
    partner?: MatchProposalUncheckedCreateNestedManyWithoutPartnerInput
    appointmentsA?: AppointmentUncheckedCreateNestedManyWithoutUserAInput
    appointmentsB?: AppointmentUncheckedCreateNestedManyWithoutUserBInput
    checks?: AttendanceCheckUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutReporterInput
    sanctions?: SanctionUncheckedCreateNestedManyWithoutUserInput
    reviewsRecv?: ReviewUncheckedCreateNestedManyWithoutRevieweeInput
  }

  export type UserCreateOrConnectWithoutReviewsGivenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewsGivenInput, UserUncheckedCreateWithoutReviewsGivenInput>
  }

  export type UserCreateWithoutReviewsRecvInput = {
    id?: string
    email: string
    provider: string
    nickname: string
    bio?: string | null
    region?: string | null
    trustScore?: number
    phoneVerified?: boolean
    blocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: UserInterestCreateNestedManyWithoutUserInput
    availability?: AvailabilitySlotCreateNestedManyWithoutUserInput
    proposer?: MatchProposalCreateNestedManyWithoutProposerInput
    partner?: MatchProposalCreateNestedManyWithoutPartnerInput
    appointmentsA?: AppointmentCreateNestedManyWithoutUserAInput
    appointmentsB?: AppointmentCreateNestedManyWithoutUserBInput
    checks?: AttendanceCheckCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutReporterInput
    sanctions?: SanctionCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewCreateNestedManyWithoutReviewerInput
  }

  export type UserUncheckedCreateWithoutReviewsRecvInput = {
    id?: string
    email: string
    provider: string
    nickname: string
    bio?: string | null
    region?: string | null
    trustScore?: number
    phoneVerified?: boolean
    blocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: UserInterestUncheckedCreateNestedManyWithoutUserInput
    availability?: AvailabilitySlotUncheckedCreateNestedManyWithoutUserInput
    proposer?: MatchProposalUncheckedCreateNestedManyWithoutProposerInput
    partner?: MatchProposalUncheckedCreateNestedManyWithoutPartnerInput
    appointmentsA?: AppointmentUncheckedCreateNestedManyWithoutUserAInput
    appointmentsB?: AppointmentUncheckedCreateNestedManyWithoutUserBInput
    checks?: AttendanceCheckUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutReporterInput
    sanctions?: SanctionUncheckedCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type UserCreateOrConnectWithoutReviewsRecvInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewsRecvInput, UserUncheckedCreateWithoutReviewsRecvInput>
  }

  export type AppointmentUpsertWithoutReviewsInput = {
    update: XOR<AppointmentUpdateWithoutReviewsInput, AppointmentUncheckedUpdateWithoutReviewsInput>
    create: XOR<AppointmentCreateWithoutReviewsInput, AppointmentUncheckedCreateWithoutReviewsInput>
    where?: AppointmentWhereInput
  }

  export type AppointmentUpdateToOneWithWhereWithoutReviewsInput = {
    where?: AppointmentWhereInput
    data: XOR<AppointmentUpdateWithoutReviewsInput, AppointmentUncheckedUpdateWithoutReviewsInput>
  }

  export type AppointmentUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    place?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    checkinCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proposal?: MatchProposalUpdateOneRequiredWithoutAppointmentNestedInput
    userA?: UserUpdateOneRequiredWithoutAppointmentsANestedInput
    userB?: UserUpdateOneRequiredWithoutAppointmentsBNestedInput
    checks?: AttendanceCheckUpdateManyWithoutAppointmentNestedInput
    reports?: ReportUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposalId?: StringFieldUpdateOperationsInput | string
    userAId?: StringFieldUpdateOperationsInput | string
    userBId?: StringFieldUpdateOperationsInput | string
    place?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    checkinCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checks?: AttendanceCheckUncheckedUpdateManyWithoutAppointmentNestedInput
    reports?: ReportUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type UserUpsertWithoutReviewsGivenInput = {
    update: XOR<UserUpdateWithoutReviewsGivenInput, UserUncheckedUpdateWithoutReviewsGivenInput>
    create: XOR<UserCreateWithoutReviewsGivenInput, UserUncheckedCreateWithoutReviewsGivenInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewsGivenInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewsGivenInput, UserUncheckedUpdateWithoutReviewsGivenInput>
  }

  export type UserUpdateWithoutReviewsGivenInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    blocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: UserInterestUpdateManyWithoutUserNestedInput
    availability?: AvailabilitySlotUpdateManyWithoutUserNestedInput
    proposer?: MatchProposalUpdateManyWithoutProposerNestedInput
    partner?: MatchProposalUpdateManyWithoutPartnerNestedInput
    appointmentsA?: AppointmentUpdateManyWithoutUserANestedInput
    appointmentsB?: AppointmentUpdateManyWithoutUserBNestedInput
    checks?: AttendanceCheckUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutReporterNestedInput
    sanctions?: SanctionUpdateManyWithoutUserNestedInput
    reviewsRecv?: ReviewUpdateManyWithoutRevieweeNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewsGivenInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    blocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: UserInterestUncheckedUpdateManyWithoutUserNestedInput
    availability?: AvailabilitySlotUncheckedUpdateManyWithoutUserNestedInput
    proposer?: MatchProposalUncheckedUpdateManyWithoutProposerNestedInput
    partner?: MatchProposalUncheckedUpdateManyWithoutPartnerNestedInput
    appointmentsA?: AppointmentUncheckedUpdateManyWithoutUserANestedInput
    appointmentsB?: AppointmentUncheckedUpdateManyWithoutUserBNestedInput
    checks?: AttendanceCheckUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    sanctions?: SanctionUncheckedUpdateManyWithoutUserNestedInput
    reviewsRecv?: ReviewUncheckedUpdateManyWithoutRevieweeNestedInput
  }

  export type UserUpsertWithoutReviewsRecvInput = {
    update: XOR<UserUpdateWithoutReviewsRecvInput, UserUncheckedUpdateWithoutReviewsRecvInput>
    create: XOR<UserCreateWithoutReviewsRecvInput, UserUncheckedCreateWithoutReviewsRecvInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewsRecvInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewsRecvInput, UserUncheckedUpdateWithoutReviewsRecvInput>
  }

  export type UserUpdateWithoutReviewsRecvInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    blocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: UserInterestUpdateManyWithoutUserNestedInput
    availability?: AvailabilitySlotUpdateManyWithoutUserNestedInput
    proposer?: MatchProposalUpdateManyWithoutProposerNestedInput
    partner?: MatchProposalUpdateManyWithoutPartnerNestedInput
    appointmentsA?: AppointmentUpdateManyWithoutUserANestedInput
    appointmentsB?: AppointmentUpdateManyWithoutUserBNestedInput
    checks?: AttendanceCheckUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutReporterNestedInput
    sanctions?: SanctionUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutReviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewsRecvInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    blocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: UserInterestUncheckedUpdateManyWithoutUserNestedInput
    availability?: AvailabilitySlotUncheckedUpdateManyWithoutUserNestedInput
    proposer?: MatchProposalUncheckedUpdateManyWithoutProposerNestedInput
    partner?: MatchProposalUncheckedUpdateManyWithoutPartnerNestedInput
    appointmentsA?: AppointmentUncheckedUpdateManyWithoutUserANestedInput
    appointmentsB?: AppointmentUncheckedUpdateManyWithoutUserBNestedInput
    checks?: AttendanceCheckUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    sanctions?: SanctionUncheckedUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type UserInterestCreateManyUserInput = {
    id?: string
    name: string
  }

  export type AvailabilitySlotCreateManyUserInput = {
    id?: string
    weekday: number
    startTime: string
    endTime: string
    area: string
    createdAt?: Date | string
  }

  export type MatchProposalCreateManyProposerInput = {
    id?: string
    partnerId: string
    message?: string | null
    status?: $Enums.MatchStatus
    createdAt?: Date | string
  }

  export type MatchProposalCreateManyPartnerInput = {
    id?: string
    proposerId: string
    message?: string | null
    status?: $Enums.MatchStatus
    createdAt?: Date | string
  }

  export type AppointmentCreateManyUserAInput = {
    id?: string
    proposalId: string
    userBId: string
    place: string
    startsAt: Date | string
    status?: $Enums.AppointmentStatus
    checkinCode: string
    createdAt?: Date | string
  }

  export type AppointmentCreateManyUserBInput = {
    id?: string
    proposalId: string
    userAId: string
    place: string
    startsAt: Date | string
    status?: $Enums.AppointmentStatus
    checkinCode: string
    createdAt?: Date | string
  }

  export type AttendanceCheckCreateManyUserInput = {
    id?: string
    appointmentId: string
    method: string
    checkedAt?: Date | string
  }

  export type ReportCreateManyReporterInput = {
    id?: string
    appointmentId: string
    targetUserId: string
    reason: string
    evidence?: string | null
    status?: $Enums.ReportStatus
    createdAt?: Date | string
  }

  export type SanctionCreateManyUserInput = {
    id?: string
    level: $Enums.SanctionLevel
    reason: string
    startAt?: Date | string
    endAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ReviewCreateManyReviewerInput = {
    id?: string
    appointmentId: string
    revieweeId: string
    comment: string
    scoreDelta?: number
    createdAt?: Date | string
  }

  export type ReviewCreateManyRevieweeInput = {
    id?: string
    appointmentId: string
    reviewerId: string
    comment: string
    scoreDelta?: number
    createdAt?: Date | string
  }

  export type UserInterestUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type UserInterestUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type UserInterestUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AvailabilitySlotUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekday?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvailabilitySlotUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekday?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvailabilitySlotUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekday?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchProposalUpdateWithoutProposerInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partner?: UserUpdateOneRequiredWithoutPartnerNestedInput
    appointment?: AppointmentUpdateOneWithoutProposalNestedInput
  }

  export type MatchProposalUncheckedUpdateWithoutProposerInput = {
    id?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUncheckedUpdateOneWithoutProposalNestedInput
  }

  export type MatchProposalUncheckedUpdateManyWithoutProposerInput = {
    id?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchProposalUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proposer?: UserUpdateOneRequiredWithoutProposerNestedInput
    appointment?: AppointmentUpdateOneWithoutProposalNestedInput
  }

  export type MatchProposalUncheckedUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposerId?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUncheckedUpdateOneWithoutProposalNestedInput
  }

  export type MatchProposalUncheckedUpdateManyWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposerId?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUpdateWithoutUserAInput = {
    id?: StringFieldUpdateOperationsInput | string
    place?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    checkinCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proposal?: MatchProposalUpdateOneRequiredWithoutAppointmentNestedInput
    userB?: UserUpdateOneRequiredWithoutAppointmentsBNestedInput
    checks?: AttendanceCheckUpdateManyWithoutAppointmentNestedInput
    reports?: ReportUpdateManyWithoutAppointmentNestedInput
    reviews?: ReviewUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutUserAInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposalId?: StringFieldUpdateOperationsInput | string
    userBId?: StringFieldUpdateOperationsInput | string
    place?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    checkinCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checks?: AttendanceCheckUncheckedUpdateManyWithoutAppointmentNestedInput
    reports?: ReportUncheckedUpdateManyWithoutAppointmentNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateManyWithoutUserAInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposalId?: StringFieldUpdateOperationsInput | string
    userBId?: StringFieldUpdateOperationsInput | string
    place?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    checkinCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUpdateWithoutUserBInput = {
    id?: StringFieldUpdateOperationsInput | string
    place?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    checkinCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proposal?: MatchProposalUpdateOneRequiredWithoutAppointmentNestedInput
    userA?: UserUpdateOneRequiredWithoutAppointmentsANestedInput
    checks?: AttendanceCheckUpdateManyWithoutAppointmentNestedInput
    reports?: ReportUpdateManyWithoutAppointmentNestedInput
    reviews?: ReviewUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutUserBInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposalId?: StringFieldUpdateOperationsInput | string
    userAId?: StringFieldUpdateOperationsInput | string
    place?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    checkinCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checks?: AttendanceCheckUncheckedUpdateManyWithoutAppointmentNestedInput
    reports?: ReportUncheckedUpdateManyWithoutAppointmentNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateManyWithoutUserBInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposalId?: StringFieldUpdateOperationsInput | string
    userAId?: StringFieldUpdateOperationsInput | string
    place?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    checkinCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCheckUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneRequiredWithoutChecksNestedInput
  }

  export type AttendanceCheckUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCheckUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUpdateWithoutReporterInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetUserId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneRequiredWithoutReportsNestedInput
  }

  export type ReportUncheckedUpdateWithoutReporterInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: StringFieldUpdateOperationsInput | string
    targetUserId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyWithoutReporterInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: StringFieldUpdateOperationsInput | string
    targetUserId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SanctionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumSanctionLevelFieldUpdateOperationsInput | $Enums.SanctionLevel
    reason?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SanctionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumSanctionLevelFieldUpdateOperationsInput | $Enums.SanctionLevel
    reason?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SanctionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumSanctionLevelFieldUpdateOperationsInput | $Enums.SanctionLevel
    reason?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    scoreDelta?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneRequiredWithoutReviewsNestedInput
    reviewee?: UserUpdateOneRequiredWithoutReviewsRecvNestedInput
  }

  export type ReviewUncheckedUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: StringFieldUpdateOperationsInput | string
    revieweeId?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    scoreDelta?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: StringFieldUpdateOperationsInput | string
    revieweeId?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    scoreDelta?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutRevieweeInput = {
    id?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    scoreDelta?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneRequiredWithoutReviewsNestedInput
    reviewer?: UserUpdateOneRequiredWithoutReviewsGivenNestedInput
  }

  export type ReviewUncheckedUpdateWithoutRevieweeInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: StringFieldUpdateOperationsInput | string
    reviewerId?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    scoreDelta?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutRevieweeInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: StringFieldUpdateOperationsInput | string
    reviewerId?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    scoreDelta?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCheckCreateManyAppointmentInput = {
    id?: string
    userId: string
    method: string
    checkedAt?: Date | string
  }

  export type ReportCreateManyAppointmentInput = {
    id?: string
    reporterId: string
    targetUserId: string
    reason: string
    evidence?: string | null
    status?: $Enums.ReportStatus
    createdAt?: Date | string
  }

  export type ReviewCreateManyAppointmentInput = {
    id?: string
    reviewerId: string
    revieweeId: string
    comment: string
    scoreDelta?: number
    createdAt?: Date | string
  }

  export type AttendanceCheckUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutChecksNestedInput
  }

  export type AttendanceCheckUncheckedUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCheckUncheckedUpdateManyWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetUserId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reporter?: UserUpdateOneRequiredWithoutReportsNestedInput
  }

  export type ReportUncheckedUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    reporterId?: StringFieldUpdateOperationsInput | string
    targetUserId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    reporterId?: StringFieldUpdateOperationsInput | string
    targetUserId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    scoreDelta?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewer?: UserUpdateOneRequiredWithoutReviewsGivenNestedInput
    reviewee?: UserUpdateOneRequiredWithoutReviewsRecvNestedInput
  }

  export type ReviewUncheckedUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewerId?: StringFieldUpdateOperationsInput | string
    revieweeId?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    scoreDelta?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewerId?: StringFieldUpdateOperationsInput | string
    revieweeId?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    scoreDelta?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}